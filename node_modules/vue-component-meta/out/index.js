Object.defineProperty(exports, "__esModule", { value: true });
exports.baseCreate = exports.createComponentMetaChecker = exports.createComponentMetaCheckerByJsonConfig = void 0;
const vue = require("@volar/vue-language-core");
const embedded = require("@volar/language-core");
const path = require("typesafe-path/posix");
const extraFileExtensions = [{
        extension: 'vue',
        isMixedContent: true,
        scriptKind: 7 /* ts.ScriptKind.Deferred */,
    }];
function createComponentMetaCheckerByJsonConfig(root, json, checkerOptions = {}, ts = require('typescript')) {
    return createComponentMetaCheckerWorker(() => vue.createParsedCommandLineByJson(ts, ts.sys, root, json, extraFileExtensions), checkerOptions, path.join(root.replace(/\\/g, '/'), 'jsconfig.json.global.vue'), ts);
}
exports.createComponentMetaCheckerByJsonConfig = createComponentMetaCheckerByJsonConfig;
function createComponentMetaChecker(tsconfigPath, checkerOptions = {}, ts = require('typescript')) {
    return createComponentMetaCheckerWorker(() => vue.createParsedCommandLine(ts, ts.sys, tsconfigPath, extraFileExtensions), checkerOptions, tsconfigPath.replace(/\\/g, '/') + '.global.vue', ts);
}
exports.createComponentMetaChecker = createComponentMetaChecker;
function createComponentMetaCheckerWorker(loadParsedCommandLine, checkerOptions, globalComponentName, ts) {
    /**
     * Original Host
     */
    let parsedCommandLine = loadParsedCommandLine();
    let fileNames = parsedCommandLine.fileNames.map(path => path.replace(/\\/g, '/'));
    let projectVersion = 0;
    const scriptSnapshots = new Map();
    const scriptVersions = new Map();
    const _host = Object.assign(Object.assign({}, ts.sys), { getProjectVersion: () => projectVersion.toString(), getDefaultLibFileName: (options) => ts.getDefaultLibFilePath(options), useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames, getCompilationSettings: () => parsedCommandLine.options, getScriptFileNames: () => fileNames, getProjectReferences: () => parsedCommandLine.projectReferences, getScriptVersion: (fileName) => { var _a, _b; return (_b = (_a = scriptVersions.get(fileName)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''; }, getScriptSnapshot: (fileName) => {
            if (!scriptSnapshots.has(fileName)) {
                const fileText = ts.sys.readFile(fileName);
                if (fileText !== undefined) {
                    scriptSnapshots.set(fileName, ts.ScriptSnapshot.fromString(fileText));
                }
            }
            return scriptSnapshots.get(fileName);
        }, getTypeScriptModule: () => ts, getVueCompilationSettings: () => parsedCommandLine.vueOptions });
    return Object.assign(Object.assign({}, baseCreate(_host, checkerOptions, globalComponentName, ts)), { updateFile(fileName, text) {
            fileName = fileName.replace(/\\/g, '/');
            scriptSnapshots.set(fileName, ts.ScriptSnapshot.fromString(text));
            scriptVersions.set(fileName, scriptVersions.has(fileName) ? scriptVersions.get(fileName) + 1 : 1);
            projectVersion++;
        },
        deleteFile(fileName) {
            fileName = fileName.replace(/\\/g, '/');
            fileNames = fileNames.filter(f => f !== fileName);
            projectVersion++;
        },
        reload() {
            parsedCommandLine = loadParsedCommandLine();
            fileNames = parsedCommandLine.fileNames.map(path => path.replace(/\\/g, '/'));
            this.clearCache();
        },
        clearCache() {
            scriptSnapshots.clear();
            scriptVersions.clear();
            projectVersion++;
        } });
}
function baseCreate(_host, checkerOptions, globalComponentName, ts) {
    /**
     * Meta
     */
    const globalComponentSnapshot = ts.ScriptSnapshot.fromString('<script setup lang="ts"></script>');
    const metaSnapshots = {};
    const host = new Proxy({
        getScriptFileNames: () => {
            const names = _host.getScriptFileNames();
            return [
                ...names,
                ...names.map(getMetaFileName),
                globalComponentName,
                getMetaFileName(globalComponentName),
            ];
        },
        getScriptSnapshot: fileName => {
            if (isMetaFileName(fileName)) {
                if (!metaSnapshots[fileName]) {
                    metaSnapshots[fileName] = ts.ScriptSnapshot.fromString(getMetaScriptContent(fileName));
                }
                return metaSnapshots[fileName];
            }
            else if (fileName === globalComponentName) {
                return globalComponentSnapshot;
            }
            else {
                return _host.getScriptSnapshot(fileName);
            }
        },
    }, {
        get(target, prop) {
            if (prop in target) {
                return target[prop];
            }
            return _host[prop];
        },
    });
    const vueLanguageModules = vue.createLanguageModules(host.getTypeScriptModule(), host.getCurrentDirectory(), host.getCompilationSettings(), host.getVueCompilationSettings());
    const core = embedded.createLanguageContext(host, vueLanguageModules);
    const proxyApis = checkerOptions.forceUseTs ? {
        getScriptKind: (fileName) => {
            if (fileName.endsWith('.vue.js')) {
                return ts.ScriptKind.TS;
            }
            if (fileName.endsWith('.vue.jsx')) {
                return ts.ScriptKind.TSX;
            }
            return core.typescript.languageServiceHost.getScriptKind(fileName);
        },
    } : {};
    const proxyHost = new Proxy(core.typescript.languageServiceHost, {
        get(target, propKey) {
            if (propKey in proxyApis) {
                return proxyApis[propKey];
            }
            return target[propKey];
        }
    });
    const tsLs = ts.createLanguageService(proxyHost);
    let globalPropNames = [];
    globalPropNames = getComponentMeta(globalComponentName).props.map(prop => prop.name);
    return {
        getExportNames,
        getComponentMeta,
        __internal__: {
            tsLs,
        },
    };
    function isMetaFileName(fileName) {
        return fileName.endsWith('.meta.ts');
    }
    function getMetaFileName(fileName) {
        return (fileName.endsWith('.vue') ? fileName : fileName.substring(0, fileName.lastIndexOf('.'))) + '.meta.ts';
    }
    function getMetaScriptContent(fileName) {
        return `
			import * as Components from '${fileName.substring(0, fileName.length - '.meta.ts'.length)}';
			export default {} as { [K in keyof typeof Components]: InstanceType<typeof Components[K]>; };
		`;
    }
    function getExportNames(componentPath) {
        const program = tsLs.getProgram();
        const typeChecker = program.getTypeChecker();
        return _getExports(program, typeChecker, componentPath).exports.map(e => e.getName());
    }
    function getComponentMeta(componentPath, exportName = 'default') {
        var _a;
        const program = tsLs.getProgram();
        const typeChecker = program.getTypeChecker();
        const { symbolNode, exports } = _getExports(program, typeChecker, componentPath);
        const _export = exports.find((property) => property.getName() === exportName);
        if (!_export) {
            throw `Could not find export ${exportName}`;
        }
        const componentType = typeChecker.getTypeOfSymbolAtLocation(_export, symbolNode);
        const symbolProperties = (_a = componentType.getProperties()) !== null && _a !== void 0 ? _a : [];
        return {
            props: getProps(),
            events: getEvents(),
            slots: getSlots(),
            exposed: getExposed(),
        };
        function getProps() {
            var _a;
            const $props = symbolProperties.find(prop => prop.escapedName === '$props');
            const propEventRegex = /^(on[A-Z])/;
            let result = [];
            if ($props) {
                const type = typeChecker.getTypeOfSymbolAtLocation($props, symbolNode);
                const properties = type.getProperties();
                result = properties
                    .map((prop) => {
                    const { resolveNestedProperties, } = createSchemaResolvers(typeChecker, symbolNode, checkerOptions, ts);
                    return resolveNestedProperties(prop);
                })
                    .filter((prop) => !prop.name.match(propEventRegex));
            }
            // fill global
            for (const prop of result) {
                prop.global = globalPropNames.includes(prop.name);
            }
            // fill defaults
            const printer = ts.createPrinter(checkerOptions.printer);
            const snapshot = host.getScriptSnapshot(componentPath);
            const vueSourceFile = (_a = core.virtualFiles.get(componentPath)) === null || _a === void 0 ? void 0 : _a[1];
            const vueDefaults = vueSourceFile && exportName === 'default'
                ? (vueSourceFile instanceof vue.VueFile ? readVueComponentDefaultProps(vueSourceFile, printer, ts) : {})
                : {};
            const tsDefaults = !vueSourceFile ? readTsComponentDefaultProps(componentPath.substring(componentPath.lastIndexOf('.') + 1), // ts | js | tsx | jsx
            snapshot.getText(0, snapshot.getLength()), exportName, printer, ts) : {};
            for (const [propName, defaultExp] of Object.entries(Object.assign(Object.assign({}, vueDefaults), tsDefaults))) {
                const prop = result.find(p => p.name === propName);
                if (prop) {
                    prop.default = defaultExp.default;
                    if (defaultExp.required !== undefined) {
                        prop.required = defaultExp.required;
                    }
                    if (prop.default !== undefined) {
                        prop.required = false; // props with default are always optional
                    }
                }
            }
            return result;
        }
        function getEvents() {
            const $emit = symbolProperties.find(prop => prop.escapedName === '$emit');
            if ($emit) {
                const type = typeChecker.getTypeOfSymbolAtLocation($emit, symbolNode);
                const calls = type.getCallSignatures();
                return calls.map((call) => {
                    const { resolveEventSignature, } = createSchemaResolvers(typeChecker, symbolNode, checkerOptions, ts);
                    return resolveEventSignature(call);
                }).filter(event => event.name);
            }
            return [];
        }
        function getSlots() {
            var _a;
            const target = (_a = _host.getVueCompilationSettings().target) !== null && _a !== void 0 ? _a : 3;
            const propertyName = target < 3 ? '$scopedSlots' : '$slots';
            const $slots = symbolProperties.find(prop => prop.escapedName === propertyName);
            if ($slots) {
                const type = typeChecker.getTypeOfSymbolAtLocation($slots, symbolNode);
                const properties = type.getProperties();
                return properties.map((prop) => {
                    const { resolveSlotProperties, } = createSchemaResolvers(typeChecker, symbolNode, checkerOptions, ts);
                    return resolveSlotProperties(prop);
                });
            }
            return [];
        }
        function getExposed() {
            const exposed = symbolProperties.filter(prop => 
            // only exposed props will have a syntheticOrigin
            Boolean(prop.syntheticOrigin));
            if (exposed.length) {
                return exposed.map((prop) => {
                    const { resolveExposedProperties, } = createSchemaResolvers(typeChecker, symbolNode, checkerOptions, ts);
                    return resolveExposedProperties(prop);
                });
            }
            return [];
        }
    }
    function _getExports(program, typeChecker, componentPath) {
        var _a;
        const sourceFile = program === null || program === void 0 ? void 0 : program.getSourceFile(getMetaFileName(componentPath));
        if (!sourceFile) {
            throw 'Could not find main source file';
        }
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) {
            throw 'Could not find module symbol';
        }
        const exportedSymbols = typeChecker.getExportsOfModule(moduleSymbol);
        let symbolNode;
        for (const symbol of exportedSymbols) {
            const [declaration] = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];
            if (ts.isExportAssignment(declaration)) {
                symbolNode = declaration.expression;
            }
        }
        if (!symbolNode) {
            throw 'Could not find symbol node';
        }
        const exportDefaultType = typeChecker.getTypeAtLocation(symbolNode);
        const exports = exportDefaultType.getProperties();
        return {
            symbolNode,
            exports,
        };
    }
}
exports.baseCreate = baseCreate;
function createSchemaResolvers(typeChecker, symbolNode, { rawType, schema: options }, ts) {
    var _a;
    const enabled = !!options;
    const ignore = typeof options === 'object' ? [...(_a = options === null || options === void 0 ? void 0 : options.ignore) !== null && _a !== void 0 ? _a : []] : [];
    function shouldIgnore(subtype) {
        const name = typeChecker.typeToString(subtype);
        if (name === 'any') {
            return true;
        }
        if (ignore.length === 0) {
            return false;
        }
        for (const item of ignore) {
            if (typeof item === 'function') {
                const result = item(name, subtype, typeChecker);
                if (result != null)
                    return result;
            }
            else if (name === item) {
                return true;
            }
        }
        return false;
    }
    function setVisited(subtype) {
        const type = typeChecker.typeToString(subtype);
        ignore.push(type);
    }
    function reducer(acc, cur) {
        acc[cur.name] = cur;
        return acc;
    }
    function resolveNestedProperties(prop) {
        const subtype = typeChecker.getTypeOfSymbolAtLocation(prop, symbolNode);
        const schema = enabled ? resolveSchema(subtype) : undefined;
        return {
            name: prop.getEscapedName().toString(),
            global: false,
            description: ts.displayPartsToString(prop.getDocumentationComment(typeChecker)),
            tags: prop.getJsDocTags(typeChecker).map(tag => {
                var _a;
                return ({
                    name: tag.name,
                    text: (_a = tag.text) === null || _a === void 0 ? void 0 : _a.map(part => part.text).join(''),
                });
            }),
            required: !(prop.flags & ts.SymbolFlags.Optional),
            type: typeChecker.typeToString(subtype),
            rawType: rawType ? subtype : undefined,
            schema,
        };
    }
    function resolveSlotProperties(prop) {
        const subtype = typeChecker.getTypeOfSymbolAtLocation(typeChecker.getTypeOfSymbolAtLocation(prop, symbolNode).getCallSignatures()[0].parameters[0], symbolNode);
        const schema = enabled ? resolveSchema(subtype) : undefined;
        return {
            name: prop.getName(),
            type: typeChecker.typeToString(subtype),
            rawType: rawType ? subtype : undefined,
            description: ts.displayPartsToString(prop.getDocumentationComment(typeChecker)),
            schema,
        };
    }
    function resolveExposedProperties(expose) {
        const subtype = typeChecker.getTypeOfSymbolAtLocation(expose, symbolNode);
        const schema = enabled ? resolveSchema(subtype) : undefined;
        return {
            name: expose.getName(),
            type: typeChecker.typeToString(subtype),
            rawType: rawType ? subtype : undefined,
            description: ts.displayPartsToString(expose.getDocumentationComment(typeChecker)),
            schema,
        };
    }
    function resolveEventSignature(call) {
        const subtype = typeChecker.getTypeOfSymbolAtLocation(call.parameters[1], symbolNode);
        const schema = enabled
            ? typeChecker.getTypeArguments(subtype).map(resolveSchema)
            : undefined;
        return {
            name: typeChecker.getTypeOfSymbolAtLocation(call.parameters[0], symbolNode).value,
            type: typeChecker.typeToString(subtype),
            rawType: rawType ? subtype : undefined,
            signature: typeChecker.signatureToString(call),
            schema,
        };
    }
    function resolveCallbackSchema(signature) {
        const schema = enabled && signature.parameters.length > 0
            ? typeChecker
                .getTypeArguments(typeChecker.getTypeOfSymbolAtLocation(signature.parameters[0], symbolNode))
                .map(resolveSchema)
            : undefined;
        return {
            kind: 'event',
            type: typeChecker.signatureToString(signature),
            schema,
        };
    }
    function resolveSchema(subtype) {
        const type = typeChecker.typeToString(subtype);
        let schema = type;
        if (shouldIgnore(subtype)) {
            return type;
        }
        setVisited(subtype);
        if (subtype.isUnion()) {
            schema = {
                kind: 'enum',
                type,
                schema: subtype.types.map(resolveSchema)
            };
        }
        // @ts-ignore - typescript internal, isArrayLikeType exists
        else if (typeChecker.isArrayLikeType(subtype)) {
            schema = {
                kind: 'array',
                type,
                schema: typeChecker.getTypeArguments(subtype).map(resolveSchema)
            };
        }
        else if (subtype.getCallSignatures().length === 0 &&
            (subtype.isClassOrInterface() || subtype.isIntersection() || subtype.objectFlags & ts.ObjectFlags.Anonymous)) {
            // setVisited(subtype);
            schema = {
                kind: 'object',
                type,
                schema: subtype.getProperties().map(resolveNestedProperties).reduce(reducer, {})
            };
        }
        else if (subtype.getCallSignatures().length === 1) {
            schema = resolveCallbackSchema(subtype.getCallSignatures()[0]);
        }
        return schema;
    }
    return {
        resolveNestedProperties,
        resolveSlotProperties,
        resolveEventSignature,
        resolveExposedProperties,
        resolveSchema,
    };
}
function readVueComponentDefaultProps(vueSourceFile, printer, ts) {
    let result = {};
    scriptSetupWorker();
    scriptWorker();
    return result;
    function scriptSetupWorker() {
        var _a;
        const descriptor = vueSourceFile.sfc;
        const scriptSetupRanges = descriptor.scriptSetupAst ? vue.parseScriptSetupRanges(ts, descriptor.scriptSetupAst) : undefined;
        if (descriptor.scriptSetup && (scriptSetupRanges === null || scriptSetupRanges === void 0 ? void 0 : scriptSetupRanges.withDefaultsArg)) {
            const defaultsText = descriptor.scriptSetup.content.substring(scriptSetupRanges.withDefaultsArg.start, scriptSetupRanges.withDefaultsArg.end);
            const ast = ts.createSourceFile('/tmp.' + descriptor.scriptSetup.lang, '(' + defaultsText + ')', ts.ScriptTarget.Latest);
            const obj = findObjectLiteralExpression(ast);
            if (obj) {
                for (const prop of obj.properties) {
                    if (ts.isPropertyAssignment(prop)) {
                        const name = prop.name.getText(ast);
                        const expNode = resolveDefaultOptionExpression(prop.initializer, ts);
                        const expText = (_a = printer === null || printer === void 0 ? void 0 : printer.printNode(ts.EmitHint.Expression, expNode, ast)) !== null && _a !== void 0 ? _a : expNode.getText(ast);
                        result[name] = {
                            default: expText,
                        };
                    }
                }
            }
        }
        else if (descriptor.scriptSetup && (scriptSetupRanges === null || scriptSetupRanges === void 0 ? void 0 : scriptSetupRanges.propsRuntimeArg)) {
            const defaultsText = descriptor.scriptSetup.content.substring(scriptSetupRanges.propsRuntimeArg.start, scriptSetupRanges.propsRuntimeArg.end);
            const ast = ts.createSourceFile('/tmp.' + descriptor.scriptSetup.lang, '(' + defaultsText + ')', ts.ScriptTarget.Latest);
            const obj = findObjectLiteralExpression(ast);
            if (obj) {
                result = Object.assign(Object.assign({}, result), resolvePropsOption(ast, obj, printer, ts));
            }
        }
        function findObjectLiteralExpression(node) {
            if (ts.isObjectLiteralExpression(node)) {
                return node;
            }
            let result;
            node.forEachChild(child => {
                if (!result) {
                    result = findObjectLiteralExpression(child);
                }
            });
            return result;
        }
    }
    function scriptWorker() {
        const descriptor = vueSourceFile.sfc;
        if (descriptor.script) {
            const scriptResult = readTsComponentDefaultProps(descriptor.script.lang, descriptor.script.content, 'default', printer, ts);
            for (const [key, value] of Object.entries(scriptResult)) {
                result[key] = value;
            }
        }
    }
}
function readTsComponentDefaultProps(lang, tsFileText, exportName, printer, ts) {
    const ast = ts.createSourceFile('/tmp.' + lang, tsFileText, ts.ScriptTarget.Latest);
    const props = getPropsNode();
    if (props) {
        return resolvePropsOption(ast, props, printer, ts);
    }
    return {};
    function getComponentNode() {
        let result;
        if (exportName === 'default') {
            ast.forEachChild(child => {
                if (ts.isExportAssignment(child)) {
                    result = child.expression;
                }
            });
        }
        else {
            ast.forEachChild(child => {
                var _a;
                if (ts.isVariableStatement(child)
                    && ((_a = child.modifiers) === null || _a === void 0 ? void 0 : _a.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword))) {
                    for (const dec of child.declarationList.declarations) {
                        if (dec.name.getText(ast) === exportName) {
                            result = dec.initializer;
                        }
                    }
                }
            });
        }
        return result;
    }
    function getComponentOptionsNode() {
        const component = getComponentNode();
        if (component) {
            // export default { ... }
            if (ts.isObjectLiteralExpression(component)) {
                return component;
            }
            // export default defineComponent({ ... })
            // export default Vue.extend({ ... })
            else if (ts.isCallExpression(component)) {
                if (component.arguments.length) {
                    const arg = component.arguments[0];
                    if (ts.isObjectLiteralExpression(arg)) {
                        return arg;
                    }
                }
            }
        }
    }
    function getPropsNode() {
        const options = getComponentOptionsNode();
        const props = options === null || options === void 0 ? void 0 : options.properties.find(prop => { var _a; return ((_a = prop.name) === null || _a === void 0 ? void 0 : _a.getText(ast)) === 'props'; });
        if (props && ts.isPropertyAssignment(props)) {
            if (ts.isObjectLiteralExpression(props.initializer)) {
                return props.initializer;
            }
        }
    }
}
function resolvePropsOption(ast, props, printer, ts) {
    var _a, _b;
    const result = {};
    for (const prop of props.properties) {
        if (ts.isPropertyAssignment(prop)) {
            const name = (_a = prop.name) === null || _a === void 0 ? void 0 : _a.getText(ast);
            if (ts.isObjectLiteralExpression(prop.initializer)) {
                const defaultProp = prop.initializer.properties.find(p => ts.isPropertyAssignment(p) && p.name.getText(ast) === 'default');
                const requiredProp = prop.initializer.properties.find(p => ts.isPropertyAssignment(p) && p.name.getText(ast) === 'required');
                result[name] = {};
                if (requiredProp) {
                    const exp = requiredProp.initializer.getText(ast);
                    result[name].required = exp === 'true';
                }
                if (defaultProp) {
                    const expNode = resolveDefaultOptionExpression(defaultProp.initializer, ts);
                    const expText = (_b = printer === null || printer === void 0 ? void 0 : printer.printNode(ts.EmitHint.Expression, expNode, ast)) !== null && _b !== void 0 ? _b : expNode.getText(ast);
                    result[name].default = expText;
                }
            }
        }
    }
    return result;
}
function resolveDefaultOptionExpression(_default, ts) {
    if (ts.isArrowFunction(_default)) {
        if (ts.isBlock(_default.body)) {
            return _default; // TODO
        }
        else if (ts.isParenthesizedExpression(_default.body)) {
            return _default.body.expression;
        }
        else {
            return _default.body;
        }
    }
    return _default;
}
//# sourceMappingURL=index.js.map