import chalk from 'chalk';
import path from 'path';
import Color from 'tinycolor2';
import * as _ChangeCase from 'change-case';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { resolve, dirname, join } from 'pathe';
import _template from 'lodash.template';
import fs$1 from 'fs-extra';
import consola from 'consola';
import JSON5 from 'json5';
import { parse } from 'jsonc-parser';
import jiti from 'jiti';
import glob from 'glob';

var version = "1.0.14";

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
const groupedMessages = {};

const GroupMessages = {
  GROUP: {
    PropertyReferenceWarnings: 'Property Reference Errors',
    PropertyValueCollisions: 'Property Value Collisions',
    TemplateDeprecationWarnings: 'Template Deprecation Warnings',
    RegisterTemplateDeprecationWarnings: 'Register Template Deprecation Warnings',
    SassMapFormatDeprecationWarnings: 'Sass Map Format Deprecation Warnings',
    MissingRegisterTransformErrors: 'Missing Register Transform Errors',
    PropertyNameCollisionWarnings: 'Property Name Collision Warnings',
    FilteredOutputReferences: 'Filtered Output Reference Warnings',
  },

  flush(messageGroup) {
    const messages = GroupMessages.fetchMessages(messageGroup);
    GroupMessages.clear(messageGroup);
    return messages
  },

  add(messageGroup, message) {
    if (messageGroup) {
      if (!groupedMessages[messageGroup])
        groupedMessages[messageGroup] = [];

      if (!groupedMessages[messageGroup].includes(message))
        groupedMessages[messageGroup].push(message);
    }
  },

  count(messageGroup) {
    return groupedMessages[messageGroup] ? groupedMessages[messageGroup].length : 0
  },

  fetchMessages(messageGroup) {
    return (messageGroup && groupedMessages[messageGroup]) || []
  },

  clear(messageGroup) {
    messageGroup && groupedMessages[messageGroup] && delete groupedMessages[messageGroup];
  },
};

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const ChangeCase = _ChangeCase;

function reduce(obj, f, accumulator_init) {
  return Object.keys(obj || {}).reduce((accumulator, key) => {
    const value = obj[key];
    return f(accumulator, value, key, obj)
  }, accumulator_init)
}

// Note: This is a crappy version to a certain extent... don't use with Strings, for example...
function clone(object) {
  return Object.assign(new object.constructor(), object)
}

function cloneDeep(obj) {
  if (obj === null || obj === undefined || typeof obj !== 'object')
    return obj

  if (Array.isArray(obj)) {
    return obj.reduce((arr, item, i) => {
      arr[i] = cloneDeep(item);
      return arr
    }, [])
  }

  if (obj instanceof Object) {
    return Object.keys(obj || {}).reduce((cpObj, key) => {
      cpObj[key] = cloneDeep(obj[key]);
      return cpObj
    }, {})
  }
}

function isObject(value) {
  const type = typeof value;
  return value != null && (type === 'object' || type === 'function')
}

function isString(obj) {
  return typeof obj === 'string' || obj instanceof String
}

function isArray(obj) {
  return Array.isArray(obj)
}

function isEmpty(obj) {
  return [Object, Array].includes((obj || {}).constructor) && !Object.entries((obj || {})).length
}

function isPlainObject(value) {
  if (typeof value !== 'object' || value === null || Object.prototype.toString.call(value) !== '[object Object]')
    return false

  if (Object.getPrototypeOf(value) === null)
    return true

  let proto = value;
  while (Object.getPrototypeOf(proto) !== null)
    proto = Object.getPrototypeOf(proto);

  return Object.getPrototypeOf(value) === proto
}

function filter$1(arr, filter) {
  if (typeof (filter) !== 'function')
    throw new Error('filter is not a function')

  if (typeof arr === 'undefined')
    return []

  return arr.filter(filter)
}

function assign(...props) {
  return Object.assign({}, ...props)
}

function pull(arr, ...removeList) {
  const removeSet = new Set(removeList);
  for (let i = arr.length - 1; i >= 0; i--) {
    if (removeSet.has(arr[i]))
      arr.splice(i, 1);
  }
}

function unique(arr) {
  return [...new Set(arr)]
}

function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.substr(1) : ''
}

function matchFn(inputObj, testObj) {
  if (isObject(testObj))
    return Object.keys(testObj).every(key => matchFn(inputObj[key], testObj[key]))

  else
    return inputObj === testObj
}

function matches(matchObj) {
  const cloneObj = cloneDeep(matchObj);
  const matchesFn = inputObj => matchFn(inputObj, cloneObj);
  return matchesFn
}

const DEFAULT_OPTIONS = {
  transform: ChangeCase.camelCaseTransformMerge,
};

function changeDefaultCaseTransform(caseFunction, default_options) {
  return (caseToChange, options) => caseFunction(caseToChange, Object.assign({}, DEFAULT_OPTIONS, default_options, options))
}
const camelCase = changeDefaultCaseTransform(ChangeCase.camelCase);
const snakeCase = ChangeCase.snakeCase;
const kebabCase = ChangeCase.paramCase;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes a file and converts it to a base64 string.
 * @private
 * @param {String} filePath - Path to the file you want base64'd
 * @returns {String}
 */
function convertToBase64(filePath) {
  if (typeof filePath !== 'string')
    throw new Error('filePath name must be a string')

  const body = fs.readFileSync(filePath, 'binary');
  return Buffer.from(body, 'binary').toString('base64')
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const UNICODE_PATTERN = /&#x([^;]+);/g;

function isColor(token) {
  return token.attributes.category === 'color'
}

function isSize(token) {
  return token.attributes.category === 'size'
}

function isFontSize(token) {
  return token.attributes.category === 'size'
    && (token.attributes.type === 'font' || token.attributes.type === 'icon')
}

function isNotFontSize(token) {
  return token.attributes.category === 'size'
    && token.attributes.type !== 'font'
    && token.attributes.type !== 'icon'
}

function isAsset(token) {
  return token.attributes.category === 'asset'
}

function isContent(token) {
  return token.attributes.category === 'content'
}

function wrapValueWith(character, token) {
  return `${character}${token.value}${character}`
}

function wrapValueWithDoubleQuote(token) {
  return wrapValueWith('"', token)
}

function throwSizeError(name, value, unitType) {
  throw new Error(`Invalid Number: '${name}: ${value}' is not a valid number, cannot transform to '${unitType}' \n`)
}

function getBasePxFontSize(options) {
  return (options && options.basePxFontSize) || 16
}

/**
 * @namespace Transforms
 */
var transform = {
  /**
   * Adds: category, type, item, subitem, and state on the attributes object based on the location in the style dictionary.
   *
   * ```js
   * // Matches: all
   * // Returns:
   * {
   *   "category": "color",
   *   "type": "background",
   *   "item": "button",
   *   "subitem": "primary",
   *   "state": "active"
   * }
   * ```
   *
   * @memberof Transforms
   */
  'attribute/cti': {
    type: 'attribute',
    transformer(token) {
      const attrNames = ['category', 'type', 'item', 'subitem', 'state'];
      const originalAttrs = token.attributes || {};
      const generatedAttrs = {};

      for (let i = 0; i < token.path.length && i < attrNames.length; i++)
        generatedAttrs[attrNames[i]] = token.path[i];

      return Object.assign(generatedAttrs, originalAttrs)
    },
  },

  /**
   * Adds: hex, hsl, hsv, rgb, red, blue, green.
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns
   * {
   *   "hex": "009688",
   *   "rgb": {"r": 0, "g": 150, "b": 136, "a": 1},
   *   "hsl": {"h": 174.4, "s": 1, "l": 0.294, "a": 1},
   *   "hsv": {"h": 174.4, "s": 1, "l": 0.588, "a": 1},
   * }
   * ```
   *
   * @memberof Transforms
   */
  'attribute/color': {
    type: 'attribute',
    matcher: isColor,
    transformer(token) {
      const color = Color(token.value);
      return {
        hex: color.toHex(),
        rgb: color.toRgb(),
        hsl: color.toHsl(),
        hsv: color.toHsv(),
      }
    },
  },

  /**
   * Creates a human-friendly name
   *
   * ```js
   * // Matches: All
   * // Returns:
   * "button primary"
   * ```
   *
   * @memberof Transforms
   */
  'name/human': {
    type: 'name',
    transformer(token) {
      return [
        token.attributes.item,
        token.attributes.subitem,
      ].join(' ')
    },
  },

  /**
   * Creates a camel case name. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "colorBackgroundButtonPrimaryActive"
   * "prefixColorBackgroundButtonPrimaryActive"
   * ```
   *
   * @memberof Transforms
   */
  'name/cti/camel': {
    type: 'name',
    transformer(token, options) {
      return camelCase([options.prefix].concat(token.path).join(' '))
    },
  },

  /**
   * Creates a camel case name without the category at the front.  This is most useful when there is a class, struct, enum, etc.
   * that already has the category in it (e.g., StyleDictionaryColors.baseDarkRed instad of StyleDictionaryColors.colorBaseDarkRed).
   * If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "backgroundButtonPrimaryActive"
   * "prefixBackgroundButtonPrimaryActive"
   * ```
   *
   * @memberof Transforms
   */
  'name/ti/camel': {
    type: 'name',
    transformer(token, options) {
      return camelCase([options.prefix].concat(token.path.slice(1, token.path.length)).join(' '))
    },
  },

  /**
   * Creates a kebab case name. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "color-background-button-primary-active"
   * "prefix-color-background-button-primary-active"
   * ```
   *
   * @memberof Transforms
   */
  'name/cti/kebab': {
    type: 'name',
    transformer(token, options) {
      return kebabCase([options.prefix].concat(token.path).join(' '))
    },
  },

  /**
   * Creates a snake case name. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "color_background_button_primary_active"
   * "prefix_color_background_button_primary_active"
   * ```
   *
   * @memberof Transforms
   */
  'name/cti/snake': {
    type: 'name',
    transformer(token, options) {
      return snakeCase([options.prefix].concat(token.path).join(' '))
    },
  },

  /**
   * Creates a constant-style name based on the full CTI of the token. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "COLOR_BACKGROUND_BUTTON_PRIMARY_ACTIVE"
   * "PREFIX_COLOR_BACKGROUND_BUTTON_PRIMARY_ACTIVE"
   * ```
   *
   * @memberof Transforms
   */
  'name/cti/constant': {
    type: 'name',
    transformer(token, options) {
      return snakeCase([options.prefix].concat(token.path).join(' ')).toUpperCase()
    },
  },

  /**
   * Creates a constant-style name on the type and item of the token. This is useful if you want to create different static classes/files for categories like `Color.BACKGROUND_BASE`. If you define a prefix on the platform in your config, it will prepend with your prefix.
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "BACKGROUND_BUTTON_PRIMARY_ACTIVE"
   * "PREFIX_BACKGROUND_BUTTON_PRIMARY_ACTIVE"
   * ```
   *
   * @memberof Transforms
   */
  'name/ti/constant': {
    type: 'name',
    transformer(token, options) {
      const path = token.path.slice(1);
      return snakeCase([options.prefix].concat(path).join(' ')).toUpperCase()
    },
  },

  /**
   * Creates a Pascal case name. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "ColorBackgroundButtonPrimaryActive"
   * "PrefixColorBackgroundButtonPrimaryActive"
   * ```
   *
   * @memberof Transforms
   */
  'name/cti/pascal': {
    type: 'name',
    transformer(token, options) {
      return upperFirst(camelCase([options.prefix].concat(token.path).join(' ')))
    },
  },

  /**
   * Transforms the value into an RGB string
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "rgb(0, 150, 136)"
   * ```
   *
   * @memberof Transforms
   */
  'color/rgb': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      return Color(token.value).toRgbString()
    },
  },

  /**
   * Transforms the value into an HSL string or HSLA if alpha is present. Better browser support than color/hsl-4
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "hsl(174, 100%, 29%)"
   * "hsl(174, 100%, 29%, .5)"
   * ```
   *
   * @memberof Transforms
   */
  'color/hsl': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      return Color(token.value).toHslString()
    },
  },

  /**
   * Transforms the value into an HSL string, using fourth argument if alpha is present.
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "hsl(174 100% 29%)"
   * "hsl(174 100% 29% / .5)"
   * ```
   *
   * @memberof Transforms
   */
  'color/hsl-4': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      const color = Color(token.value);
      const o = color.toHsl();
      const vals = `${Math.round(o.h)} ${Math.round(o.s * 100)}% ${Math.round(o.l * 100)}%`;
      if (color.getAlpha() === 1)
        return `hsl(${vals})`
      else
        return `hsl(${vals} / ${o.a})`
    },
  },

  /**
   * Transforms the value into an 6-digit hex string
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "#009688"
   * ```
   *
   * @memberof Transforms
   */
  'color/hex': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      return Color(token.value).toHexString()
    },
  },

  /**
   * Transforms the value into an 8-digit hex string
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "#009688ff"
   * ```
   *
   * @memberof Transforms
   */
  'color/hex8': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      return Color(token.value).toHex8String()
    },
  },

  /**
   * Transforms the value into an 8-digit hex string for Android because they put the alpha channel first
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "#ff009688"
   * ```
   *
   * @memberof Transforms
   */
  'color/hex8android': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      const str = Color(token.value).toHex8();
      return `#${str.slice(6)}${str.slice(0, 6)}`
    },
  },

  /**
   * Transforms the value into a Color class for Compose
   *
   * ```kotlin
   * // Matches: prop.attributes.category === 'color'
   * // Returns:
   * Color(0xFF009688)
   * ```
   *
   * @memberof Transforms
   */
  'color/composeColor': {
    type: 'value',
    matcher: isColor,
    transformer(prop) {
      const str = Color(prop.value).toHex8();
      return `Color(0x${str.slice(6)}${str.slice(0, 6)})`
    },
  },

  /**
   * Transforms the value into an UIColor class for iOS
   *
   * ```objectivec
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * [UIColor colorWithRed:0.114f green:0.114f blue:0.114f alpha:1.000f]
   * ```
   *
   * @memberof Transforms
   */
  'color/UIColor': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      const rgb = Color(token.value).toRgb();
      return `[UIColor colorWithRed:${(rgb.r / 255).toFixed(3)}f`
             + ` green:${(rgb.g / 255).toFixed(3)}f`
             + ` blue:${(rgb.b / 255).toFixed(3)}f`
             + ` alpha:${rgb.a.toFixed(3)}f]`
    },
  },

  /**
   * Transforms the value into an UIColor swift class for iOS
   *
   * ```swift
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * UIColor(red: 0.667, green: 0.667, blue: 0.667, alpha: 0.6)
   * ```
   *
   * @memberof Transforms
   */
  'color/UIColorSwift': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      const { r, g, b, a } = Color(token.value).toRgb();
      const rFixed = (r / 255.0).toFixed(3);
      const gFixed = (g / 255.0).toFixed(3);
      const bFixed = (b / 255.0).toFixed(3);
      return `UIColor(red: ${rFixed}, green: ${gFixed}, blue: ${bFixed}, alpha: ${a})`
    },
  },

  /**
   * Transforms the value into an UIColor swift class for iOS
   *
   * ```swift
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * Color(red: 0.667, green: 0.667, blue: 0.667, opacity: 0.6)
   * ```
   *
   * @memberof Transforms
   */
  'color/ColorSwiftUI': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      const { r, g, b, a } = Color(token.value).toRgb();
      const rFixed = (r / 255.0).toFixed(3);
      const gFixed = (g / 255.0).toFixed(3);
      const bFixed = (b / 255.0).toFixed(3);
      return `Color(red: ${rFixed}, green: ${gFixed}, blue: ${bFixed}, opacity: ${a})`
    },
  },

  /**
   * Transforms the value into a hex or rgb string depending on if it has transparency
   *
   * ```css
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * #000000
   * rgba(0,0,0,0.5)
   * ```
   *
   * @memberof Transforms
   */
  'color/css': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      const color = Color(token.value);
      if (color.getAlpha() === 1)
        return color.toHexString()
      else
        return color.toRgbString()
    },
  },

  /**
   *
   * Transforms a color into an object with red, green, blue, and alpha
   * attributes that are floats from 0 - 1. This object is how Sketch stores
   * colors.
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * {
   *   red: 0.5,
   *   green: 0.5,
   *   blue: 0.5,
   *   alpha: 1
   * }
   * ```
   * @memberof Transforms
   */
  'color/sketch': {
    type: 'value',
    matcher: token => token.attributes.category === 'color',
    transformer(token) {
      const color = Color(token.original.value).toRgb();
      return {
        red: (color.r / 255).toFixed(5),
        green: (color.g / 255).toFixed(5),
        blue: (color.b / 255).toFixed(5),
        alpha: color.a,
      }
    },
  },

  /**
   * Transforms the value into a scale-independent pixel (sp) value for font sizes on Android. It will not scale the number.
   *
   * ```js
   * // Matches: token.attributes.category === 'size' && token.attributes.type === 'font'
   * // Returns:
   * "10.0sp"
   * ```
   *
   * @memberof Transforms
   */
  'size/sp': {
    type: 'value',
    matcher: isFontSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'sp');
      return `${val.toFixed(2)}sp`
    },
  },

  /**
   * Transforms the value into a density-independent pixel (dp) value for non-font sizes on Android. It will not scale the number.
   *
   * ```js
   * // Matches: token.attributes.category === 'size' && token.attributes.type !== 'font'
   * // Returns:
   * "10.0dp"
   * ```
   *
   * @memberof Transforms
   */
  'size/dp': {
    type: 'value',
    matcher: isNotFontSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'dp');
      return `${val.toFixed(2)}dp`
    },
  },

  /**
   * Transforms the value into a usefull object ( for React Native support )
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * {
   *  original: "10px",
   *  number: 10,
   *  decimal: 0.1, // 10 divided by 100
   *  scale: 160, // 10 times 16
   * }
   * ```
   *
   * @memberof Transforms
   */
  'size/object': {
    type: 'value',
    matcher: isSize,
    transformer(token, options) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'object');

      return {
        original: token.value,
        number: val,
        decimal: val / 100,
        scale: val * getBasePxFontSize(options),
      }
    },
  },

  /**
   * Transforms the value from a REM size on web into a scale-independent pixel (sp) value for font sizes on Android. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).
   *
   * ```js
   * // Matches: token.attributes.category === 'size' && token.attributes.type === 'font'
   * // Returns:
   * "16.0sp"
   * ```
   *
   * @memberof Transforms
   */
  'size/remToSp': {
    type: 'value',
    matcher: isFontSize,
    transformer(token, options) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'sp');
      return `${(val * baseFont).toFixed(2)}sp`
    },
  },

  /**
   * Transforms the value from a REM size on web into a density-independent pixel (dp) value for font sizes on Android. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).
   *
   * ```js
   * // Matches: token.attributes.category === 'size' && token.attributes.type !== 'font'
   * // Returns:
   * "16.0dp"
   * ```
   *
   * @memberof Transforms
   */
  'size/remToDp': {
    type: 'value',
    matcher: isNotFontSize,
    transformer(token, options) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'dp');
      return `${(val * baseFont).toFixed(2)}dp`
    },
  },

  /**
   * Adds 'px' to the end of the number. Does not scale the number
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "10px"
   * ```
   *
   * @memberof Transforms
   */
  'size/px': {
    type: 'value',
    matcher: isSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'px');
      return `${val}px`
    },
  },

  /**
   * Adds 'rem' to the end of the number. Does not scale the number
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "10rem"
   * ```
   *
   * @memberof Transforms
   */
  'size/rem': {
    type: 'value',
    matcher: isSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'rem');
      return `${val}rem`
    },
  },

  /**
   * Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) and adds 'pt' to the end.
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "16pt"
   * ```
   *
   * @memberof Transforms
   */
  'size/remToPt': {
    type: 'value',
    matcher: isSize,
    transformer(token, options) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'pt');
      return `${(val * baseFont).toFixed(2)}f`
    },
  },

  /**
   * Transforms the value from a REM size on web into a scale-independent pixel (sp) value for font sizes in Compose. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).
   *
   * ```kotlin
   * // Matches: prop.attributes.category === 'size' && prop.attributes.type === 'font'
   * // Returns:
   * "16.0.sp"
   * ```
   *
   * @memberof Transforms
   */
  'size/compose/remToSp': {
    type: 'value',
    matcher: isFontSize,
    transformer(prop, options) {
      const val = parseFloat(prop.value);
      const baseFont = getBasePxFontSize(options);
      if (isNaN(val))
        throwSizeError(prop.name, prop.value, 'sp');
      return `${(val * baseFont).toFixed(2)}.sp`
    },
  },

  /**
   * Transforms the value from a REM size on web into a density-independent pixel (dp) value for font sizes in Compose. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).
   *
   * ```kotlin
   * // Matches: prop.attributes.category === 'size' && prop.attributes.type !== 'font'
   * // Returns:
   * "16.0.dp"
   * ```
   *
   * @memberof Transforms
   */
  'size/compose/remToDp': {
    type: 'value',
    matcher: isNotFontSize,
    transformer(prop, options) {
      const val = parseFloat(prop.value);
      const baseFont = getBasePxFontSize(options);
      if (isNaN(val))
        throwSizeError(prop.name, prop.value, 'dp');
      return `${(val * baseFont).toFixed(2)}.dp`
    },
  },

  /**
   * Adds the .em Compose extension to the end of a number. Does not scale the value
   *
   * ```kotlin
   * // Matches: prop.attributes.category === 'size' && prop.attributes.type === 'font'
   * // Returns:
   * "16.0em"
   * ```
   *
   * @memberof Transforms
   */
  'size/compose/em': {
    type: 'value',
    matcher: isFontSize,
    transformer(prop) {
      const val = parseFloat(prop.value);
      if (isNaN(val))
        throwSizeError(prop.name, prop.value, 'em');
      return `${val}.em`
    },
  },

  /**
   * Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) to get to points for Swift and initializes a CGFloat
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns: "CGFloat(16.00)""
   * ```
   *
   * @memberof Transforms
   */
  'size/swift/remToCGFloat': {
    type: 'value',
    matcher: isSize,
    transformer(token, options) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'CGFloat');
      return `CGFloat(${(val * baseFont).toFixed(2)})`
    },
  },

  /**
   * Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) and adds 'px' to the end.
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "16px"
   * ```
   *
   * @memberof Transforms
   */
  'size/remToPx': {
    type: 'value',
    matcher: isSize,
    transformer(token, options) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options);
      if (isNaN(val))
        throwSizeError(token.name, token.value, 'px');
      return `${(val * baseFont).toFixed(0)}px`
    },
  },

  /**
   * Scales non-zero numbers to rem, and adds 'rem' to the end. If you define a "basePxFontSize" on the platform in your config, it will be used to scale the value, otherwise 16 (default web font size) will be used.
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "0"
   * "1rem"
   * ```
   */
  'size/pxToRem': {
    type: 'value',
    matcher: isSize,
    transformer: (token, options) => {
      const baseFont = getBasePxFontSize(options);
      const floatVal = parseFloat(token.value);

      if (isNaN(floatVal))
        throwSizeError(token.name, token.value, 'rem');

      if (floatVal === 0)
        return '0'

      return `${floatVal / baseFont}rem`
    },
  },

  /**
   * Takes a unicode point and transforms it into a form CSS can use.
   *
   * ```js
   * // Matches: token.attributes.category === 'content' && token.attributes.type === 'icon'
   * // Returns:
   * "'\\E001'"
   * ```
   *
   * @memberof Transforms
   */
  'content/icon': {
    type: 'value',
    matcher(token) {
      return token.attributes.category === 'content' && token.attributes.type === 'icon'
    },
    transformer(token) {
      return token.value.replace(UNICODE_PATTERN, (match, variable) => {
        return `'\\${variable}'`
      })
    },
  },

  /**
   * Wraps the value in a single quoted string
   *
   * ```js
   * // Matches: token.attributes.category === 'content'
   * // Returns:
   * "'string'"
   * ```
   *
   * @memberof Transforms
   */
  'content/quote': {
    type: 'value',
    matcher: isContent,
    transformer(token) {
      return wrapValueWith('\'', token)
    },
  },

  /**
   * Wraps the value in a double-quoted string and prepends an '@' to make a string literal.
   *
   * ```objectivec
   * // Matches: token.attributes.category === 'content'
   * // Returns:
   * @"string"
   * ```
   *
   * @memberof Transforms
   */
  'content/objC/literal': {
    type: 'value',
    matcher: isContent,
    transformer(token) {
      return `@${wrapValueWithDoubleQuote(token)}`
    },
  },

  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```swift
   * // Matches: token.attributes.category === 'content'
   * // Returns:
   * "string"
   * ```
   *
   * @memberof Transforms
   */
  'content/swift/literal': {
    type: 'value',
    matcher: isContent,
    transformer: wrapValueWithDoubleQuote,
  },

  /**
   * Wraps the value in a double-quoted string and prepends an '@' to make a string literal.
   *
   * ```objectivec
   * // Matches: token.attributes.category === 'font'
   * // Returns: @"string"
   * ```
   *
   * @memberof Transforms
   */
  'font/objC/literal': {
    type: 'value',
    matcher(token) {
      return token.attributes.category === 'font'
    },
    transformer(token) {
      return `@${wrapValueWithDoubleQuote(token)}`
    },
  },

  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```swift
   * // Matches: token.attributes.category === 'font'
   * // Returns: "string"
   * ```
   *
   * @memberof Transforms
   */
  'font/swift/literal': {
    type: 'value',
    matcher(token) {
      return token.attributes.category === 'font'
    },
    transformer: wrapValueWithDoubleQuote,
  },

  /**
   * Assumes a time in miliseconds and transforms it into a decimal
   *
   * ```js
   * // Matches: token.attributes.category === 'time'
   * // Returns:
   * "0.5s"
   * ```
   *
   * @memberof Transforms
   */
  'time/seconds': {
    type: 'value',
    matcher(token) {
      return token.attributes.category === 'time'
    },
    transformer(token) {
      return `${(parseFloat(token.value) / 1000).toFixed(2)}s`
    },
  },

  /**
   * Wraps the value in a double-quoted string and prepends an '@' to make a string literal.
   *
   * ```js
   * // Matches: token.attributes.category === 'asset'
   * // Returns:
   * 'IyBlZGl0b3Jjb25maWcub3JnCnJvb3QgPSB0cnVlCgpbKl0KaW5kZW50X3N0eWxlID0gc3BhY2UKaW5kZW50X3NpemUgPSAyCmVuZF9vZl9saW5lID0gbGYKY2hhcnNldCA9IHV0Zi04CnRyaW1fdHJhaWxpbmdfd2hpdGVzcGFjZSA9IHRydWUKaW5zZXJ0X2ZpbmFsX25ld2xpbmUgPSB0cnVlCgpbKi5tZF0KdHJpbV90cmFpbGluZ193aGl0ZXNwYWNlID0gZmFsc2U='
   * ```
   *
   * @memberof Transforms
   */
  'asset/base64': {
    type: 'value',
    matcher: isAsset,
    transformer(token) {
      return convertToBase64(token.value)
    },
  },

  /**
   * Prepends the local file path
   *
   * ```js
   * // Matches: token.attributes.category === 'asset'
   * // Returns:
   * "path/to/file/asset.png"
   * ```
   *
   * @memberof Transforms
   */
  'asset/path': {
    type: 'value',
    matcher: isAsset,
    transformer(token) {
      return path.join(process.cwd(), token.value)
    },
  },

  /**
   * Wraps the value in a double-quoted string and prepends an '@' to make a string literal.
   *
   * ```objectivec
   * // Matches: token.attributes.category === 'asset'
   * // Returns: @"string"
   * ```
   *
   * @memberof Transforms
   */
  'asset/objC/literal': {
    type: 'value',
    matcher: isAsset,
    transformer(token) {
      return `@${wrapValueWithDoubleQuote(token)}`
    },
  },

  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```swift
   * // Matches: token.attributes.category === 'asset'
   * // Returns: "string"
   * ```
   *
   * @memberof Transforms
   */
  'asset/swift/literal': {
    type: 'value',
    matcher: isAsset,
    transformer: wrapValueWithDoubleQuote,
  },

  /**
   * Transforms the value into a Flutter Color object using 8-digit hex with the alpha chanel on start
   *  ```js
   *  // Matches: token.attributes.category === 'color'
   *  // Returns:
   *  Color(0xFF00FF5F)
   *  ```
   *  @memberof Transforms
   *
   */
  'color/hex8flutter': {
    type: 'value',
    matcher: isColor,
    transformer(token) {
      const str = Color(token.value).toHex8().toUpperCase();
      return `Color(0x${str.slice(6)}${str.slice(0, 6)})`
    },
  },

  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```dart
   * // Matches: token.attributes.category === 'content'
   * // Returns: "string"
   * ```
   *
   * @memberof Transforms
   */
  'content/flutter/literal': {
    type: 'value',
    matcher: isContent,
    transformer: wrapValueWithDoubleQuote,
  },

  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```dart
   * // Matches: token.attributes.category === 'asset'
   * // Returns: "string"
   * ```
   *
   * @memberof Transforms
   */
  'asset/flutter/literal': {
    type: 'value',
    matcher: isAsset,
    transformer: wrapValueWithDoubleQuote,
  },

  /**
 * Wraps the value in a double-quoted string to make a string literal.
 *
 * ```dart
 * // Matches: token.attributes.category === 'font'
 * // Returns: "string"
 * ```
 *
 * @memberof Transforms
 */
  'font/flutter/literal': {
    type: 'value',
    matcher(token) {
      return token.attributes.category === 'font'
    },
    transformer: wrapValueWithDoubleQuote,
  },

  /**
   * Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) to get to points for Flutter
   *
   * ```dart
   * // Matches: token.attributes.category === 'size'
   * // Returns: 16.00
   * ```
   *
   * @memberof Transforms
   */
  'size/flutter/remToDouble': {
    type: 'value',
    matcher: isSize,
    transformer(token, options) {
      const baseFont = getBasePxFontSize(options);
      return (parseFloat(token.value, 10) * baseFont).toFixed(2)
    },
  },

};

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * @namespace TransformGroups
 */

var transformGroup = {

  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/kebab](transforms.md#namectikebab)
   * [size/px](transforms.md#sizepx)
   * [color/css](transforms.md#colorcss)
   *
   * @memberof TransformGroups
   */
  'web': [
    'attribute/cti',
    'name/cti/kebab',
    'size/px',
    'color/css',
  ],

  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/pascal](transforms.md#namectipascal)
   * [size/rem](transforms.md#sizerem)
   * [color/hex](transforms.md#colorhex)
   *
   * @memberof TransformGroups
   */
  'js': [
    'attribute/cti',
    'name/cti/pascal',
    'size/rem',
    'color/hex',
  ],

  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/kebab](transforms.md#namectikebab)
   * [time/seconds](transforms.md#timeseconds)
   * [content/icon](transforms.md#contenticon)
   * [size/rem](transforms.md#sizerem)
   * [color/css](transforms.md#colorcss)
   *
   * @memberof TransformGroups
   */
  'scss': [
    'attribute/cti',
    'name/cti/kebab',
    'time/seconds',
    'content/icon',
    'size/rem',
    'color/css',
  ],

  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/kebab](transforms.md#namectikebab)
   * [time/seconds](transforms.md#timeseconds)
   * [content/icon](transforms.md#contenticon)
   * [size/rem](transforms.md#sizerem)
   * [color/css](transforms.md#colorcss)
   *
   * @memberof TransformGroups
   */
  'css': [
    'attribute/cti',
    'name/cti/kebab',
    'time/seconds',
    'content/icon',
    'size/rem',
    'color/css',
  ],

  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/kebab](transforms.md#namectikebab)
   * [time/seconds](transforms.md#timeseconds)
   * [content/icon](transforms.md#contenticon)
   * [size/rem](transforms.md#sizerem)
   * [color/hex](transforms.md#colorhex)
   *
   * @memberof TransformGroups
   */
  'less': [
    'attribute/cti',
    'name/cti/kebab',
    'time/seconds',
    'content/icon',
    'size/rem',
    'color/hex',
  ],

  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [attribute/color](transforms.md#attributecolor)
   * [name/human](transforms.md#namehuman)
   *
   * @memberof TransformGroups
   */
  'html': [
    'attribute/cti',
    'attribute/color',
    'name/human',
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/snake](transforms.md#namectisnake)
   * [color/hex8android](transforms.md#colorhex8android)
   * [size/remToSp](transforms.md#sizeremtosp)
   * [size/remToDp](transforms.md#sizeremtodp)
   *
   * @memberof TransformGroups
   */
  'android': [
    'attribute/cti',
    'name/cti/snake',
    'color/hex8android',
    'size/remToSp',
    'size/remToDp',
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/camel](transforms.md#namecticamel)
   * [color/composeColor](transforms.md#colorcomposecolor)
   * [size/compose/em](transforms.md#sizecomposeem)
   * [size/compose/remToSp](transforms.md#sizecomposeremtosp)
   * [size/compose/remToDp](transforms.md#sizecomposeremtodp)
   *
   * @memberof TransformGroups
   */
  'compose': [
    'attribute/cti',
    'name/cti/camel',
    'color/composeColor',
    'size/compose/em',
    'size/compose/remToSp',
    'size/compose/remToDp',
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/pascal](transforms.md#namectipascal)
   * [color/UIColor](transforms.md#coloruicolor)
   * [content/objC/literal](transforms.md#contentobjcliteral)
   * [asset/objC/literal](transforms.md#assetobjcliteral)
   * [size/remToPt](transforms.md#sizeremtopt)
   * [font/objC/literal](transforms.md#fontobjcliteral)
   *
   * @memberof TransformGroups
   */
  'ios': [
    'attribute/cti',
    'name/cti/pascal',
    'color/UIColor',
    'content/objC/literal',
    'asset/objC/literal',
    'size/remToPt',
    'font/objC/literal',
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/camel](transforms.md#namecticamel)
   * [color/UIColorSwift](transforms.md#coloruicolorswift)
   * [content/swift/literal](transforms.md#contentswiftliteral)
   * [asset/swift/literal](transforms.md#assetswiftliteral)
   * [size/swift/remToCGFloat](transforms.md#sizeswiftremtocgfloat)
   * [font/swift/literal](transforms.md#fontswiftliteral)
   *
   * @memberof TransformGroups
   */
  'ios-swift': [
    'attribute/cti',
    'name/cti/camel',
    'color/UIColorSwift',
    'content/swift/literal',
    'asset/swift/literal',
    'size/swift/remToCGFloat',
    'font/swift/literal',
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/ti/camel](transforms.md#nameticamel)
   * [color/UIColorSwift](transforms.md#coloruicolorswift)
   * [content/swift/literal](transforms.md#contentswiftliteral)
   * [asset/swift/literal](transforms.md#assetswiftliteral)
   * [size/swift/remToCGFloat](transforms.md#sizeswiftremtocgfloat)
   * [font/swift/literal](transforms.md#fontswiftliteral)
   *
   * This is to be used if you want to have separate files per category and you don't want the category (e.g., color) as the lead value in the name of the token (e.g., StyleDictionaryColor.baseText instead of StyleDictionary.colorBaseText).
   *
   * @memberof TransformGroups
   */
  'ios-swift-separate': [
    'attribute/cti',
    'name/ti/camel',
    'color/UIColorSwift',
    'content/swift/literal',
    'asset/swift/literal',
    'size/swift/remToCGFloat',
    'font/swift/literal',
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   *
   * @memberof TransformGroups
   */
  'assets': [
    'attribute/cti',
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/camel](transforms.md#namecticamel)
   * [color/hex8flutter](transforms.md#colorhex8flutter)
   * [size/flutter/remToDouble](transforms.md#sizeflutterremToDouble)
   * [content/flutter/literal](transforms.md#contentflutterliteral)
   * [asset/flutter/literal](transforms.md#assetflutterliteral)
   * [font/flutter/literal](transforms.md#fontflutterliteral)
   *
   * @memberof TransformGroups
   */
  'flutter': [
    'attribute/cti',
    'name/cti/camel',
    'color/hex8flutter',
    'size/flutter/remToDouble',
    'content/flutter/literal',
    'asset/flutter/literal',
    'font/flutter/literal',
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/ti/camel](transforms.md#nameticamel)
   * [color/hex8flutter](transforms.md#colorhex8flutter)
   * [size/flutter/remToDouble](transforms.md#sizeflutterremToDouble)
   * [content/flutter/literal](transforms.md#contentflutterliteral)
   * [asset/flutter/literal](transforms.md#assetflutterliteral)
   * [font/flutter/literal](transforms.md#fontflutterliteral)
   *
   * This is to be used if you want to have separate files per category and you don't want the category (e.g., color) as the lead value in the name of the token (e.g., StyleDictionaryColor.baseText instead of StyleDictionary.colorBaseText).
   *
   * @memberof TransformGroups
   */
  'flutter-separate': [
    'attribute/cti',
    'name/ti/camel',
    'color/hex8flutter',
    'size/flutter/remToDouble',
    'content/flutter/literal',
    'asset/flutter/literal',
    'font/flutter/literal',
  ],

  /**
   * Transforms:
   *
   * [name/cti/camel](transforms.md#namecticamel)
   * [size/object](transforms.md#sizeobject)
   * [color/css](transforms.md#colorcss)
   *
   * @memberof TransformGroups
   */
  'react-native': [
    'name/cti/camel',
    'color/css',
    'size/object',
  ],
};

const _dir = resolve(dirname(fileURLToPath(import.meta.url)), '../templates');
const resolveTemplate = _path => join(_dir, _path);

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const defaultFormatting$2 = {
  prefix: '',
  commentStyle: 'long',
  indentation: '',
  separator: ' =',
  suffix: ';',
};

/**
 * Creates a function that can be used to format a property. This can be useful
 * to use as the function on `dictionary.allTokens.map`. The formatting
 * is configurable either by supplying a `format` option or a `formatting` object
 * which uses: prefix, indentation, separator, suffix, and commentStyle.
 * @memberof module:formatHelpers
 * @example
 * ```javascript
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *     const { outputReferences } = options;
 *     const formatProperty = createPropertyFormatter({
 *       outputReferences,
 *       dictionary,
 *       format: 'css'
 *     });
 *     return dictionary.allTokens.map(formatProperty).join('\n');
 *   }
 * });
 * ```
 * @param {Object} options
 * @param {Boolean} options.outputReferences - Whether or not to output references. You will want to pass this from the `options` object sent to the formatter function.
 * @param {Boolean} options.outputReferenceFallbacks - Whether or not to output css variable fallback values when using output references. You will want to pass this from the `options` object sent to the formatter function.
 * @param {Dictionary} options.dictionary - The dictionary object sent to the formatter function
 * @param {String} options.format - Available formats are: 'css', 'sass', 'less', and 'stylus'. If you want to customize the format and can't use one of those predefined formats, use the `formatting` option
 * @param {Object} options.formatting - Custom formatting properties that define parts of a declaration line in code. The configurable strings are: prefix, indentation, separator, suffix, and commentStyle. Those are used to generate a line like this: `${indentation}${prefix}${prop.name}${separator} ${prop.value}${suffix}`
 * @param {Boolean} options.themeable [false] - Whether tokens should default to being themeable.
 * @returns {Function}
 */
function createPropertyFormatter({
  outputReferences = false,
  outputReferenceFallbacks = false,
  dictionary,
  format,
  formatting = {},
  themeable = false,
}) {
  // eslint-disable-next-line prefer-const
  let { prefix, commentStyle, indentation, separator, suffix } = Object.assign({}, defaultFormatting$2, formatting);

  switch (format) {
    case 'css':
      prefix = '--';
      indentation = '  ';
      separator = ':';
      break
    case 'sass':
      prefix = '$';
      commentStyle = 'short';
      indentation = '';
      separator = ':';
      break
    case 'less':
      prefix = '@';
      commentStyle = 'short';
      indentation = '';
      separator = ':';
      break
    case 'stylus':
      prefix = '$';
      commentStyle = 'short';
      indentation = '';
      separator = '=';
      break
  }

  return function (prop) {
    let to_ret_prop = `${indentation}${prefix}${prop.name}${separator} `;
    let value = prop.value;

    /**
     * A single value can have multiple references either by interpolation:
     * "value": "{size.border.width.value} solid {color.border.primary.value}"
     * or if the value is an object:
     * "value": {
     *    "size": "{size.border.width.value}",
     *    "style": "solid",
     *    "color": "{color.border.primary.value"}
     * }
     * This will see if there are references and if there are, replace
     * the resolved value with the reference's name.
     */
    if (outputReferences && dictionary.usesReference(prop.original.value)) {
      // Formats that use this function expect `value` to be a string
      // or else you will get '[object Object]' in the output
      if (typeof value === 'string') {
        const refs = dictionary.getReferences(prop.original.value);
        refs.forEach((ref) => {
          // value should be a string that contains the resolved reference
          // because Style Dictionary resolved this in the resolution step.
          // Here we are undoing that by replacing the value with
          // the reference's name
          if (ref.value && ref.name) {
            value = value.replace(ref.value, () => {
              if (format === 'css') {
                if (outputReferenceFallbacks)
                  return `var(${prefix}${ref.name}, ${ref.value})`
                else
                  return `var(${prefix}${ref.name})`
              }
              else {
                return `${prefix}${ref.name}`
              }
            });
          }
        });
      }
    }

    to_ret_prop += prop.attributes.category === 'asset' ? `"${value}"` : value;

    const themeable_prop = typeof prop.themeable === 'boolean' ? prop.themeable : themeable;
    if (format === 'sass' && themeable_prop)
      to_ret_prop += ' !default';

    to_ret_prop += suffix;

    if (prop.comment && commentStyle !== 'none') {
      if (commentStyle === 'short')
        to_ret_prop = to_ret_prop.concat(` // ${prop.comment}`);
      else
        to_ret_prop = to_ret_prop.concat(` /* ${prop.comment} */`);
    }

    return to_ret_prop
  }
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

// no-op default
const defaultFileHeader = arr => arr;

const lineSeparator = '\n';
const defaultFormatting$1 = {
  lineSeparator,
  prefix: ' * ',
  header: `/**${lineSeparator}`,
  footer: `${lineSeparator} */${lineSeparator}${lineSeparator}`,
};

/**
 *
 * This is for creating the comment at the top of generated files with the generated at date.
 * It will use the custom file header if defined on the configuration, or use the
 * default file header.
 * @memberof module:formatHelpers
 * @param {Object} options
 * @param {File} options.file - The file object that is passed to the formatter.
 * @param {String} options.commentStyle - The only options are 'short' and 'xml', which will use the // or \<!-- --> style comments respectively. Anything else will use \/\* style comments.
 * @param {Object} options.formatting - Custom formatting properties that define parts of a comment in code. The configurable strings are: prefix, lineSeparator, header, and footer.
 * @returns {String}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, file }) {
 *     return fileHeader({file, commentStyle: 'short'}) +
 *       dictionary.allTokens.map(token => `${token.name} = ${token.value}`)
 *         .join('\n');
 *   }
 * });
 * ```
 */
function fileHeader({ file = {}, commentStyle, formatting = {} }) {
  // showFileHeader is true by default
  let showFileHeader = true;
  if (file.options && typeof file.options.showFileHeader !== 'undefined')
    showFileHeader = file.options.showFileHeader;

  // Return empty string if the showFileHeader is false
  if (!showFileHeader)
    return ''

  let fn = defaultFileHeader;
  if (file.options && typeof file.options.fileHeader === 'function')
    fn = file.options.fileHeader;

  // default header
  const defaultHeader = [
    'Do not edit directly',
    `Generated on ${new Date().toUTCString()}`,
  ];

  // eslint-disable-next-line prefer-const
  let { prefix, lineSeparator, header, footer } = Object.assign({}, defaultFormatting$1, formatting);

  if (commentStyle === 'short') {
    prefix = '// ';
    header = `${lineSeparator}`;
    footer = `${lineSeparator}${lineSeparator}`;
  }
  else if (commentStyle === 'xml') {
    prefix = '  ';
    header = `<!--${lineSeparator}`;
    footer = `${lineSeparator}-->`;
  }

  return `${header}${fn(defaultHeader)
    .map(line => `${prefix}${line}`)
    .join(lineSeparator)}${footer}`
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * A function that returns a sorting function to be used with Array.sort that
 * will sort the allTokens array based on references. This is to make sure
 * if you use output references that you never use a reference before it is
 * defined.
 * @memberof module:formatHelpers
 * @example
 * ```javascript
 * dictionary.allTokens.sort(sortByReference(dictionary))
 * ```
 * @param {Dictionary} dictionary
 * @returns {Function}
 */
function sortByReference(dictionary) {
  // The sorter function is recursive to account for multiple levels of nesting
  function sorter(a, b) {
    const aComesFirst = -1;
    const bComesFirst = 1;

    // return early if a or b ar undefined
    if (typeof a === 'undefined')
      return aComesFirst
    else if (typeof b === 'undefined')
      return bComesFirst

    // If token a uses a reference and token b doesn't, b might come before a
    // read on..
    if (a.original && dictionary.usesReference(a.original.value)) {
      // Both a and b have references, we need to see if the reference each other
      if (b.original && dictionary.usesReference(b.original.value)) {
        const aRefs = dictionary.getReferences(a.original.value);
        const bRefs = dictionary.getReferences(b.original.value);

        aRefs.forEach((aRef) => {
          // a references b, we want b to come first
          if (aRef.name === b.name)
            return bComesFirst
        });

        bRefs.forEach((bRef) => {
          // ditto but opposite
          if (bRef.name === a.name)
            return aComesFirst
        });

        // both a and b have references and don't reference each other
        // we go further down the rabbit hole (reference chain)
        return sorter(aRefs[0], bRefs[0])
      // a has a reference and b does not:
      }
      else {
        return bComesFirst
      }
    // a does not have a reference it should come first regardless if b has one
    }
    else {
      return aComesFirst
    }
  }

  return sorter
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const defaultFormatting = {
  lineSeparator: '\n',
};

/**
 *
 * This is used to create lists of variables like Sass variables or CSS custom properties
 * @memberof module:formatHelpers
 * @param {Object} options
 * @param {String} options.format - What type of variables to output. Options are: css, sass, less, and stylus
 * @param {Object} options.dictionary - The dictionary object that gets passed to the formatter method.
 * @param {Boolean} options.outputReferences - Whether or not to output references
 * @param {Object} options.formatting - Custom formatting properties that define parts of a declaration line in code. This will get passed to `formatHelpers.createPropertyFormatter` and used for the `lineSeparator` between lines of code.
 * @param {Boolean} options.themeable [false] - Whether tokens should default to being themeable.
 * @returns {String}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *     return formattedVariables({
 *       format: 'less',
 *       dictionary,
 *       outputReferences: options.outputReferences
 *     });
 *   }
 * });
 * ```
 */
function formattedVariables({ format, dictionary, outputReferences = false, formatting = {}, themeable = false }) {
  let { allTokens } = dictionary;

  const { lineSeparator } = Object.assign({}, defaultFormatting, formatting);

  // Some languages are imperative, meaning a variable has to be defined
  // before it is used. If `outputReferences` is true, check if the token
  // has a reference, and if it does send it to the end of the array.
  // We also need to account for nested references, a -> b -> c. They
  // need to be defined in reverse order: c, b, a so that the reference always
  // comes after the definition
  if (outputReferences) {
    // note: using the spread operator here so we get a new array rather than
    // mutating the original
    allTokens = [...allTokens].sort(sortByReference(dictionary));
  }

  return allTokens
    .map(createPropertyFormatter({ outputReferences, dictionary, format, formatting, themeable }))
    .filter((strVal) => { return !!strVal })
    .join(lineSeparator)
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Given some value, returns a basic valid TypeScript type for that value.
 * Supports numbers, strings, booleans, arrays and objects of any of those types.
 *
 * @memberof module:formatHelpers
 * @example
 * ```javascript
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *    return dictionary.allProperties.map(function(prop) {
 *      var to_ret_prop = 'export const ' + prop.name + ' : ' + getTypeScriptType(prop.value) + ';';
 *      if (prop.comment)
 *        to_ret_prop = to_ret_prop.concat(' // ' + prop.comment);
 *      return to_ret_prop;
 *    }).join('\n');
 *   }
 * });
 *```
 * @param {*} value A value to check the type of.
 * @return {String} A valid name for a TypeScript type.
 *
 */
function getTypeScriptType(value) {
  if (Array.isArray(value))
    return getArrayType(value)
  if (typeof value === 'object')
    return getObjectType(value)
  if (['string', 'number', 'boolean'].includes(typeof value))
    return typeof value

  return 'any'
}

/**
 * @param {Object} value An object with uknown type properties
 * @returns {String} A representation of the type model for the passed object
 */
function getObjectType(value) {
  const entries = Object.entries(value);
  return `{ ${entries.map(([key, property], index) => {
    const isLast = entries.length === index + 1;
    return `${key}: ${getTypeScriptType(property)}${!isLast ? ', ' : ''}`
  }).join('')} }`
}

/**
 * @param {Array} value An array to check each property of
 * @returns {String} A valid type for the passed array and it's items
 */
function getArrayType(passedArray) {
  if (passedArray.length > 0) {
    const firstValueType = getTypeScriptType(passedArray[0]);
    if (passedArray.every(v => getTypeScriptType(v) === firstValueType)) {
      return `${firstValueType}[]`
    }
    else {
      return `(${unique(passedArray.map((item, index) => {
        const isLast = passedArray.length === index + 1;
        return `${getTypeScriptType(item)}${!isLast ? ' | ' : ''}`
      })).join('')})[]`
    }
  }
  return 'any[]'
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 *
 * This is used to create CSS (and CSS pre-processor) lists of icons. It assumes you are
 * using an icon font and creates helper classes with the :before pseudo-selector to add
 * a unicode character.
 * __You probably don't need this.__
 * @memberof module:formatHelpers
 * @param {String} prefix - Character to prefix variable names, like '$' for Sass
 * @param {Token[]} allTokens - allTokens array on the dictionary object passed to the formatter function.
 * @param {Object} options - options object passed to the formatter function.
 * @returns {String}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *     return iconsWithPrefix('$', dictionary.allTokens, options);
 *   }
 * });
 * ```
 */
function iconsWithPrefix(prefix, allTokens, options) {
  return allTokens.filter((token) => {
    return token.attributes.category === 'content' && token.attributes.type === 'icon'
  })
    .map((token) => {
      const varName = `${prefix + token.name}: ${token.value};`;
      const className = `.${options.prefix}-icon.${token.attributes.item}:before `;
      const declaration = `{ content: ${prefix}${token.name}; }`;
      return `${varName}\n${className}${declaration}`
    })
    .join('\n')
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * A sorting function to be used when iterating over `dictionary.allTokens` in
 * a format.
 * @memberof module:formatHelpers
 * @example
 * ```javascript
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *     return dictionary.allTokens.sort(sortByName)
 *       .map(token => `${token.name} = ${token.value}`)
 *       .join('\n');
 *   }
 * });
 * ```
 * @param {*} a - first element for comparison
 * @param {*} b - second element for comparison
 * @returns {Integer} -1 or 1 depending on which element should come first based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
 */
function sortByName(a, b) {
  if (b.name > a.name)
    return -1
  else
    return 1
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Outputs an object stripping out everything except values
 * @memberof module:formatHelpers
 * @param {Object} obj - The object to minify. You will most likely pass `dictionary.tokens` to it.
 * @returns {Object}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary }) {
 *     return JSON.stringify(minifyDictionary(dictionary.tokens));
 *   }
 * });
 * ```
 */
function minifyDictionary(obj) {
  if (typeof obj !== 'object' || Array.isArray(obj))
    return obj

  const toRet = {};

  if (obj.hasOwnProperty('value')) {
    return obj.value
  }
  else {
    for (const name in obj) {
      if (obj.hasOwnProperty(name))
        toRet[name] = minifyDictionary(obj[name]);
    }
  }
  return toRet
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Outputs an object with swift format configurations. Sets import, object type and access control.
 * @memberof module:formatHelpers
 * @param {Object} options - The options object declared at configuration
 * @param {String} objectType - The type of the object in the final file. Could be a class, enum, struct, etc.
 * @param {String} transformGroup - The transformGroup of the file, so it can be applied proper import
 * @returns {Object}
 */
function setSwiftFileProperties(options, objectType, transformGroup) {
  if (typeof options.objectType === 'undefined') {
    if (typeof objectType === 'undefined')
      options.objectType = 'class';
    else
      options.objectType = objectType;
  }

  if (typeof options.import === 'undefined') {
    if (typeof transformGroup === 'undefined') {
      options.import = ['UIKit'];
    }
    else if (['ios-swift', 'ios-swift-separate'].includes(transformGroup)) {
      options.import = ['UIKit'];
    }
    else {
      // future swift-ui transformGroup to be added here
      options.import = ['SwiftUI'];
    }
  }
  else if (typeof options.import === 'string') {
    options.import = [options.import];
  }

  if (typeof options.accessControl === 'undefined') {
    options.accessControl = 'public ';
  }
  else {
    if (options.accessControl !== '')
      options.accessControl = `${options.accessControl} `;
  }

  return options
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

declare const formatHelpers_createPropertyFormatter: typeof createPropertyFormatter;
declare const formatHelpers_fileHeader: typeof fileHeader;
declare const formatHelpers_formattedVariables: typeof formattedVariables;
declare const formatHelpers_getTypeScriptType: typeof getTypeScriptType;
declare const formatHelpers_iconsWithPrefix: typeof iconsWithPrefix;
declare const formatHelpers_sortByReference: typeof sortByReference;
declare const formatHelpers_sortByName: typeof sortByName;
declare const formatHelpers_minifyDictionary: typeof minifyDictionary;
declare const formatHelpers_setSwiftFileProperties: typeof setSwiftFileProperties;
declare namespace formatHelpers {
  export {
    formatHelpers_createPropertyFormatter as createPropertyFormatter,
    formatHelpers_fileHeader as fileHeader,
    formatHelpers_formattedVariables as formattedVariables,
    formatHelpers_getTypeScriptType as getTypeScriptType,
    formatHelpers_iconsWithPrefix as iconsWithPrefix,
    formatHelpers_sortByReference as sortByReference,
    formatHelpers_sortByName as sortByName,
    formatHelpers_minifyDictionary as minifyDictionary,
    formatHelpers_setSwiftFileProperties as setSwiftFileProperties,
  };
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const SASS_MAP_FORMAT_DEPRECATION_WARNINGS$1 = GroupMessages.GROUP.SassMapFormatDeprecationWarnings;

/**
 * @namespace Formats
 */

const formats = {
  /**
   * Creates a CSS file with variable definitions based on the style dictionary
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @param {string} [options.selector] - Override the root css selector
   * @example
   * ```css
   * :root {
   *   --color-background-base: #f0f0f0;
   *   --color-background-alt: #eeeeee;
   * }
   * ```
   */
  'css/variables': function ({ dictionary, options = {}, file }) {
    const selector = options.selector ? options.selector : ':root';
    const { outputReferences } = options;
    return `${fileHeader({ file })
      }${selector} {\n${
      formattedVariables({ format: 'css', dictionary, outputReferences })
      }\n}\n`
  },

  /**
   * Creates a SCSS file with a flat map based on the style dictionary
   *
   * Name the map by adding a 'mapName' attribute on the file object in your config.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```scss
   * $tokens: (
   *   'color-background-base': #f0f0f0;
   *   'color-background-alt': #eeeeee;
   * )
   * ```
   */
  'scss/map-flat': function ({ dictionary, options, file }) {
    const template = _template(fs.readFileSync(resolveTemplate('scss/map-flat.template')));
    const { allTokens } = dictionary;
    return template({ allTokens, file, options, fileHeader })
  },

  // This will soon be removed, is left here only for backwards compatibility
  'sass/map-flat': function ({ dictionary, options, file }) {
    GroupMessages.add(SASS_MAP_FORMAT_DEPRECATION_WARNINGS$1, 'sass/map-flat');
    return formats['scss/map-flat']({ dictionary, options, file })
  },

  /**
   * Creates a SCSS file with a deep map based on the style dictionary.
   *
   * Name the map by adding a 'mapName' attribute on the file object in your config.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @param {Boolean} [options.themeable=true] - Whether or not tokens should default to being themeable, if not otherwise specified per token.
   * @example
   * ```scss
   * $color-background-base: #f0f0f0 !default;
   * $color-background-alt: #eeeeee !default;
   *
   * $tokens: {
   *   'color': (
   *     'background': (
   *       'base': $color-background-base,
   *       'alt': $color-background-alt
   *     )
   *   )
   * )
   * ```
   */
  'scss/map-deep': function ({ dictionary, options, file }) {
    const mapTemplate = _template(fs.readFileSync(resolveTemplate('scss/map-deep.template')));

    // Default the "themeable" option to true for backward compatibility.
    const { outputReferences, themeable = true } = options;
    return `\n${
      fileHeader({ file, commentStyle: 'long' })
      }${formattedVariables({ format: 'sass', dictionary, outputReferences, themeable })
       }\n${
      mapTemplate({ dictionary, file })}`
  },

  // This will soon be removed, is left here only for backwards compatibility
  'sass/map-deep': function ({ dictionary, options, file }) {
    GroupMessages.add(SASS_MAP_FORMAT_DEPRECATION_WARNINGS$1, 'sass/map-deep');
    return formats['scss/map-deep']({ dictionary, options, file })
  },

  /**
   * Creates a SCSS file with variable definitions based on the style dictionary.
   *
   * Add `!default` to any variable by setting a `themeable: true` attribute in the token's definition.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @param {Boolean} [options.themeable=false] - Whether or not tokens should default to being themeable, if not otherwise specified per token.
   * @example
   * ```scss
   * $color-background-base: #f0f0f0;
   * $color-background-alt: #eeeeee !default;
   * ```
   */
  'scss/variables': function ({ dictionary, options, file }) {
    const { outputReferences, themeable = false } = options;
    return fileHeader({ file, commentStyle: 'short' })
      + formattedVariables({ format: 'sass', dictionary, outputReferences, themeable })
  },

  /**
   * Creates a SCSS file with variable definitions and helper classes for icons
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```scss
   * $content-icon-email: '\E001';
   * .icon.email:before { content:$content-icon-email; }
   * ```
   */
  'scss/icons': function ({ dictionary, options, file }) {
    return fileHeader({ file, commentStyle: 'short' }) + iconsWithPrefix('$', dictionary.allTokens, options)
  },

  /**
   * Creates a LESS file with variable definitions based on the style dictionary
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```less
   * \@color-background-base: #f0f0f0;
   * \@color-background-alt: #eeeeee;
   * ```
   */
  'less/variables': function ({ dictionary, options, file }) {
    const { outputReferences } = options;
    return fileHeader({ file, commentStyle: 'short' })
      + formattedVariables({ format: 'less', dictionary, outputReferences })
  },

  /**
   * Creates a LESS file with variable definitions and helper classes for icons
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```less
   * \@content-icon-email: '\E001';
   * .icon.email:before { content:\@content-icon-email; }
   * ```
   */
  'less/icons': function ({ dictionary, options, file }) {
    return fileHeader({ file, commentStyle: 'short' }) + iconsWithPrefix('@', dictionary.allTokens, options)
  },

  /**
   * Creates a Stylus file with variable definitions based on the style dictionary
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```stylus
   * $color-background-base= #f0f0f0;
   * $color-background-alt= #eeeeee;
   * ```
   */
  'stylus/variables': function ({ dictionary, options, file }) {
    const { outputReferences } = options;
    return fileHeader({ file, commentStyle: 'short' })
      + formattedVariables({ format: 'stylus', dictionary, outputReferences })
  },

  /**
   * Creates a CommonJS module with the whole style dictionary
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * export default {
   *   color: {
   *     base: {
   *        red: {
   *          value: '#ff0000'
   *        }
   *     }
   *   }
   * }
   * ```
   */
  'javascript/module': function ({ dictionary, file }) {
    return `${fileHeader({ file })
    }export default ${
      JSON.stringify(dictionary.tokens, null, 2)};`
  },

  /**
   * Creates a CommonJS module with the whole style dictionary flattened to a single level.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * export default {
   *  "ColorBaseRed": "#ff0000"
   *}
   *```
   */
  'javascript/module-flat': function ({ dictionary, file }) {
    return `${fileHeader({ file })
      }export default ${
        formats['json/flat']({ dictionary })};`
  },

  /**
   * Creates a JS file a global var that is a plain javascript object of the style dictionary.
   * Name the variable by adding a 'name' attribute on the file object in your config.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * var StyleDictionary = {
   *   color: {
   *     base: {
   *        red: {
   *          value: '#ff0000'
   *        }
   *     }
   *   }
   * }
   * ```
   */
  'javascript/object': function ({ dictionary, file }) {
    return `${fileHeader({ file })
       }var ${
       file.name || '_styleDictionary'
       } = ${
       JSON.stringify(dictionary.tokens, null, 2)
       };`
  },

  /**
   * Creates a [UMD](https://github.com/umdjs/umd) module of the style
   * dictionary. Name the module by adding a 'name' attribute on the file object
   * in your config.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * (function(root, factory) {
   *   if (typeof module === "object" && module.exports) {
   *     export default factory();
   *   } else if (typeof exports === "object") {
   *     exports["_styleDictionary"] = factory();
   *   } else if (typeof define === "function" && define.amd) {
   *     define([], factory);
   *   } else {
   *     root["_styleDictionary"] = factory();
   *   }
   * }(this, function() {
   *   return {
   *     "color": {
   *       "red": {
   *         "value": "#FF0000"
   *       }
   *     }
   *   };
   * }))
   * ```
   */
  'javascript/umd': function ({ dictionary, file }) {
    const name = file.name || '_styleDictionary';
    return `${fileHeader({ file })
      }(function(root, factory) {\n`
      + '  if (typeof module === "object" && module.exports) {\n'
      + '    export default factory();\n'
      + '  } else if (typeof exports === "object") {\n'
      + `    exports["${name}"] = factory();\n`
      + '  } else if (typeof define === "function" && define.amd) {\n'
      + '    define([], factory);\n'
      + '  } else {\n'
      + `    root["${name}"] = factory();\n`
      + '  }\n'
      + '}(this, function() {\n'
      + `  return ${JSON.stringify(dictionary.tokens, null, 2)};\n`
      + '}))\n'
  },

  /**
   * Creates a ES6 module of the style dictionary.
   *
   * ```json
   * {
   *   "platforms": {
   *     "js": {
   *       "transformGroup": "js",
   *       "files": [
   *         {
   *           "format": "javascript/es6",
   *           "destination": "colors.js",
   *           "filter": {
   *             "attributes": {
   *               "category": "color"
   *             }
   *           }
   *         }
   *       ]
   *     }
   *   }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * export const ColorBackgroundBase = '#ffffff';
   * export const ColorBackgroundAlt = '#fcfcfcfc';
   * ```
   */
  'javascript/es6': function ({ dictionary, file }) {
    return fileHeader({ file })
      + dictionary.allTokens.map((token) => {
        let to_ret = `export const ${token.name} = ${JSON.stringify(token.value)};`;
        if (token.comment)
          to_ret = to_ret.concat(` // ${token.comment}`);
        return to_ret
      }).join('\n')
  },

  // TypeScript declarations
  /**
   * Creates TypeScript declarations for ES6 modules
   *
   * ```json
   * {
   *   "platforms": {
   *     "ts": {
   *       "transformGroup": "js",
   *       "files": [
   *         {
   *           "format": "javascript/es6",
   *           "destination": "colors.js"
   *         },
   *         {
   *           "format": "typescript/es6-declarations",
   *           "destination": "colors.d.ts"
   *         }
   *       ]
   *     }
   *   }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```typescript
   * export const ColorBackgroundBase : string;
   * export const ColorBackgroundAlt : string;
   * ```
   */
  'typescript/es6-declarations': function ({ dictionary, file }) {
    return fileHeader({ file })
      + dictionary.allProperties.map((prop) => {
        let to_ret_prop = `export const ${prop.name} : ${getTypeScriptType(prop.value)};`;
        if (prop.comment)
          to_ret_prop = to_ret_prop.concat(` // ${prop.comment}`);
        return to_ret_prop
      }).join('\n')
  },

  /**
   * Creates TypeScript declarations for CommonJS module
   *
   * ```json
   * {
   *   "platforms": {
   *     "ts": {
   *       "transformGroup": "js",
   *       "files": [
   *         {
   *           "format": "javascript/module",
   *           "destination": "colors.js"
   *         },
   *         {
   *           "format": "typescript/module-declarations",
   *           "destination": "colors.d.ts"
   *         }
   *       ]
   *     }
   *   }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```typescript
   * export default tokens;
   * declare interface DesignToken { value: string; name?: string; path?: string[]; comment?: string; attributes?: any; original?: any; }
   * declare const tokens: {
   *  "color": {
   *    "red": DesignToken
   *  }
   * }
   * ```
   *
   * As you can see above example output this does not generate 100% accurate d.ts.
   * This is a compromise between of what style-dictionary can do to help and not bloating the library with rarely used dependencies.
   *
   * Thankfully you can extend style-dictionary very easily:
   *
   * ```js
   * import JsonToTS from 'json-to-ts';
   * StyleDictionaryPackage.registerFormat({
   *   name: 'typescript/accurate-module-declarations',
   *   formatter: function({ dictionary }) {
   *     return 'declare const root: RootObject\n' +
   *     'export default root\n' +
   *     JsonToTS(dictionary.properties).join('\n');
   *   },
   * });
   * ```
   */
  'typescript/module-declarations': function ({ dictionary, file, options }) {
    const { moduleName = 'tokens' } = options;
    function treeWalker(obj) {
      let type = Object.create(null);
      const has = Object.prototype.hasOwnProperty.bind(obj);
      if (has('value')) {
        type = 'DesignToken';
      }
      else {
        for (const k in obj) {
          if (has(k)) {
            switch (typeof obj[k]) {
              case 'object':
                type[k] = treeWalker(obj[k]);
            }
          }
        }
      }
      return type
    }

    const _dir = resolve(dirname(fileURLToPath(import.meta.url)), '../templates');
    const designTokenInterface = fs.readFileSync(
      resolve(_dir, '../../types/DesignToken.d.ts'), { encoding: 'UTF-8' }
    );

    // get the first and last lines to add to the format by
    // looking for the first and last single-line comment
    const lines = designTokenInterface
      .split('\n');
    const firstLine = lines.indexOf('//start') + 1;
    const lastLine = lines.indexOf('//end');

    const output = `${fileHeader({ file })
}export default ${moduleName};

declare ${lines.slice(firstLine, lastLine).join('\n')}

declare const ${moduleName}: ${JSON.stringify(treeWalker(dictionary.tokens), null, 2)}`;

    // JSON stringify will quote strings, because this is a type we need
    // it unquoted.
    return output.replace(/"DesignToken"/g, 'DesignToken')
  },

  // Android templates
  /**
   * Creates a [resource](https://developer.android.com/guide/topics/resources/providing-resources) xml file. It is recommended to use a filter with this format
   * as it is generally best practice in Android development to have resource files
   * organized by type (color, dimension, string, etc.). However, a resource file
   * with mixed resources will still work.
   *
   * This format will try to use the proper resource type for each token based on
   * the category (color => color, size => dimen, etc.). However if you want to
   * force a particular resource type you can provide a 'resourceType' attribute
   * on the file configuration. You can also provide a 'resourceMap' if you
   * don't use Style Dictionary's built-in CTI structure.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *  <color name="color_base_red_5">#fffaf3f2</color>
   *  <color name="color_base_red_30">#fff0cccc</color>
   *  <dimen name="size_font_base">14sp</color>
   * ```
   */
  'android/resources': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('android/resources.template'))
    );
    return template({ dictionary, file, options, fileHeader })
  },

  /**
   * Creates a color resource xml file with all the colors in your style dictionary.
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'color' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *  <color name="color_base_red_5">#fffaf3f2</color>
   *  <color name="color_base_red_30">#fff0cccc</color>
   *  <color name="color_base_red_60">#ffe19d9c</color>
   * ```
   */
  'android/colors': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('android/colors.template'))
    );
    return template({ dictionary, file, options, fileHeader })
  },

  /**
   * Creates a dimen resource xml file with all the sizes in your style dictionary.
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'size' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *  <dimen name="size_padding_tiny">5.00dp</dimen>
   *  <dimen name="size_padding_small">10.00dp</dimen>
   *  <dimen name="size_padding_medium">15.00dp</dimen>
   * ```
   */
  'android/dimens': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('android/dimens.template'))
    );
    return template({ dictionary, file, options, fileHeader })
  },

  /**
   * Creates a dimen resource xml file with all the font sizes in your style dictionary.
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'size' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *  <dimen name="size_font_tiny">10.00sp</dimen>
   *  <dimen name="size_font_small">13.00sp</dimen>
   *  <dimen name="size_font_medium">15.00sp</dimen>
   * ```
   */
  'android/fontDimens': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('android/fontDimens.template'))
    );
    return template({ dictionary, file, options, fileHeader })
  },

  /**
   * Creates a resource xml file with all the integers in your style dictionary. It filters your
   * design tokens by `token.attributes.category === 'time'`
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'time' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @todo Update the filter on this.
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *   <integer name="time_duration_short">1000</integer>
   *   <integer name="time_duration_medium">2000</integer>
   *   <integer name="time_duration_long">4000</integer>
   * ```
   */
  'android/integers': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('android/integers.template'))
    );
    return template({ dictionary, file, options, fileHeader })
  },

  /**
   * Creates a resource xml file with all the strings in your style dictionary. Filters your
   * design tokens by `token.attributes.category === 'content'`
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'content' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *   <string name="content_icon_email">&#xE001;</string>
   *   <string name="content_icon_chevron_down">&#xE002;</string>
   *   <string name="content_icon_chevron_up">&#xE003;</string>
   * ```
   */
  'android/strings': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('android/strings.template'))
    );
    return template({ dictionary, file, options, fileHeader })
  },

  // Compose templates
  /**
   * Creates a Kotlin file for Compose containing an object with a `val` for each property.
   *
   * @memberof Formats
   * @kind member
   * @param {String} className The name of the generated Kotlin object
   * @param {String} packageName The package for the generated Kotlin object
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```kotlin
   * package com.example.tokens;
   *
   * import androidx.compose.ui.graphics.Color
   *
   * object StyleDictionary {
   *  val colorBaseRed5 = Color(0xFFFAF3F2)
   * }
   * ```
   */
  'compose/object': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('compose/object.kt.template'))
    );
    let allProperties;
    const { outputReferences } = options;
    const formatProperty = createPropertyFormatter({
      outputReferences,
      dictionary,
      formatting: {
        suffix: '',
        commentStyle: 'none', // We will add the comment in the format template
      },
    });

    if (outputReferences)
      allProperties = [...dictionary.allProperties].sort(sortByReference(dictionary));
    else
      allProperties = [...dictionary.allProperties].sort(sortByName);

    return template({ allProperties, file, options, formatProperty, fileHeader })
  },

  // iOS templates

  /**
   * Creates an Objective-C header file with macros for design tokens
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```objectivec
   * #import <Foundation/Foundation.h>
   * #import <UIKit/UIKit.h>
   *
   * #define ColorFontLink [UIColor colorWithRed:0.00f green:0.47f blue:0.80f alpha:1.00f]
   * #define SizeFontTiny 176.00f
   * ```
   */
  'ios/macros': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/macros.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates an Objective-C plist file
   *
   * @memberof Formats
   * @kind member
   * @todo Fix this template and add example and usage
   */
  'ios/plist': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/plist.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates an Objective-C implementation file of a style dictionary singleton class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  'ios/singleton.m': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/singleton.m.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates an Objective-C header file of a style dictionary singleton class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  'ios/singleton.h': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/singleton.h.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates an Objective-C header file of a static style dictionary class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  'ios/static.h': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/static.h.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates an Objective-C implementation file of a static style dictionary class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  'ios/static.m': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/static.m.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates an Objective-C header file of a color class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  'ios/colors.h': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/colors.h.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates an Objective-C implementation file of a color class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  'ios/colors.m': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/colors.m.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates an Objective-C header file of strings
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  'ios/strings.h': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/strings.h.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates an Objective-C implementation file of strings
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  'ios/strings.m': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios/strings.m.template'))
    );

    return template({ dictionary, options, file, fileHeader })
  },

  /**
   * Creates a Swift implementation file of a class with values. It adds default `class` object type, `public` access control and `UIKit` import.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {String} [options.accessControl=public] - Level of [access](https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html) of the generated swift object
   * @param {String[]} [options.import=UIKit] - Modules to import. Can be a string or array of string
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```swift
   * public class StyleDictionary {
   *   public static let colorBackgroundDanger = UIColor(red: 1.000, green: 0.918, blue: 0.914, alpha: 1)
   * }
   * ```
   */
  'ios-swift/class.swift': function ({ dictionary, options, file, platform }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios-swift/any.swift.template'))
    );
    let allTokens;
    const { outputReferences } = options;
    options = setSwiftFileProperties(options, 'class', platform.transformGroup);
    const formatProperty = createPropertyFormatter({
      outputReferences,
      dictionary,
      formatting: {
        suffix: '',
      },
    });

    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName);

    return template({ allTokens, file, options, formatProperty, fileHeader })
  },

  /**
   * Creates a Swift implementation file of an enum with values. It adds default `enum` object type, `public` access control and `UIKit` import.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {String} [options.accessControl=public] - Level of [access](https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html) of the generated swift object
   * @param {String[]} [options.import=UIKit] - Modules to import. Can be a string or array of string
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```swift
   * public enum StyleDictionary {
   *   public static let colorBackgroundDanger = UIColor(red: 1.000, green: 0.918, blue: 0.914, alpha: 1)
   * }
   * ```
   */
  'ios-swift/enum.swift': function ({ dictionary, options, file, platform }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios-swift/any.swift.template'))
    );
    let allTokens;
    const { outputReferences } = options;
    options = setSwiftFileProperties(options, 'enum', platform.transformGroup);
    const formatProperty = createPropertyFormatter({
      outputReferences,
      dictionary,
      formatting: {
        suffix: '',
      },
    });

    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName);

    return template({ allTokens, file, options, formatProperty, fileHeader })
  },

  /**
   * Creates a Swift implementation file of any given type with values. It has by default `class` object type, `public` access control and `UIKit` import.
   *
   * ```javascript
   * format: 'ios-swift/any.swift',
   * import: ['UIKit', 'AnotherModule'],
   * objectType: 'struct',
   * accessControl: 'internal',
   * ```
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {String} [options.accessControl=public] - Level of [access](https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html) of the generated swift object
   * @param {String[]} [options.import=UIKit] - Modules to import. Can be a string or array of strings
   * @param {String} [options.objectType=class] - The type of the generated Swift object
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```swift
   * import UIKit
   * import AnotherModule
   *
   * internal struct StyleDictionary {
   *   internal static let colorBackgroundDanger = UIColor(red: 1.000, green: 0.918, blue: 0.914, alpha: 1)
   * }
   * ```
   */
  'ios-swift/any.swift': function ({ dictionary, options, file, platform }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('ios-swift/any.swift.template'))
    );
    let allTokens;
    const { outputReferences } = options;
    options = setSwiftFileProperties(options, options.objectType, platform.transformGroup);
    const formatProperty = createPropertyFormatter({
      outputReferences,
      dictionary,
      formatting: {
        suffix: '',
      },
    });

    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName);

    return template({ allTokens, file, options, formatProperty, fileHeader })
  },

  // Css templates

  /**
   * Creates CSS file with @font-face declarations
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  'css/fonts.css': _template(
    fs.readFileSync(resolveTemplate('css/fonts.css.template'))
  ),

  // Web templates

  /**
   * Creates a JSON file of the style dictionary.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "color": {
   *     "base": {
   *        "red": {
   *          "value": "#ff0000"
   *        }
   *     }
   *   }
   * }
   * ```
   */
  'json': function ({ dictionary }) {
    return JSON.stringify(dictionary.tokens, null, 2)
  },

  /**
   * Creates a JSON file of the assets defined in the style dictionary.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * {
   *   "asset": {
   *     "image": {
   *        "logo": {
   *          "value": "assets/logo.png"
   *        }
   *     }
   *   }
   * }
   * ```
   */
  'json/asset': function ({ dictionary }) {
    return JSON.stringify({ asset: dictionary.tokens.asset }, null, 2)
  },

  /**
   * Creates a JSON nested file of the style dictionary.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "color": {
   *     "base": {
   *        "red": "#ff0000"
   *     }
   *   }
   * }
   * ```
   */
  'json/nested': function ({ dictionary }) {
    return JSON.stringify(minifyDictionary(dictionary.tokens), null, 2)
  },

  /**
   * Creates a JSON flat file of the style dictionary.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "color-base-red": "#ff0000"
   * }
   * ```
   */
  'json/flat': function ({ dictionary }) {
    return `{\n${dictionary.allTokens.map((token) => {
        return `  "${token.name}": ${JSON.stringify(token.value)}`
      }).join(',\n')}\n}`
  },

  /**
   * Creates a sketchpalette file of all the base colors
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "compatibleVersion": "1.0",
   *   "pluginVersion": "1.1",
   *   "colors": [
   *     "#ffffff",
   *     "#ff0000",
   *     "#fcfcfc"
   *   ]
   * }
   * ```
   */
  'sketch/palette': function ({ dictionary }) {
    const to_ret = {
      compatibleVersion: '1.0',
      pluginVersion: '1.1',
    };
    to_ret.colors = dictionary.allTokens
      .filter((token) => {
        return token.attributes.category === 'color' && token.attributes.type === 'base'
      })
      .map((token) => {
        return token.value
      });
    return JSON.stringify(to_ret, null, 2)
  },

  /**
   * Creates a sketchpalette file compatible with version 2 of
   * the sketchpalette plugin. To use this you should use the
   * 'color/sketch' transform to get the correct value for the colors.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "compatibleVersion": "2.0",
   *   "pluginVersion": "2.2",
   *   "colors": [
   *     {name: "red", r: 1.0, g: 0.0, b: 0.0, a: 1.0},
   *     {name: "green", r: 0.0, g: 1.0, b: 0.0, a: 1.0},
   *     {name: "blue", r: 0.0, g: 0.0, b: 1.0, a: 1.0}
   *   ]
   * }
   * ```
   */
  'sketch/palette/v2': function ({ dictionary }) {
    const to_ret = {
      compatibleVersion: '2.0',
      pluginVersion: '2.2',
      colors: dictionary.allTokens.map((token) => {
        // Merging the token's value, which should be an object with r,g,b,a channels
        return Object.assign({
          name: token.name,
        }, token.value)
      }),
    };
    return JSON.stringify(to_ret, null, 2)
  },

  // Flutter templates
  /**
   *  Creates a Dart implementation file of a class with values
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```dart
   * import 'package:flutter/material.dart';
   *
   * class StyleDictionary {
   *   StyleDictionary._();
   *
   *     static const colorBrandPrimary = Color(0x00ff5fff);
   *     static const sizeFontSizeMedium = 16.00;
   *     static const contentFontFamily1 = "NewJune";
   * ```
   */
  'flutter/class.dart': function ({ dictionary, options, file }) {
    const template = _template(
      fs.readFileSync(resolveTemplate('flutter/class.dart.template'))
    );
    let allTokens;
    const { outputReferences } = options;
    const formatProperty = createPropertyFormatter({
      outputReferences,
      dictionary,
    });

    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName);

    return template({ allTokens, file, options, formatProperty, fileHeader })
  },
};

// Mark which formats are nested
formats['json/nested'].nested = true;
formats['javascript/module'].nested = true;
formats['javascript/object'].nested = true;

let _logger;
const logger = () => {
  if (!_logger)
    _logger = consola.create().withDefaults().withScope('style-dictionary');

  return _logger
};

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * @namespace Actions
 */
var action = {
  /**
   * Action to copy images into appropriate android directories.
   *
   * @type {Action}
   * @memberof Actions
   */
  'android/copyImages': {
    do(dictionary, config) {
      const imagesDir = `${config.buildPath}android/main/res/drawable-`;
      dictionary.allTokens.forEach((token) => {
        if (token.attributes.category === 'asset' && token.attributes.type === 'image') {
          const name = token.path.slice(2, 4).join('_');
          fs$1.copySync(token.value, `${imagesDir + token.attributes.state}/${name}.png`);
        }
      });
    },
    undo(dictionary, config) {
      const imagesDir = `${config.buildPath}android/main/res/drawable-`;
      dictionary.allTokens.forEach((token) => {
        if (token.attributes.category === 'asset' && token.attributes.type === 'image') {
          const name = token.path.slice(2, 4).join('_');
          fs$1.removeSync(`${imagesDir + token.attributes.state}/${name}.png`);
        }
      });
    },
  },

  /**
   * Action that copies everything in the assets directory to a new assets directory in the build path of the platform.
   *
   * @type {Action}
   * @memberof Actions
   */
  'copy_assets': {
    do(dictionary, config) {
      logger().log(`Copying assets directory to ${config.buildPath}assets`);
      fs$1.copySync('assets', `${config.buildPath}assets`);
    },
    undo(dictionary, config) {
      logger().log(`Removing assets directory from ${config.buildPath}assets`);
      fs$1.removeSync(`${config.buildPath}assets`);
    },
  },
};

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * @namespace Filters
 */

var filter = {
  /**
   * Remove a token from the ditribution output if it contains a key `private` set to true
   *
   * @memberof Filters
   *
   * @param {Object} token
   * @returns {Boolean}
   */
  removePrivate(token) {
    return !((token && token.private))
  },
};

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const transformTypes = ['name', 'value', 'attribute'];

/**
 * Add a custom transform to the Style Dictionary
 * Transforms can manipulate a token's name, value, or attributes
 *
 * @static
 * @name registerTransform
 * @memberof module:style-dictionary
 * @function
 * @param {Object} transform - Transform object
 * @param {String} transform.type - Type of transform, can be: name, attribute, or value
 * @param {String} transform.name - Name of the transformer (used by transformGroup to call a list of transforms).
 * @param {Boolean} transform.transitive - If the value transform should be applied transitively, i.e. should be applied to referenced values as well as absolute values.
 * @param {Function} [transform.matcher] - Matcher function, return boolean if transform should be applied. If you omit the matcher function, it will match all tokens.
 * @param {Function} transform.transformer Modifies a design token object. The transformer function will receive the token and the platform configuration as its arguments. The transformer function should return a string for name transforms, an object for attribute transforms, and same type of value for a value transform.
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * StyleDictionary.registerTransform({
 *   name: 'time/seconds',
 *   type: 'value',
 *   matcher: function(token) {
 *     return token.attributes.category === 'time';
 *   },
 *   transformer: function(token) {
 *     // Note the use of prop.original.value,
 *     // before any transforms are performed, the build system
 *     // clones the original token to the 'original' attribute.
 *     return (parseInt(token.original.value) / 1000).toString() + 's';
 *   }
 * });
 * ```
 */
function registerTransform(options) {
  if (typeof options.type !== 'string')
    throw new Error('type must be a string')
  if (!transformTypes.includes(options.type))
    throw new Error(`${options.type} type is not one of: ${transformTypes.join(', ')}`)
  if (typeof options.name !== 'string')
    throw new Error('name must be a string')
  if (options.matcher && typeof options.matcher !== 'function')
    throw new Error('matcher must be a function')
  if (typeof options.transformer !== 'function')
    throw new Error('transformer must be a function')

  this.transform[options.name] = {
    type: options.type,
    matcher: options.matcher,
    transitive: !!options.transitive,
    transformer: options.transformer,
  };

  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Add a custom transformGroup to the Style Dictionary, which is a
 * group of transforms.
 * @static
 * @memberof module:style-dictionary
 * @param {Object} transformGroup
 * @param {String} transformGroup.name - Name of the transform group that will be referenced in config.json
 * @param {String[]} transformGroup.transforms - Array of strings that reference the name of transforms to be applied in order. Transforms must be defined and match the name or there will be an error at build time.
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * StyleDictionary.registerTransformGroup({
 *   name: 'Swift',
 *   transforms: [
 *     'attribute/cti',
 *     'size/pt',
 *     'name/cti'
 *   ]
 * });
 * ```
 */
function registerTransformGroup(options) {
  if (typeof options.name !== 'string')
    throw new Error('transform name must be a string')
  if (!isArray(options.transforms))
    throw new Error('transforms must be an array of registered value transforms')

  options.transforms.forEach((t) => {
    if (!(t in this.transform))
      throw new Error('transforms must be an array of registered value transforms')
  });

  this.transformGroup[options.name] = options.transforms;
  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * @module format
 */

/**
 * The formatter function that is called when Style Dictionary builds files.
 *
 * @function formatter
 * @memberof module:format
 * @param {Object} args - A single argument to support named parameters and destructuring.
 * @param {Object} args.dictionary - The transformed and resolved dictionary object
 * @param {Object} args.dictionary.tokens - Object structure of the tokens that has been transformed and references resolved.
 * @param {Array} args.dictionary.allTokens - Flattened array of all the tokens. This makes it easy to output a list, like a list of SCSS variables.
 * @param {function(value): Boolean} args.dictionary.usesReference - Use this function to see if a token's value uses a reference. This is the same function style dictionary uses internally to detect a reference.
 * @param {function(value): Value} args.dictionary.getReferences - Use this function to get the tokens that it references. You can use this to output a reference in your custom format. For example: `dictionary.getReferences(token.original.value) // returns an array of the referenced token objects`
 * @param {Object} args.platform - The platform configuration this format is being called in.
 * @param {Object} args.file - The file configuration this format is being called in.
 * @param {Object} args.options - Merged options object that combines platform level configuration and file level configuration. File options take precedence.
 * @returns {String}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({dictionary, platform, options, file}) {
 *     return JSON.stringify(dictionary.tokens, null, 2);
 *   }
 * })
 * ```
 */

/**
 * Add a custom format to the style dictionary
 * @static
 * @memberof module:style-dictionary
 * @param {Object} format
 * @param {String} format.name - Name of the format to be referenced in your config.json
 * @param {function} format.formatter - Function to perform the format. Takes a single argument. See [creating custom formats](formats.md#creating-formats)
 * Must return a string, which is then written to a file.
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'json',
 *   formatter: function({dictionary, platform, options, file}) {
 *     return JSON.stringify(dictionary.tokens, null, 2);
 *   }
 * })
 * ```
 */
function registerFormat(options) {
  if (typeof options.name !== 'string')
    throw new Error('Can\'t register format; format.name must be a string')
  if (typeof options.formatter !== 'function')
    throw new Error('Can\'t register format; format.formatter must be a function')

  this.format[options.name] = options.formatter;

  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const REGISTER_TEMPLATE_DEPRECATION_WARNINGS$1 = GroupMessages.GROUP.RegisterTemplateDeprecationWarnings;

/**
 * Add a custom template to the Style Dictionary
 * @static
 * @deprecated registerTemplate will be removed in the future, please use registerFormat
 * @memberof module:style-dictionary
 * @param {Object} template
 * @param {String} template.name - The name of your template. You will refer to this in your config.json file.
 * @param {String} template.template - Path to your lodash template
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * StyleDictionary.registerTemplate({
 *   name: 'Swift/colors',
 *   template: `src/common` + '/templates/swift/colors.template'
 * });
 * ```
 */
function registerTemplate(options) {
  if (typeof options.name !== 'string')
    throw new Error(`Template name must be a string: ${chalk.red(JSON.stringify(options.name))}`)
  if (typeof options.template !== 'string')
    throw new Error(`Template path must be a string: ${chalk.red(JSON.stringify(options.template))}`)
  if (!fs.existsSync(options.template))
    throw new Error(`Can't find template: ${chalk.red(JSON.stringify(options.template))}`)

  GroupMessages.add(
    REGISTER_TEMPLATE_DEPRECATION_WARNINGS$1,
    `${options.name}`
  );

  const template_string = fs.readFileSync(options.template);

  this.format[options.name] = _template(template_string);
  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Adds a custom action to Style Dictionary. Custom
 * actions can do whatever you need, such as: copying files,
 * base64'ing files, running other build scripts, etc.
 * After you register a custom action, you then use that
 * action in a platform your config.json
 *
 * You can perform operations on files generated by the style dictionary
 * as actions run after these files are generated.
 * Actions are run sequentially, if you write synchronous code then
 * it will block other actions, or if you use asynchronous code like Promises
 * it will not block.
 *
 * @static
 * @memberof module:style-dictionary
 * @param {Object} action
 * @param {String} action.name - The name of the action
 * @param {Function} action.do - The action in the form of a function.
 * @param {Function} [action.undo] - A function that undoes the action.
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * StyleDictionary.registerAction({
 *   name: 'copy_assets',
 *   do: function(dictionary, config) {
 *     logger().log('Copying assets directory');
 *     fs.copySync('assets', config.buildPath + 'assets');
 *   },
 *   undo: function(dictionary, config) {
 *     logger().log('Cleaning assets directory');
 *     fs.removeSync(config.buildPath + 'assets');
 *   }
 * });
 * ```
 */
function registerAction(options) {
  if (typeof options.name !== 'string')
    throw new Error('name must be a string')
  if (typeof options.do !== 'function')
    throw new Error('do must be a function')

  this.action[options.name] = {
    do: options.do,
    undo: options.undo,
  };

  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Add a custom filter to the style dictionary
 * @static
 * @memberof module:style-dictionary
 * @param {Object} filter
 * @param {String} filter.name - Name of the filter to be referenced in your config.json
 * @param {Function} filter.matcher - Matcher function, return boolean if the token should be included.
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * StyleDictionary.registerFilter({
 *   name: 'isColor',
 *   matcher: function(token) {
  *     return token.attributes.category === 'color';
  *   }
 * })
 * ```
 */
function registerFilter(options) {
  if (typeof options.name !== 'string')
    throw new Error('Can\'t register filter; filter.name must be a string')
  if (typeof options.matcher !== 'function')
    throw new Error('Can\'t register filter; filter.matcher must be a function')

  this.filter[options.name] = options.matcher;

  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Adds a custom parser to parse style dictionary files
 * @static
 * @memberof module:style-dictionary
 * @param {Regex} pattern - A file path regular expression to match which files this parser should be be used on. This is similar to how webpack loaders work. `/\.json$/` will match any file ending in '.json', for example.
 * @param {Function} parse - Function to parse the file contents. Takes 1 argument, which is an object with 2 attributes: contents wich is the string of the file contents and filePath. The function should return a plain Javascript object.
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * StyleDictionary.registerParser({
 *   pattern: /\.json$/,
 *   parse: ({contents, filePath}) => {
 *     return JSON.parse(contents);
 *   }
 * })
 * ```
 */
function registerParser(options) {
  if (!(options.pattern instanceof RegExp))
    throw new Error('Can\'t register parser; parser.pattern must be a regular expression')
  if (typeof options.parse !== 'function')
    throw new Error('Can\'t register parser; parser.parse must be a function')

  this.parsers.push(options);

  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Add a custom file header to the style dictionary. File headers are used in
 * formats to display some information about how the file was built in a comment.
 * @static
 * @memberof module:style-dictionary
 * @param {Object} options
 * @param {String} options.name - Name of the format to be referenced in your config.json
 * @param {function} options.fileHeader - Function that returns an array of strings, which will be mapped to comment lines. It takes a single argument which is the default message array. See [file headers](formats.md#file-headers) for more information.
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * StyleDictionary.registerFileHeader({
 *   name: 'myCustomHeader',
 *   fileHeader: function(defaultMessage) {
 *     return [
 *       ...defaultMessage,
 *       `hello, world!`
 *     ];
 *   }
 * })
 * ```
 */

function registerFileHeader(options) {
  if (typeof options.name !== 'string')
    throw new Error('Can\'t register file header; options.name must be a string')
  if (typeof options.fileHeader !== 'function')
    throw new Error('Can\'t register file header; options.fileHeader must be a function')

  this.fileHeader[options.name] = options.fileHeader;

  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const defaults$1 = {
  opening_character: '{',
  closing_character: '}',
  separator: '.',
};

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

function createReferenceRegex(opts = {}) {
  const options = Object.assign({}, defaults$1, opts);

  return new RegExp(
    `\\${
    options.opening_character
    }([^${
    options.closing_character
    }]+)`
    + `\\${
    options.closing_character}`, 'g'
  )
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Checks if the value uses a value reference.
 * @memberof Dictionary
 * @param {string} value
 * @param {Object|RegExp} regexOrOptions
 * @returns {boolean} - True, if the value uses a value reference
 */
function usesReference(value, regexOrOptions = {}) {
  const regex = regexOrOptions instanceof RegExp ? regexOrOptions : createReferenceRegex(regexOrOptions);

  if (typeof value === 'string')
    return regex.test(value)

  if (typeof value === 'object') {
    let hasReference = false;
    // iterate over each property in the object,
    // if any element passes the regex test,
    // the whole thing should be true
    for (const key in value) {
      if (value.hasOwnProperty(key)) {
        const element = value[key];
        const reference = usesReference(element, regexOrOptions);
        if (reference) {
          hasReference = true;
          break
        }
      }
    }
    return hasReference
  }

  return false
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Returns the paths name be joining its parts with a given separator.
 *
 * @private
 * @param {Array} path
 * @param {Object} opts
 * @returns {string} - The paths name
 */
function getName(path, opts = {}) {
  const options = Object.assign({}, defaults$1, opts);
  if (!path || !(Array.isArray(path)))
    throw new Error('Getting name for path failed. Path must be an array')

  return path.join(options.separator)
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Returns the path from a path name be splitting the name by a given separator.
 *
 * @private
 * @param {string} pathName
 * @param {Object} opts
 * @returns {Array} - The path
 */
function getPathFromName(pathName, opts = {}) {
  const options = Object.assign({}, defaults$1, opts);
  if (typeof pathName !== 'string')
    throw new Error('Getting path from name failed. Name must be a string')

  return pathName.split(options.separator)
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

function resolveReference(path, obj) {
  let i;
  let ref = obj;

  if (!Array.isArray(path))
    return

  for (i = 0; i < path.length; i++) {
    // Check for undefined as 0 is a valid, truthy value
    if (typeof ref[path[i]] !== 'undefined') {
      ref = ref[path[i]];
    }
    else {
      // set the reference as undefined if we don't find anything
      ref = undefined;
      break
    }
  }

  return ref
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const PROPERTY_REFERENCE_WARNINGS$1 = GroupMessages.GROUP.PropertyReferenceWarnings;

let current_context = []; // To maintain the context to be able to test for circular definitions
const defaults = {
  ignoreKeys: ['original'],
  ignorePaths: [],
};
let updated_object, regex, options;

function resolveObject(object, opts) {
  options = Object.assign({}, defaults, opts);

  updated_object = cloneDeep(object); // This object will be edited

  regex = createReferenceRegex(options);

  if (typeof object === 'object') {
    current_context = [];
    return traverseObj$1(updated_object)
  }
  else {
    throw new TypeError('Please pass an object in')
  }
}

function traverseObj$1(obj) {
  let key;

  for (key in obj) {
    if (!obj.hasOwnProperty(key))
      continue

    // We want to check for ignoredKeys, this is to
    // skip over attributes that should not be
    // mutated, like a copy of the original property.
    if (options.ignoreKeys && options.ignoreKeys.includes(key))
      continue

    current_context.push(key);
    if (typeof obj[key] === 'object') {
      traverseObj$1(obj[key]);
    }
    else {
      if (typeof obj[key] === 'string' && obj[key].includes('{'))
        obj[key] = compile_value(obj[key], [getName(current_context)]);
    }
    current_context.pop();
  }

  return obj
}

const foundCirc = {};
function compile_value(value, stack) {
  let to_ret = value; let ref;

  // Replace the reference inline, but don't replace the whole string because
  // references can be part of the value such as "1px solid {color.border.light}"
  value.replace(regex, (match, variable) => {
    variable = variable.trim();

    // Find what the value is referencing
    const pathName = getPathFromName(variable, options);
    const context = getName(current_context, options);
    const refHasValue = pathName[pathName.length - 1] === 'value';

    if (refHasValue && options.ignorePaths.includes(variable))
      return value
    else if (!refHasValue && options.ignorePaths.includes(`${variable}.value`))
      return value

    stack.push(variable);

    ref = resolveReference(pathName, updated_object);

    // If the reference doesn't end in 'value'
    // and
    // the reference points to someplace that has a `value` attribute
    // we should take the '.value' of the reference
    // per the W3C draft spec where references do not have .value
    // https://design-tokens.github.io/community-group/format/#aliases-references
    if (!refHasValue && ref && ref.hasOwnProperty('value'))
      ref = ref.value;

    if (typeof ref !== 'undefined') {
      if (typeof ref === 'string' || typeof ref === 'number') {
        to_ret = value.replace(match, ref);

        // Recursive, therefore we can compute multi-layer variables like a = b, b = c, eventually a = c
        if (usesReference(to_ret, regex)) {
          const reference = to_ret.slice(1, -1);

          // Compare to found circular references
          if (foundCirc.hasOwnProperty(reference)) ;
          else if (stack.includes(reference)) {
            // If the current stack already contains the current reference, we found a new circular reference
            // chop down only the circular part, save it to our circular reference info, and spit out an error

            // Get the position of the existing reference in the stack
            const stackIndexReference = stack.indexOf(reference);

            // Get the portion of the stack that starts at the circular reference and brings you through until the end
            const circStack = stack.slice(stackIndexReference);

            // For all the references in this list, add them to the list of references that end up in a circular reference
            circStack.forEach((key) => { foundCirc[key] = true; });

            // Add our found circular reference to the end of the cycle
            circStack.push(reference);

            // Add circ reference info to our list of warning messages
            GroupMessages.add(
              PROPERTY_REFERENCE_WARNINGS$1,
              `Circular definition cycle:  ${circStack.join(', ')}`
            );
          }
          else {
            to_ret = compile_value(to_ret, stack);
          }
        }
        // if evaluated value is a number and equal to the reference, we want to keep the type
        if (typeof ref === 'number' && ref.toString() === to_ret)
          to_ret = ref;
      }
      else {
        // if evaluated value is not a string or number, we want to keep the type
        to_ret = ref;
      }
    }
    else {
      GroupMessages.add(
        PROPERTY_REFERENCE_WARNINGS$1,
        `Reference doesn't exist: ${context} tries to reference ${variable}, which is not defined`
      );
      to_ret = ref;
    }
    stack.pop(variable);

    return to_ret
  });

  return to_ret
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Applies all transforms to a property. This is a pure function,
 * it returns a new property object rather than mutating it inline.
 * @private
 * @param {Object} property
 * @param {Object} options
 * @returns {Object} - A new property object with transforms applied.
 */
function transformProperty(property, options) {
  const to_ret = clone(property);
  const transforms = options.transforms;

  for (let i = 0; i < transforms.length; i++) {
    const transform = transforms[i];

    if (!transform.matcher || transform.matcher(to_ret)) {
      if (transform.type === 'name')
        to_ret.name = transform.transformer(to_ret, options);
      // Don't try to transform the value if it is referencing another value
      // Only try to transform if the value is not a string or if it has '{}'
      if (transform.type === 'value' && !usesReference(property.value, options)) {
        // Only transform non-referenced values (from original)
        // and transitive transforms if the value has been resolved
        if (!usesReference(property.original.value, options) || transform.transitive)
          to_ret.value = transform.transformer(to_ret, options);
      }

      if (transform.type === 'attribute')
        to_ret.attributes = Object.assign({}, to_ret.attributes, transform.transformer(to_ret, options));
    }
  }

  return to_ret
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Performs an deep extend on the objects, from right to left.
 * @private
 * @param {Object[]} objects - An array of JS objects
 * @param {Function} collision - A function to be called when a merge collision happens.
 * @param {string[]} path - (for internal use) An array of strings which is the current path down the object when this is called recursively.
 * @returns {Object}
 */
function deepExtend(objects, collision, path) {
  if (objects == null)
    return {}

  let src; let copyIsArray; let copy; let name; let options; let clone;
  let target = objects[0] || {};
  let i = 1;
  const length = objects.length;

  path = path || [];

  // Handle case when target is a string or something (possible in deep copy)
  if (typeof target !== 'object')
    target = {};

  for (; i < length; i++) {
    // Only deal with non-null/undefined values
    options = objects[i];
    if (options != null) {
      // Extend the base object
      for (name in options) {
        if (!options.hasOwnProperty(name))
          continue
        if (name === '__proto__')
          continue

        src = target[name];
        copy = options[name];

        // Prevent never-ending loop
        if (target === copy)
          continue

        // Recurse if we're merging plain objects or arrays
        copyIsArray = isArray(copy);
        if (copy && (isPlainObject(copy) || copyIsArray)) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src && isArray(src) ? src : [];
          }
          else {
            clone = src && isPlainObject(src) ? src : {};
          }

          const nextPath = path.slice(0);
          nextPath.push(name);

          // Never move original objects, clone them
          target[name] = deepExtend([clone, copy], collision, nextPath);

          // Don't bring in undefined values
        }
        else if (copy !== undefined) {
          if (src != null && typeof collision == 'function')
            collision({ target, copy: options, path, key: name });

          target[name] = copy;
        }
      }
    }
  }

  return target
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes a property object, a leaf node in a properties object, and
 * returns a new object that has some properties set. It clones the
 * original object for safekeeping, adds a name, adds an attributes object,
 * and a path array.
 * @private
 * @param {Object} property - the property object to setup
 * @param {String} name - The name of the property, which will should be its key in the object.
 * @param {Array} path - The path of keys to get to the property from the top level of the properties object.
 * @returns {Object} - A new object that is setup and ready to go.
 */
function propertySetup(property, name, path) {
  if (!property && !isPlainObject(property))
    throw new Error('Property object must be an object')
  if (!name || !isString(name))
    throw new Error('Name must be a string')
  if (!path || !isArray(path))
    throw new Error('Path must be an array')

  let to_ret = property;

  // Only do this once
  if (!property.original) {
    // Initial property setup
    // Keep the original object properties like it was in file (whitout additional data)
    // so we can key off them in the transforms
    to_ret = deepExtend([{}, property]);
    const to_ret_original = deepExtend([{}, property]);
    delete to_ret_original.filePath;
    delete to_ret_original.isSource;

    to_ret.original = to_ret_original;
    // Copy the name - it will be our base name to transform
    to_ret.name = to_ret.name || name || '';
    // Create an empty attributes object that we can transform on it later
    to_ret.attributes = to_ret.attributes || {};
    // An array of the path down the object tree; we will use it to build readable names
    // like color_font_base
    to_ret.path = clone(path);
  }

  return to_ret
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Applies transforms on all tokens. This
 * does not happen inline, rather it is functional
 * and returns a new object. By doing this,
 * we can perform transforms for different platforms
 * on the same style dictionary.
 * @private
 * @param {Object} obj
 * @param {Object} options
 * @param {Object} [transformationContext={}]
 * @param {Array} [path=[]]
 * @param {Object} [transformedObj={}]
 * @returns {Object}
 */
function transformObject(obj, options, transformationContext = {}, path, transformedObj) {
  transformedObj = transformedObj || {};
  path = path || [];
  const { transformedPropRefs = [], deferredPropValueTransforms = [] } = transformationContext;

  for (const name in obj) {
    if (!obj.hasOwnProperty(name))
      continue

    path.push(name);
    const objProp = obj[name];
    const isPlainObject$1 = isPlainObject(objProp);

    // is the objProp a style property?
    // {
    //   value: "#ababab"
    //   ...
    // }
    if (isPlainObject$1 && 'value' in objProp) {
      const pathName = getName(path);
      const alreadyTransformed = transformedPropRefs.includes(pathName);

      // If the property is already transformed, just pass assign it to the
      // transformed object and move on.
      if (alreadyTransformed) {
        transformedObj[name] = objProp;
        path.pop();
        continue
      }

      // Note: propertySetup won't re-run if property has already been setup
      // it is safe to run this multiple times on the same property.
      const setupProperty = propertySetup(objProp, name, path);

      // If property has a reference, defer its transformations until later
      if (usesReference(setupProperty.value, options)) {
        // If property path isn't in the deferred array, add it now.
        if (!deferredPropValueTransforms.includes(pathName))
          deferredPropValueTransforms.push(pathName);

        transformedObj[name] = setupProperty;
        path.pop();
        continue
      }

      // If we got here, the property hasn't been transformed yet and
      // does not use a value reference. Transform the property now and assign it.
      transformedObj[name] = transformProperty(setupProperty, options);
      // Remove the property path from the deferred transform list
      pull(deferredPropValueTransforms, pathName);
      // Add the property path to the transformed list so we don't transform it again.
      transformedPropRefs.push(pathName);
    }
    else if (isPlainObject$1) {
      // objProp is not a token -> go deeper down the object tree
      transformedObj[name] = transformObject(objProp, options, transformationContext, path, transformedObj[name]);
    }
    else {
      // objProp is not a token or an object then it is some other data in the
      // object we should just copy over. There might be metadata
      // like documentation in the object that is not part of a token/property.
      transformedObj[name] = objProp;
    }

    path.pop();
  }

  return transformedObj
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const TEMPLATE_DEPRECATION_WARNINGS$1 = GroupMessages.GROUP.TemplateDeprecationWarnings;
const MISSING_TRANSFORM_ERRORS = GroupMessages.GROUP.MissingRegisterTransformErrors;

/**
 * Takes a platform config object and returns a new one
 * that has filters, transforms, formats, and actions
 * mapped properly.
 * @private
 * @param {Object} config
 * @param {Object} dictionary
 * @param {Object} platformName (only used for error messaging)
 * @returns {Object}
 */
function transformConfig(config, dictionary, platformName) {
  const to_ret = clone(config);

  // The platform can define either a transformGroup or an array
  // of transforms. If given a transformGroup that doesn't exist,
  // it will throw an error to make the user aware that the transformGroup doesn't
  // exist. A valid case is if the user defines neither, no transforms will be
  // applied.
  let transforms = [];
  if (to_ret.transforms) {
    transforms = to_ret.transforms.filter(Boolean);
  }
  else if (to_ret.transformGroup) {
    if (dictionary.transformGroup[to_ret.transformGroup]) {
      transforms = dictionary.transformGroup[to_ret.transformGroup];
    }
    else {
      const err
      = `Unknown transformGroup "${to_ret.transformGroup}" found in platform "${platformName}":\n`
      + `"${to_ret.transformGroup}" does not match the name of a registered transformGroup.\n`;

      throw new Error(err)
    }
  }

  // Transforms are an array of strings that map to functions on
  // the StyleDictionary module. We need to map the strings to
  // the actual functions.
  to_ret.transforms = transforms.map((name) => {
    if (!dictionary.transform[name]) {
      GroupMessages.add(
        MISSING_TRANSFORM_ERRORS,
        `"${name}"`
      );
    }
    return dictionary.transform[name]
  });

  const missingTransformCount = GroupMessages.count(MISSING_TRANSFORM_ERRORS);

  if (missingTransformCount > 0) {
    const transform_warnings = GroupMessages.flush(MISSING_TRANSFORM_ERRORS).join(', ');

    const err
    = `Unknown transforms ${transform_warnings} found in platform "${platformName}":\n`
    + `None of ${transform_warnings} match the name of a registered transform.`;

    throw new Error(err)
  }

  // Apply registered fileHeaders onto the platform options
  if (config.options && config.options.fileHeader) {
    const fileHeader = config.options.fileHeader;
    if (typeof fileHeader === 'string') {
      if (dictionary.fileHeader[fileHeader])
        to_ret.options.fileHeader = dictionary.fileHeader[fileHeader];
      else
        throw new Error(`Can't find fileHeader: ${fileHeader}`)
    }
    else if (typeof fileHeader !== 'function') {
      throw new TypeError('fileHeader must be a string or a function')
    }
    else {
      to_ret.options.fileHeader = fileHeader;
    }
  }

  to_ret.files = (config.files || []).map((file) => {
    const ext = { options: {} };
    if (file.options && file.options.fileHeader) {
      const fileHeader = file.options.fileHeader;
      if (typeof fileHeader === 'string') {
        if (dictionary.fileHeader[fileHeader])
          ext.options.fileHeader = dictionary.fileHeader[fileHeader];
        else
          throw new Error(`Can't find fileHeader: ${fileHeader}`)
      }
      else if (typeof fileHeader !== 'function') {
        throw new TypeError('fileHeader must be a string or a function')
      }
      else {
        ext.options.fileHeader = fileHeader;
      }
    }

    if (file.filter) {
      if (typeof file.filter === 'string') {
        if (dictionary.filter[file.filter])
          ext.filter = dictionary.filter[file.filter];
        else
          throw new Error(`Can't find filter: ${file.filter}`)
      }
      else if (typeof file.filter === 'object') {
        ext.filter = matches(file.filter);
      }
      else if (typeof file.filter === 'function') {
        ext.filter = file.filter;
      }
      else {
        throw new TypeError(`Filter format not valid: ${typeof file.filter}`)
      }
    }

    if (file.template) {
      if (dictionary.format[file.template]) {
        GroupMessages.add(
          TEMPLATE_DEPRECATION_WARNINGS$1,
          `${file.destination} (template: ${file.template})`
        );
        ext.format = dictionary.format[file.template];
      }
      else {
        throw new Error(`Can't find template: ${file.template}`)
      }
    }
    else if (file.format) {
      if (dictionary.format[file.format])
        ext.format = dictionary.format[file.format];
      else
        throw new Error(`Can't find format: ${file.format}`)
    }
    else {
      throw new Error(`Please supply a format for file: ${JSON.stringify(file)}`)
    }
    return deepExtend([{}, file, ext])
  });

  to_ret.actions = (config.actions || []).map((action) => {
    if (typeof dictionary.action[action].undo !== 'function')
      logger().warn(`${action} action does not have a clean function!`);

    return dictionary.action[action]
  });

  return to_ret
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const PROPERTY_REFERENCE_WARNINGS = GroupMessages.GROUP.PropertyReferenceWarnings;

/**
 * Exports a tokens object with applied
 * platform transforms.
 *
 * This is useful if you want to use a style
 * dictionary in JS build tools like webpack.
 *
 * @static
 * @memberof module:style-dictionary
 * @param {String} platform - The platform to be exported.
 * Must be defined on the style dictionary.
 * @returns {Object}
 */
function exportPlatform(platform) {
  if (!platform || !this.options.platforms[platform])
    throw new Error('Please supply a valid platform')

  // We don't want to mutate the original object
  const platformConfig = transformConfig(this.options.platforms[platform], this);

  let exportableResult = this.properties;

  // list keeping paths of props with applied value transformations
  const transformedPropRefs = [];
  // list keeping paths of props that had references in it, and therefore
  // could not (yet) have transformed
  const deferredPropValueTransforms = [];

  const transformationContext = {
    transformedPropRefs,
    deferredPropValueTransforms,
  };

  let deferredPropCount = 0;
  let finished;

  while (typeof finished === 'undefined') {
    // We keep up transforming and resolving until all props are resolved
    // and every defined transformation was executed. Remember: transformations
    // can only be executed, if the value to be transformed, has no references
    // in it. So resolving may lead to enable further transformations, and sub
    // sequent resolving may enable even more transformations - and so on.
    // So we keep this loop running until sub sequent transformations are ineffective.
    //
    // Take the following example:
    //
    // color.brand = {
    //   value: "{color.base.green}"
    // }
    //
    // color.background.button.primary.base = {
    //   value: "{color.brand.value}",
    //   color: {
    //     desaturate: 0.5
    //   }
    // }
    //
    // color.background.button.primary.hover = {
    //   value: "{color.background.button.primary.base}",
    //   color: {
    //     darken: 0.2
    //   }
    // }
    //
    // As you can see 'color.background.button.primary.hover' is a variation
    // of 'color.background.button.primary.base' which is a variation of
    // 'color.base.green'. These transitive references are solved by running
    // this loop until all properties are transformed and resolved.

    // We need to transform the object before we resolve the
    // variable names because if a value contains concatenated
    // values like "1px solid {color.border.base}" we want to
    // transform the original value (color.border.base) before
    // replacing that value in the string.
    const transformed = transformObject(exportableResult, platformConfig, transformationContext);

    // referenced values, that have not (yet) been transformed should be excluded from resolving
    const ignorePathsToResolve = deferredPropValueTransforms.map(p => getName([p, 'value']));
    exportableResult = resolveObject(transformed, { ignorePaths: ignorePathsToResolve });

    const newDeferredPropCount = deferredPropValueTransforms.length;

    // nothing left to transform -> ready
    if (newDeferredPropCount === 0) {
      finished = true;
    // or deferred count doesn't go down, that means there
    // is a circular reference -> ready (but errored)
    }
    else if (deferredPropCount === newDeferredPropCount) {
      // if we didn't resolve any deferred references then we have a circular reference
      // the resolveObject method will find the circular references
      // we do this in case there are multiple circular references
      resolveObject(transformed);
      finished = true;
    }
    else {
      // neither of these things, keep going.
      deferredPropCount = newDeferredPropCount;
    }
  }

  if (GroupMessages.count(PROPERTY_REFERENCE_WARNINGS) > 0) {
    const warnings = GroupMessages.flush(PROPERTY_REFERENCE_WARNINGS).join('\n');
    logger().log(`\n${PROPERTY_REFERENCE_WARNINGS}:\n${warnings}\n\n`);
    throw new Error('Problems were found when trying to resolve property references')
  }

  return exportableResult
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes a nested object of properties and filters them using the provided
 * function.
 *
 * @param {Object} properties
 * @param {Function} filter - A function that receives a property object and
 *   returns `true` if the property should be included in the output or `false`
 *   if the property should be excluded from the output.
 * @returns {Object[]} properties - A new object containing only the properties
 *   that matched the filter.
 */
function filterPropertyObject(properties, filter) {
  // Use reduce to generate a new object with the unwanted properties filtered out
  return reduce(properties, (result, value, key) => {
    // If the value is not an object, we don't know what it is. We return it as-is.
    if (!isObject(value)) {
      return result
    // If the value has a `value` member we know it's a property, pass it to
    // the filter function and either include it in the final `result` object or
    // exclude it (by returning the `result` object without it added).
    }
    else if (typeof value.value !== 'undefined') {
      return filter(value) ? assign(result, { [key]: value }) : result
    // If we got here we have an object that is not a property. We'll assume
    // it's an object containing multiple properties and recursively filter it
    // using the `filterPropertyObject` function.
    }
    else {
      const filtered = filterPropertyObject(value, filter);
      // If the filtered object is not empty then add it to the final `result`
      // object. If it is empty then every property inside of it was filtered
      // out, then exclude it entirely from the final `result` object.
      return isEmpty(filtered) ? result : assign(result, { [key]: filtered })
    }
  }, {})
}

/**
 * Takes an array of properties and filters them using the provided function.
 *
 * @param {Object[]} properties
 * @param {Function} filter - A function that receives a property object and
 *   returns `true` if the property should be included in the output or `false`
 *   if the property should be excluded from the output.
 * @returns {Object[]} properties - A new array containing only the properties
 *   that matched the filter.
 */
function filterPropertyArray(properties, filter) {
  return filter$1(properties, filter)
}

/**
 * Takes a dictionary and filters the `allProperties` array and the `properties`
 * object using a function provided by the user.
 *
 * @param {Object} dictionary
 * @param {Function} filter - A function that receives a token object
 *   and returns `true` if the token should be included in the output
 *   or `false` if the token should be excluded from the output
 * @returns {Object} dictionary - A new dictionary containing only the
 *   properties that matched the filter (or the original dictionary if no filter
 *   function was provided).
 */
function filterProperties(dictionary, filter) {
  if (!filter) {
    return dictionary
  }
  else {
    return {
      allProperties: filterPropertyArray(dictionary.allProperties, filter),
      properties: filterPropertyObject(dictionary.properties, filter),
    }
  }
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

function createFormatArgs({ dictionary, platform, file = {} }) {
  const { allProperties, properties, allTokens, tokens, usesReference, getReferences } = dictionary;
  // This will merge platform and file-level configuration
  // where the file configuration takes precedence
  const { options } = platform;
  file = deepExtend([{}, { options }, file]);

  return {
    dictionary,
    usesReference,
    getReferences,
    allProperties,
    properties,
    // adding tokens and allTokens as the new way starting in v3,
    // keeping properties and allProperties around for backwards-compatibility
    allTokens,
    tokens,
    platform,
    file,
    options: file.options || {},
  }
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes the style property object and a format and returns a
 * string that can be written to a file.
 * @memberOf StyleDictionary
 * @param {Object} file
 * @param {Object} platform
 * @param {Object} dictionary
 * @returns {null}
 */
function buildFile(file = {}, platform = {}, dictionary = {}) {
  const { destination, filter } = file || {};
  let { format } = file || {};

  const silent = file?.silent || platform?.silent || false;

  if (typeof format !== 'function')
    throw new Error('Please enter a valid file format')

  // get if the format is nested, this needs to be done before
  // the function is bound
  const nested = format.nested;

  // to maintain backwards compatibility we bind the format to the file object
  format = format.bind(file);

  let fullDestination = destination;
  const id = `${file?.format || ''}-${Date.now()}`;

  if (typeof destination === 'string') {
    // if there is a build path, prepend the full destination with it
    if (platform.buildPath)
      fullDestination = platform.buildPath + fullDestination;

    const dirname = path.dirname(fullDestination);
    if (!fs$1.existsSync(dirname))
      fs$1.mkdirsSync(dirname, { recursive: true });
  }

  const filteredProperties = filterProperties(dictionary, filter);
  const filteredDictionary = Object.assign({}, dictionary, {
    properties: filteredProperties.properties,
    allProperties: filteredProperties.allProperties,
    tokens: filteredProperties.properties,
    allTokens: filteredProperties.allProperties,
    // keep the unfiltered properties object for reference resolution
    _properties: dictionary.properties,
  });

  // if properties object is empty, return without creating a file
  if (
    filteredProperties.hasOwnProperty('properties')
    && Object.keys(filteredProperties.properties).length === 0
    && filteredProperties.properties.constructor === Object
  ) {
    const warnNoFile = `No properties for ${destination || id}. File not created.`;
    !silent && logger().log(chalk.red(warnNoFile));
    return null
  }

  // Check for property name Collisions
  const nameCollisionObj = {};
  filteredProperties.allProperties && filteredProperties.allProperties.forEach((propertyData) => {
    const propertyName = propertyData.name;
    if (!nameCollisionObj[propertyName])
      nameCollisionObj[propertyName] = [];

    nameCollisionObj[propertyName].push(propertyData);
  });

  const PROPERTY_NAME_COLLISION_WARNINGS = `${GroupMessages.GROUP.PropertyNameCollisionWarnings}:${destination || id}`;
  GroupMessages.clear(PROPERTY_NAME_COLLISION_WARNINGS);
  Object.keys(nameCollisionObj).forEach((propertyName) => {
    if (nameCollisionObj[propertyName].length > 1) {
      const collisions = nameCollisionObj[propertyName].map((properties) => {
        const propertyPathText = chalk.red(properties.path.join('.'));
        const valueText = chalk.red(properties.value);
        return `${propertyPathText}   ${valueText}`
      }).join('\n        ');
      GroupMessages.add(
        PROPERTY_NAME_COLLISION_WARNINGS,
        `Output name ${chalk.red.bold(propertyName)} was generated by:\n        ${collisions}`
      );
    }
  });

  const propertyNamesCollisionCount = GroupMessages.count(PROPERTY_NAME_COLLISION_WARNINGS);

  // Allows disabling file writings
  const result = format(createFormatArgs({
    dictionary: filteredDictionary,
    platform,
    file,
  }), platform, file);

  // Supports `write` at `platform` and `file` level
  if (platform?.write !== false && file?.write !== false) {
    fs$1.writeFileSync(
      fullDestination,
      result
    );
  }

  if (platform?.done && typeof platform?.done === 'function')
    platform?.done({ file, platform, dictionary, result });

  if (file?.done && typeof file?.done === 'function')
    file?.done({ file, platform, dictionary, result });

  const filteredReferencesCount = GroupMessages.count(GroupMessages.GROUP.FilteredOutputReferences);

  if (!silent) {
    // don't show name collision warnings for nested type formats
  // because they are not relevant.
    if ((nested || propertyNamesCollisionCount === 0) && filteredReferencesCount === 0) {
      logger().log(chalk.bold.green(`✔︎ ${fullDestination}`));
    }
    else {
      logger().log(`⚠️ ${fullDestination}`);
      if (propertyNamesCollisionCount > 0) {
        const propertyNamesCollisionWarnings = GroupMessages.fetchMessages(PROPERTY_NAME_COLLISION_WARNINGS).join('\n    ');
        const title = `While building ${chalk.red.bold(destination || id)}, token collisions were found; output may be unexpected.`;
        const help = chalk.red([
          'This many-to-one issue is usually caused by some combination of:',
          '* conflicting or similar paths/names in property definitions',
          '* platform transforms/transformGroups affecting names, especially when removing specificity',
          '* overly inclusive file filters',
        ].join('\n    '));
        const warn = `${title}\n    ${propertyNamesCollisionWarnings}\n${help}`;
        logger().log(chalk.red.bold(warn));
      }

      if (filteredReferencesCount > 0) {
        const filteredReferencesWarnings = GroupMessages.flush(GroupMessages.GROUP.FilteredOutputReferences).join('\n    ');
        const title = `While building ${chalk.red.bold(destination || id)}, filtered out token references were found; output may be unexpected. Here are the references that are used but not defined in the file`;
        const help = chalk.red([
          'This is caused when combining a filter and `outputReferences`.',
        ].join('\n    '));
        const warn = `${title}\n    ${filteredReferencesWarnings}\n${help}`;
        logger().log(chalk.red.bold(warn));
      }
    }
  }
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes a platform config object and a dictionary
 * object and builds all the files. Dictionary object
 * should have been transformed and resolved before this
 * point.
 * @memberOf StyleDictionary
 * @param {Object} dictionary
 * @param {Object} platform
 * @returns {null}
 */
function buildFiles(dictionary, platform) {
  if (platform.buildPath && (platform.buildPath.slice(-1) !== '/' && platform.buildPath.slice(-1) !== '\\'))
    throw new Error('Build path must end in a trailing slash or you will get weird file names.')

  platform.files.forEach((file) => {
    if (file.format)
      buildFile(file, platform, dictionary);
    else
      throw new Error('Please supply a format')
  });
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Performs any actions in a platform config. Pretty
 * simple really. Actions should be an array of functions,
 * the calling function should map the functions accordingly.
 * @private
 * @memberof module:style-dictionary
 * @param {Object} dictionary
 * @param {Object} platform
 * @returns {null}
 */
function performActions(dictionary, platform) {
  if (platform.actions) {
    platform.actions.forEach((action) => {
      action.do(dictionary, platform);
    });
  }
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes an plain javascript object and will make a flat array of all the leaf nodes.
 * A leaf node in this context has a 'value' property. Potentially refactor this to
 * be more generic.
 * @private
 * @param  {Object} properties - The plain object you want flattened into an array.
 * @param  {Array} [to_ret=[]] - Properties array. This function is recursive therefore this is what gets passed along.
 * @return {Array}
 */
function flattenProperties(properties, to_ret) {
  to_ret = to_ret || [];

  for (const name in properties) {
    if (properties.hasOwnProperty(name)) {
      // TODO: this is a bit fragile and arbitrary to stop when we get to a 'value' property.
      if (isPlainObject(properties[name]) && ('value' in properties[name]))
        to_ret.push(properties[name]);
      else if (isPlainObject(properties[name]))
        flattenProperties(properties[name], to_ret);
    }
  }

  return to_ret
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * This is a helper function that is added to the dictionary object that
 * is passed to formats and actions. It will resolve a reference giving
 * you access to the token (not just the value) that a value references.
 * This allows formats to have variable references in the output. For example:
 *
 * ```css
 * --color-background-base: var(--color-core-white);
 * ```
 *
 * @memberof Dictionary
 * @param {string} value the value that contains a reference
 * @param {object[]} references array of token's references because a token's value can contain multiple references due to string interpolation
 * @returns {any}
 */
function getReferences(value, references = []) {
  // eslint-disable-next-line @typescript-eslint/no-this-alias
  const self = this;

  // `this` is the dictionary object passed to formats and actions
  const regex = createReferenceRegex({});

  // this will update the references array with the referenced tokens it finds.
  function findReference(match, variable) {
    // remove 'value' to access the whole token object
    variable = variable.trim().replace('.value', '');

    // Find what the value is referencing
    const pathName = getPathFromName(variable);

    let ref = resolveReference(pathName, self.properties);
    if (!ref) {
      // fall back on _properties as it is unfiltered
      ref = resolveReference(pathName, self._properties);
      // and warn the user about this
      GroupMessages.add(GroupMessages.GROUP.FilteredOutputReferences, variable);
    }
    references.push(ref);
  }

  if (typeof value === 'string') {
    // function inside .replace runs multiple times if there are multiple matches
    value.replace(regex, findReference);
  }

  // If the token's value is an object, run the replace reference
  // on each value within that object. This mirrors the `usesReference`
  // function which iterates over the object to see if there is a reference
  if (typeof value === 'object') {
    for (const key in value) {
      if (value.hasOwnProperty(key) && typeof value[key] === 'string')
        value[key].replace(regex, findReference);

      // if it is an object, we go further down the rabbit hole
      if (value.hasOwnProperty(key) && typeof value[key] === 'object')
        self.getReferences(value[key], references);
    }
  }

  return references
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 *
 * @typedef Dictionary
 * @property {Object} properties - Deprecated
 * @property {Array} allProperties - Deprecated
 * @property {Object} tokens - Replacement for `properties`
 * @property {Array} allTokens - Replacement for `allProperties`
 * @property {Dictionary.getReferences} getReferences
 * @property {Dictionary.usesReference} usesReference
 */

/**
 * Creates the dictionary object that is passed to formats and actions.
 * @param {Object} args
 * @param {Object} args.properties
 * @returns {Dictionary}
 */
function createDictionary({ properties }) {
  const allProperties = flattenProperties(properties);
  return {
    properties,
    allProperties,
    // adding tokens and allTokens as the new way starting in v3,
    // keeping properties and allProperties around for backwards-compatibility
    tokens: properties,
    allTokens: allProperties,
    getReferences,
    usesReference,
  }
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes a platform and performs all transforms to
 * the tokens object (non-mutative) then
 * builds all the files and performs any actions. This is useful if you only want to
 * build the artifacts of one platform to speed up the build process.
 *
 * This method is also used internally in [buildAllPlatforms](#buildAllPlatforms) to
 * build each platform defined in the config.
 *
 * @static
 * @memberof module:style-dictionary
 * @param {String} platform - Name of the platform you want to build.
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * StyleDictionary.buildPlatform('web');
 * ```
 * ```bash
 * $ style-dictionary build --platform web
 * ```
 */
function buildPlatform(platform) {
  if (!this.options || !(platform in (this.options.platforms || {})))
    throw new Error(`Platform "${platform}" does not exist`)

  let properties;

  // We don't want to mutate the original object
  const platformConfig = transformConfig(this.options.platforms[platform], this, platform);

  if (!platformConfig?.silent)
    logger().log(`\n${platform}`);

  // We need to transform the object before we resolve the
  // variable names because if a value contains concatenated
  // values like "1px solid {color.border.base}" we want to
  // transform the original value (color.border.base) before
  // replacing that value in the string.

  // eslint-disable-next-line prefer-const
  properties = this.exportPlatform(platform);

  // This is the dictionary object we pass to the file
  // building and action methods.
  const dictionary = createDictionary({ properties });

  buildFiles(dictionary, platformConfig);
  performActions(dictionary, platformConfig);

  // For chaining
  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * The only top-level method that needs to be called
 * to build the Style Dictionary.
 *
 * @static
 * @memberof module:style-dictionary
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * import StyleDictionary from 'style-dictionary';
 * StyleDictionary.extend().buildAllPlatforms();
 * ```
 */
function buildAllPlatforms() {
  // eslint-disable-next-line @typescript-eslint/no-this-alias
  const self = this;

  Object.keys(this.options.platforms).forEach((key) => {
    self.buildPlatform(key);
  });

  // For chaining
  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes the style property object and a format and returns a
 * string that can be written to a file.
 * @memberOf StyleDictionary
 * @param {String} destination
 * @param {Function} format (unused)
 * @param {Object} platform
 * @param {Object} dictionary (unused)
 * @param {Function} filter (unused)
 * @returns {null}
 */
function cleanFile(file = {}, platform = {}) {
  let { destination } = file;

  const silent = file?.silent || platform?.silent || false;

  if (typeof destination !== 'string' || platform.write === false)
    return

  // if there is a clean path, prepend the destination with it
  if (platform.buildPath)
    destination = platform.buildPath + destination;

  if (!fs$1.existsSync(destination)) {
    !silent && logger().log(`${chalk.bold.red('!')} ${destination}, does not exist`);
    return
  }

  fs$1.unlinkSync(destination);
  !silent && logger().log(`${chalk.bold.red('-')} ${destination}`);
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes a platform config object and a dictionary
 * object and cleans all the files. Dictionary object
 * should have been transformed and resolved before this
 * point.
 * @memberOf StyleDictionary
 * @param {Object} dictionary
 * @param {Object} platform
 * @returns {null}
 */
function cleanFiles(dictionary, platform) {
  if (platform.buildPath && platform.buildPath.slice(-1) !== '/')
    throw new Error('Build path must end in a trailing slash or you will get weird file names.')

  // while neither the format or dictionary are used by clean file I'm passing them in for symmetry to buildFile
  platform.files.forEach((file) => {
    if (file.format)
      cleanFile(file, platform);
    else
      throw new Error('Please supply a template or formatter')
  });
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes the style property object and a format and returns a
 * string that can be written to a file.
 * @memberOf StyleDictionary
 * @param {Object} file
 * @param {Object} platform
 * @param {Object} dictionary (unused)
 * @returns {null}
 */
function cleanDir(file = {}, platform = {}) {
  let { destination } = file;

  const silent = file?.silent || platform?.silent || false;

  if (typeof destination !== 'string' || platform.write === false)
    return

  // if there is a clean path, prepend the destination with it
  if (platform.buildPath)
    destination = platform.buildPath + destination;

  let dirname = path.dirname(destination);

  while (dirname) {
    if (fs$1.existsSync(dirname)) {
      if (fs$1.readdirSync(dirname).length === 0) {
        !silent && logger().log(`${chalk.bold.red('-')} ${dirname}`);
        fs$1.rmdirSync(dirname);
      }
      else {
        break
      }
    }

    dirname = dirname.split('/');
    dirname.pop();
    dirname = dirname.join('/');
  }
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes a platform config object and a properties
 * object and cleans all the files. Properties object
 * should have been transformed and resolved before this
 * point.
 * @memberOf StyleDictionary
 * @param {Object} dictionary
 * @param {Object} platform
 * @returns {null}
 */
function cleanDirs(dictionary, platform) {
  if (platform.buildPath && platform.buildPath.slice(-1) !== '/')
    throw new Error('Build path must end in a trailing slash or you will get weird file names.')

  // while neither the format or dictionary are used by clean file I'm passing them in for symmetry to buildFile
  platform.files.forEach((file) => {
    if (file.format)
      cleanDir(file, platform);
    else
      throw new Error('Please supply a format')
  });
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Performs the undo of any actions defined in a platform. Pretty
 * simple really. Actions should be an array of functions,
 * the calling function should map the functions accordingly.
 * @static
 * @private
 * @memberof module:style-dictionary
 * @param {Object} dictionary
 * @param {Object} platform
 * @returns {null}
 */
function cleanActions(dictionary, platform) {
  if (platform.actions) {
    platform.actions.forEach((action) => {
      if (typeof action.undo === 'function')
        action.undo(dictionary, platform);
    });
  }
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Takes a platform and performs all transforms to
 * the tokens object (non-mutative) then
 * cleans all the files and performs the undo method of any [actions](actions.md).
 *
 * @static
 * @memberof module:style-dictionary
 * @param {String} platform
 * @returns {module:style-dictionary}
 */
function cleanPlatform(platform) {
  if (!this.options || !(platform in (this.options.platforms || {})))
    throw new Error(`Platform ${platform} doesn't exist`)

  let properties;

  // We don't want to mutate the original object
  const platformConfig = transformConfig(this.options.platforms[platform], this, platform);

  if (!platformConfig?.silent)
    logger().log(`\n${platform}`);

  // We need to transform the object before we resolve the
  // variable names because if a value contains concatenated
  // values like "1px solid {color.border.base}" we want to
  // transform the original value (color.border.base) before
  // replacing that value in the string.

  // eslint-disable-next-line prefer-const
  properties = this.exportPlatform(platform);

  // This is the dictionary object we pass to the file
  // cleaning and action methods.
  const dictionary = createDictionary({ properties });

  // We clean files first, then actions, ...and then directories?
  cleanFiles(dictionary, platformConfig);
  cleanActions(dictionary, platformConfig);
  cleanDirs(dictionary, platformConfig);

  // For chaining
  return this
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Does the reverse of [buildAllPlatforms](#buildAllPlatforms) by
 * performing a clean on each platform. This removes all the files
 * defined in the platform and calls the undo method on any actions.
 *
 * @static
 * @memberof module:style-dictionary
 * @returns {module:style-dictionary}
 */
function cleanAllPlatforms() {
  // eslint-disable-next-line @typescript-eslint/no-this-alias
  const self = this;

  Object.keys(this.options.platforms).forEach((key) => {
    self.cleanPlatform(key);
  });

  // For chaining
  return this
}

function resolveFileContent (resolvedPath) {
  let _content;
  if (resolvedPath.match(/.json5$/)) {
    const source = fs.readFileSync(resolvedPath, { encoding: 'UTF-8' });
    _content = JSON5.parse(source);
  }
  else if (resolvedPath.match(/.jsonc$/)) {
    const source = fs.readFileSync(resolvedPath, { encoding: 'UTF-8' });
    _content = parse(source);
  }
  else if (resolvedPath.match(/.json$/)) {
    const source = fs.readFileSync(resolvedPath, { encoding: 'UTF-8' });
    _content = JSON.parse(source);
  }
  else {
    _content = jiti(import.meta.url, { interopDefault: true, cache: false, v8cache: false, requireCache: false })(resolvedPath);
  }
  return _content
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

function traverseObj(obj, fn) {
  for (const key in obj) {
    // eslint-disable-next-line  no-useless-call
    fn.apply(null, [obj, key, obj[key]]);
    if (obj[key] && typeof obj[key] === 'object')
      traverseObj(obj[key], fn);
  }
}

/**
 * Takes an array of json files and merges
 * them together. Optionally does a deep extend.
 * @private
 * @param {String[]} arr - Array of paths to json (or node modules that export objects) files
 * @param {Boolean} [deep=false] - If it should perform a deep merge
 * @param {Function} collision - A function to be called when a name collision happens that isn't a normal deep merge of objects
 * @param {Boolean} [source=true] - If json files are "sources", tag properties
 * @param {Object[]} [parsers=[]] - Custom file parsers
 * @returns {Object}
 */
function combineJSON(arr, deep, collision, source, parsers = []) {
  let i; let files = [];
  const to_ret = {};

  for (i = 0; i < arr.length; i++) {
    const new_files = glob.sync(arr[i], {});
    files = files.concat(new_files);
  }

  for (i = 0; i < files.length; i++) {
    const filePath = files[i];

    const resolvedPath = path.isAbsolute(files[i])
      ? files[i]
      : path.resolve(process.cwd(), files[i]);

    let file_content = null;

    try {
      // Iterate over custom parsers, if the file path matches the parser's
      // pattern regex, use it's parse function to generate the object
      parsers.forEach(({ pattern, parse }) => {
        if (resolvedPath.match(pattern)) {
          file_content = parse({
            contents: fs.readFileSync(resolvedPath, { encoding: 'UTF-8' }),
            filePath: resolvedPath,
          });
        }
      });

      // If there is no file_content then no custom parser ran on that file
      if (!file_content) {
        const _content = resolveFileContent(resolvedPath);

        file_content = deepExtend([file_content, _content]);
      }
    }
    catch (e) {
      e.message = `Failed to load or parse JSON or JS Object: ${e.message}`;
      throw e
    }

    // Add some side data on each property to make filtering easier
    traverseObj(file_content, (obj) => {
      if (obj.hasOwnProperty('value') && !obj.filePath) {
        obj.filePath = filePath;

        obj.isSource = !!(source || source === undefined);
      }
    });

    if (deep)
      deepExtend([to_ret, file_content], collision);
    else
      Object.assign(to_ret, file_content);
  }

  return to_ret
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const PROPERTY_VALUE_COLLISIONS = GroupMessages.GROUP.PropertyValueCollisions;

/**
 * Either a string to a JSON file that contains configuration for the style dictionary or a plain Javascript object
 * that contains the configuration.
 * @typedef {(object|string)} Config
 * @prop {String[]} source - Paths to token files
 * @prop {Platform} platforms.platform - A platform
 * @example
 * ```json
 * {
 *   "source": ["tokens/*.json"],
 *   "platforms": {
 *     "scss": {
 *       "transformGroup": "scss",
 *       "buildPath": "web/sass/",
 *       "files": [
 *         {
 *           "format": "scss/variables",
 *           "destination": "_variables.scss"
 *         }
 *       ],
 *       "actions": ["copy_assets"]
 *     }
 *   }
 * }
 * ```
 */

/**
 * An object representing a platform
 * @typedef {Object} Platform
 * @prop {String} transformGroup
 * @prop {String} transforms
 */

/**
 * Create a Style Dictionary
 * @static
 * @memberof module:style-dictionary
 * @param {Config} config - Configuration options to build your style dictionary. If you pass a string,
 * it will be used as a path to a JSON config file. You can also pass an object with the configuration.
 * @returns {module:style-dictionary}
 * @example
 * ```js
 * import StyleDictionary from 'style-dictionary'
 * StyleDictionary.extend('config.json');
 *
 * StyleDictionary..extend({
 *   source: ['tokens/*.json'],
 *   platforms: {
 *     scss: {
 *       transformGroup: 'scss',
 *       buildPath: 'build/',
 *       files: [{
 *         destination: 'variables.scss',
 *         format: 'scss/variables'
 *       }]
 *     }
 *     // ...
 *   }
 * });
 * ```
 */
function extend(opts) {
  let options, to_ret;
  let inlineTokens = {};
  let includeTokens = {};
  let sourceTokens = {};

  // Overloaded method, can accept a string as a path that points to a JS or
  // JSON file or a plain object. Potentially refactor.
  if (isString(opts))
    options = resolveFileContent(opts);
  else
    options = opts;

  // Creating a new object and copying over the options
  // Also keeping an options object in case
  // eslint-disable-next-line prefer-const
  to_ret = deepExtend([{}, this, { options }, options]);

  // grab the inline tokens, ones either defined in the configuration object
  // or that already exist from extending another style dictionary instance
  // with `properties` or `tokens` keys
  inlineTokens = deepExtend([{}, (to_ret.tokens || {}), (to_ret.properties || {})]);

  // Update tokens with includes from dependencies
  if (options.include) {
    if (!isArray(options.include))
      throw new Error('include must be an array')

    includeTokens = combineJSON(options.include, true, null, false, to_ret.parsers);

    to_ret.include = null; // We don't want to carry over include references
  }

  // Update tokens with current package's source
  // These highest precedence
  if (options.source) {
    if (!isArray(options.source))
      throw new Error('source must be an array')

    sourceTokens = combineJSON(options.source, true, (prop) => {
      GroupMessages.add(
        PROPERTY_VALUE_COLLISIONS,
        `Collision detected at: ${prop.path.join('.')}! Original value: ${prop.target[prop.key]}, New value: ${prop.copy[prop.key]}`
      );
    }, true, to_ret.parsers);

    if (GroupMessages.count(PROPERTY_VALUE_COLLISIONS) > 0) {
      const collisions = GroupMessages.flush(PROPERTY_VALUE_COLLISIONS).join('\n');
      logger().log(`\n${PROPERTY_VALUE_COLLISIONS}:\n${collisions}\n\n`);
      if (options.log === 'error')
        throw new Error('Collisions detected')
    }

    to_ret.source = null; // We don't want to carry over the source references
  }

  // Merge inline, include, and source tokens
  const tokens = deepExtend([{}, inlineTokens, includeTokens, sourceTokens]);

  // Add tokens to both .tokens and .properties
  to_ret.tokens = tokens;
  to_ret.properties = tokens;

  return to_ret
}

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const TEMPLATE_DEPRECATION_WARNINGS = GroupMessages.GROUP.TemplateDeprecationWarnings;
const REGISTER_TEMPLATE_DEPRECATION_WARNINGS = GroupMessages.GROUP.RegisterTemplateDeprecationWarnings;
const SASS_MAP_FORMAT_DEPRECATION_WARNINGS = GroupMessages.GROUP.SassMapFormatDeprecationWarnings;

/**
 * Style Dictionary module
 *
 * @module style-dictionary
 * @typicalname StyleDictionary
 * @example
 * ```js
 * import StyleDictionary from 'style-dictionary';
 * StyleDictionary.extend('config.json');
 *
 * StyleDictionary.buildAllPlatforms();
 * ```
 */
const StyleDictionary = {
  VERSION: version,
  /**
   * @deprecated
   */
  properties: {},
  /**
   * @deprecated
   */
  allProperties: [],
  // Starting in v3 we are moving towards "tokens" rather than "properties"
  // keeping both for backwards compatibility
  tokens: {},
  allTokens: [],
  options: {},

  parsers: [], // we need to initialise the array, since we don't have built-in parsers
  fileHeader: {},

  transform,
  transformGroup,
  format: formats,
  action,
  formatHelpers,
  filter,
  logger,

  registerTransform,
  registerTransformGroup,
  registerFormat,
  registerAction,
  registerFilter,
  registerParser,
  registerFileHeader,
  exportPlatform,
  buildPlatform,
  buildAllPlatforms,
  cleanPlatform,
  cleanAllPlatforms,
  extend,

  /**
   * @deprecated registerTemplate will be removed in the future, please use registerFormat
   */
  registerTemplate,
};

process.on('exit', () => {
  if (GroupMessages.count(TEMPLATE_DEPRECATION_WARNINGS) > 0) {
    const template_warnings = GroupMessages.flush(TEMPLATE_DEPRECATION_WARNINGS).join('\n  ');
    logger().log(chalk.bold.yellow(`
⚠️ DEPRECATION WARNING ️️️️️⚠️
Templates are deprecated and will be removed, please update your config to use formats.
This is an example of how to update your config.json:

Before:
  "files": [{
    "destination": "colors.xml",
    "template": "android/colors"
  }]

After:
  "files": [{
    "destination": "colors.xml",
    "format": "android/colors"
  }]

Your current config uses the following templates:
  ${template_warnings}
`));
  }

  if (GroupMessages.count(REGISTER_TEMPLATE_DEPRECATION_WARNINGS) > 0) {
    const register_template_warnings = GroupMessages.flush(REGISTER_TEMPLATE_DEPRECATION_WARNINGS).join('\n  ');
    logger().log(chalk.bold.yellow(`
⚠️ DEPRECATION WARNING ️️️️️⚠️
The registerTemplate method is deprecated and will be removed, please
migrate to registerFormat. You can use any templating engine you would
like, you only need to require/import it. This is an example of how to
update your code using a lodash template (the template engine previously
used by registerTemplate):

Before:
  registerTemplate({
    name: 'template/name',
    template: templateFile,
  });

After:
  registerFormat({
    name: 'template/name',
    formatter: _.template( fs.readFileSync( templateFile ) ),
  });

Note that formatter is a function that takes in a style dictionary
and returns a string with the formatted output. There is a second
argument available that contains the configuration being used to
process the style dictionary.

Calls to registerTemplate included the registration of the following
custom templates:
  ${register_template_warnings}`));
  }

  if (GroupMessages.count(SASS_MAP_FORMAT_DEPRECATION_WARNINGS) > 0) {
    const sass_map_format_warnings = GroupMessages.flush(SASS_MAP_FORMAT_DEPRECATION_WARNINGS).join('\n  ');
    logger().log(chalk.bold.cyan(`
🔔 NOTICE 🔔
The formats 'sass/map-***' have been renamed to 'scss/map-***', please update your config.
In the future 'sass/map-***' formats may output actual Sass instead of SCSS, which may break your current configuration.
This is an example of how to update your config.json:

Before:
  "files": [{
    "destination": "tokens_map-flat.scss",
    "format": "sass/map-flat"
  }]

After:
  "files": [{
    "destination": "tokens_map-flat.scss",
    "format": "scss/map-flat"
  }]

Your current config uses the following formats:
  ${sass_map_format_warnings}
`));
  }
});

export { StyleDictionary as default };
