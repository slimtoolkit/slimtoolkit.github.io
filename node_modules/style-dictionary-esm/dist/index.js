import chalk2 from 'chalk';
import path4 from 'path';
import Color from 'tinycolor2';
import * as _ChangeCase from 'change-case';
import fs2 from 'fs';
import { fileURLToPath } from 'url';
import { resolve, dirname, join } from 'pathe';
import _template from 'lodash.template';
import fs3 from 'fs-extra';
import consola from 'consola';
import JSON5 from 'json5';
import { parse } from 'jsonc-parser';
import jiti from 'jiti';
import glob from 'glob';

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// package.json
var version = "1.0.14";

// src/utils/groupMessages.js
var groupedMessages = {};
var GroupMessages = {
  GROUP: {
    PropertyReferenceWarnings: "Property Reference Errors",
    PropertyValueCollisions: "Property Value Collisions",
    TemplateDeprecationWarnings: "Template Deprecation Warnings",
    RegisterTemplateDeprecationWarnings: "Register Template Deprecation Warnings",
    SassMapFormatDeprecationWarnings: "Sass Map Format Deprecation Warnings",
    MissingRegisterTransformErrors: "Missing Register Transform Errors",
    PropertyNameCollisionWarnings: "Property Name Collision Warnings",
    FilteredOutputReferences: "Filtered Output Reference Warnings"
  },
  flush(messageGroup) {
    const messages = GroupMessages.fetchMessages(messageGroup);
    GroupMessages.clear(messageGroup);
    return messages;
  },
  add(messageGroup, message) {
    if (messageGroup) {
      if (!groupedMessages[messageGroup])
        groupedMessages[messageGroup] = [];
      if (!groupedMessages[messageGroup].includes(message))
        groupedMessages[messageGroup].push(message);
    }
  },
  count(messageGroup) {
    return groupedMessages[messageGroup] ? groupedMessages[messageGroup].length : 0;
  },
  fetchMessages(messageGroup) {
    return messageGroup && groupedMessages[messageGroup] || [];
  },
  clear(messageGroup) {
    messageGroup && groupedMessages[messageGroup] && delete groupedMessages[messageGroup];
  }
};
var groupMessages_default = GroupMessages;
var ChangeCase = _ChangeCase;
function reduce(obj, f, accumulator_init) {
  return Object.keys(obj || {}).reduce((accumulator, key) => {
    const value = obj[key];
    return f(accumulator, value, key, obj);
  }, accumulator_init);
}
function clone(object) {
  return Object.assign(new object.constructor(), object);
}
function cloneDeep(obj) {
  if (obj === null || obj === void 0 || typeof obj !== "object")
    return obj;
  if (Array.isArray(obj)) {
    return obj.reduce((arr, item, i) => {
      arr[i] = cloneDeep(item);
      return arr;
    }, []);
  }
  if (obj instanceof Object) {
    return Object.keys(obj || {}).reduce((cpObj, key) => {
      cpObj[key] = cloneDeep(obj[key]);
      return cpObj;
    }, {});
  }
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function");
}
function isString(obj) {
  return typeof obj === "string" || obj instanceof String;
}
function isArray(obj) {
  return Array.isArray(obj);
}
function isEmpty(obj) {
  return [Object, Array].includes((obj || {}).constructor) && !Object.entries(obj || {}).length;
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  if (Object.getPrototypeOf(value) === null)
    return true;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null)
    proto = Object.getPrototypeOf(proto);
  return Object.getPrototypeOf(value) === proto;
}
function filter(arr, filter2) {
  if (typeof filter2 !== "function")
    throw new Error("filter is not a function");
  if (typeof arr === "undefined")
    return [];
  return arr.filter(filter2);
}
function assign(...props) {
  return Object.assign({}, ...props);
}
function pull(arr, ...removeList) {
  const removeSet = new Set(removeList);
  for (let i = arr.length - 1; i >= 0; i--) {
    if (removeSet.has(arr[i]))
      arr.splice(i, 1);
  }
}
function unique(arr) {
  return [...new Set(arr)];
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.substr(1) : "";
}
function matchFn(inputObj, testObj) {
  if (isObject(testObj))
    return Object.keys(testObj).every((key) => matchFn(inputObj[key], testObj[key]));
  else
    return inputObj === testObj;
}
function matches(matchObj) {
  const cloneObj = cloneDeep(matchObj);
  const matchesFn = (inputObj) => matchFn(inputObj, cloneObj);
  return matchesFn;
}
var DEFAULT_OPTIONS = {
  transform: ChangeCase.camelCaseTransformMerge
};
function changeDefaultCaseTransform(caseFunction, default_options) {
  return (caseToChange, options2) => caseFunction(caseToChange, Object.assign({}, DEFAULT_OPTIONS, default_options, options2));
}
var camelCase = changeDefaultCaseTransform(ChangeCase.camelCase);
var snakeCase = ChangeCase.snakeCase;
var kebabCase = ChangeCase.paramCase;
function convertToBase64(filePath) {
  if (typeof filePath !== "string")
    throw new Error("filePath name must be a string");
  const body = fs2.readFileSync(filePath, "binary");
  return Buffer.from(body, "binary").toString("base64");
}
var convertToBase64_default = convertToBase64;

// src/common/transforms.js
var UNICODE_PATTERN = /&#x([^;]+);/g;
function isColor(token) {
  return token.attributes.category === "color";
}
function isSize(token) {
  return token.attributes.category === "size";
}
function isFontSize(token) {
  return token.attributes.category === "size" && (token.attributes.type === "font" || token.attributes.type === "icon");
}
function isNotFontSize(token) {
  return token.attributes.category === "size" && token.attributes.type !== "font" && token.attributes.type !== "icon";
}
function isAsset(token) {
  return token.attributes.category === "asset";
}
function isContent(token) {
  return token.attributes.category === "content";
}
function wrapValueWith(character, token) {
  return `${character}${token.value}${character}`;
}
function wrapValueWithDoubleQuote(token) {
  return wrapValueWith('"', token);
}
function throwSizeError(name, value, unitType) {
  throw new Error(`Invalid Number: '${name}: ${value}' is not a valid number, cannot transform to '${unitType}' 
`);
}
function getBasePxFontSize(options2) {
  return options2 && options2.basePxFontSize || 16;
}
var transforms_default = {
  "attribute/cti": {
    type: "attribute",
    transformer(token) {
      const attrNames = ["category", "type", "item", "subitem", "state"];
      const originalAttrs = token.attributes || {};
      const generatedAttrs = {};
      for (let i = 0; i < token.path.length && i < attrNames.length; i++)
        generatedAttrs[attrNames[i]] = token.path[i];
      return Object.assign(generatedAttrs, originalAttrs);
    }
  },
  "attribute/color": {
    type: "attribute",
    matcher: isColor,
    transformer(token) {
      const color = Color(token.value);
      return {
        hex: color.toHex(),
        rgb: color.toRgb(),
        hsl: color.toHsl(),
        hsv: color.toHsv()
      };
    }
  },
  "name/human": {
    type: "name",
    transformer(token) {
      return [
        token.attributes.item,
        token.attributes.subitem
      ].join(" ");
    }
  },
  "name/cti/camel": {
    type: "name",
    transformer(token, options2) {
      return camelCase([options2.prefix].concat(token.path).join(" "));
    }
  },
  "name/ti/camel": {
    type: "name",
    transformer(token, options2) {
      return camelCase([options2.prefix].concat(token.path.slice(1, token.path.length)).join(" "));
    }
  },
  "name/cti/kebab": {
    type: "name",
    transformer(token, options2) {
      return kebabCase([options2.prefix].concat(token.path).join(" "));
    }
  },
  "name/cti/snake": {
    type: "name",
    transformer(token, options2) {
      return snakeCase([options2.prefix].concat(token.path).join(" "));
    }
  },
  "name/cti/constant": {
    type: "name",
    transformer(token, options2) {
      return snakeCase([options2.prefix].concat(token.path).join(" ")).toUpperCase();
    }
  },
  "name/ti/constant": {
    type: "name",
    transformer(token, options2) {
      const path5 = token.path.slice(1);
      return snakeCase([options2.prefix].concat(path5).join(" ")).toUpperCase();
    }
  },
  "name/cti/pascal": {
    type: "name",
    transformer(token, options2) {
      return upperFirst(camelCase([options2.prefix].concat(token.path).join(" ")));
    }
  },
  "color/rgb": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      return Color(token.value).toRgbString();
    }
  },
  "color/hsl": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      return Color(token.value).toHslString();
    }
  },
  "color/hsl-4": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const color = Color(token.value);
      const o = color.toHsl();
      const vals = `${Math.round(o.h)} ${Math.round(o.s * 100)}% ${Math.round(o.l * 100)}%`;
      if (color.getAlpha() === 1)
        return `hsl(${vals})`;
      else
        return `hsl(${vals} / ${o.a})`;
    }
  },
  "color/hex": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      return Color(token.value).toHexString();
    }
  },
  "color/hex8": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      return Color(token.value).toHex8String();
    }
  },
  "color/hex8android": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const str = Color(token.value).toHex8();
      return `#${str.slice(6)}${str.slice(0, 6)}`;
    }
  },
  "color/composeColor": {
    type: "value",
    matcher: isColor,
    transformer(prop) {
      const str = Color(prop.value).toHex8();
      return `Color(0x${str.slice(6)}${str.slice(0, 6)})`;
    }
  },
  "color/UIColor": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const rgb = Color(token.value).toRgb();
      return `[UIColor colorWithRed:${(rgb.r / 255).toFixed(3)}f green:${(rgb.g / 255).toFixed(3)}f blue:${(rgb.b / 255).toFixed(3)}f alpha:${rgb.a.toFixed(3)}f]`;
    }
  },
  "color/UIColorSwift": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const { r, g, b, a } = Color(token.value).toRgb();
      const rFixed = (r / 255).toFixed(3);
      const gFixed = (g / 255).toFixed(3);
      const bFixed = (b / 255).toFixed(3);
      return `UIColor(red: ${rFixed}, green: ${gFixed}, blue: ${bFixed}, alpha: ${a})`;
    }
  },
  "color/ColorSwiftUI": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const { r, g, b, a } = Color(token.value).toRgb();
      const rFixed = (r / 255).toFixed(3);
      const gFixed = (g / 255).toFixed(3);
      const bFixed = (b / 255).toFixed(3);
      return `Color(red: ${rFixed}, green: ${gFixed}, blue: ${bFixed}, opacity: ${a})`;
    }
  },
  "color/css": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const color = Color(token.value);
      if (color.getAlpha() === 1)
        return color.toHexString();
      else
        return color.toRgbString();
    }
  },
  "color/sketch": {
    type: "value",
    matcher: (token) => token.attributes.category === "color",
    transformer(token) {
      const color = Color(token.original.value).toRgb();
      return {
        red: (color.r / 255).toFixed(5),
        green: (color.g / 255).toFixed(5),
        blue: (color.b / 255).toFixed(5),
        alpha: color.a
      };
    }
  },
  "size/sp": {
    type: "value",
    matcher: isFontSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "sp");
      return `${val.toFixed(2)}sp`;
    }
  },
  "size/dp": {
    type: "value",
    matcher: isNotFontSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "dp");
      return `${val.toFixed(2)}dp`;
    }
  },
  "size/object": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "object");
      return {
        original: token.value,
        number: val,
        decimal: val / 100,
        scale: val * getBasePxFontSize(options2)
      };
    }
  },
  "size/remToSp": {
    type: "value",
    matcher: isFontSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "sp");
      return `${(val * baseFont).toFixed(2)}sp`;
    }
  },
  "size/remToDp": {
    type: "value",
    matcher: isNotFontSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "dp");
      return `${(val * baseFont).toFixed(2)}dp`;
    }
  },
  "size/px": {
    type: "value",
    matcher: isSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "px");
      return `${val}px`;
    }
  },
  "size/rem": {
    type: "value",
    matcher: isSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "rem");
      return `${val}rem`;
    }
  },
  "size/remToPt": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "pt");
      return `${(val * baseFont).toFixed(2)}f`;
    }
  },
  "size/compose/remToSp": {
    type: "value",
    matcher: isFontSize,
    transformer(prop, options2) {
      const val = parseFloat(prop.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(prop.name, prop.value, "sp");
      return `${(val * baseFont).toFixed(2)}.sp`;
    }
  },
  "size/compose/remToDp": {
    type: "value",
    matcher: isNotFontSize,
    transformer(prop, options2) {
      const val = parseFloat(prop.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(prop.name, prop.value, "dp");
      return `${(val * baseFont).toFixed(2)}.dp`;
    }
  },
  "size/compose/em": {
    type: "value",
    matcher: isFontSize,
    transformer(prop) {
      const val = parseFloat(prop.value);
      if (isNaN(val))
        throwSizeError(prop.name, prop.value, "em");
      return `${val}.em`;
    }
  },
  "size/swift/remToCGFloat": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "CGFloat");
      return `CGFloat(${(val * baseFont).toFixed(2)})`;
    }
  },
  "size/remToPx": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "px");
      return `${(val * baseFont).toFixed(0)}px`;
    }
  },
  "size/pxToRem": {
    type: "value",
    matcher: isSize,
    transformer: (token, options2) => {
      const baseFont = getBasePxFontSize(options2);
      const floatVal = parseFloat(token.value);
      if (isNaN(floatVal))
        throwSizeError(token.name, token.value, "rem");
      if (floatVal === 0)
        return "0";
      return `${floatVal / baseFont}rem`;
    }
  },
  "content/icon": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "content" && token.attributes.type === "icon";
    },
    transformer(token) {
      return token.value.replace(UNICODE_PATTERN, (match, variable) => {
        return `'\\${variable}'`;
      });
    }
  },
  "content/quote": {
    type: "value",
    matcher: isContent,
    transformer(token) {
      return wrapValueWith("'", token);
    }
  },
  "content/objC/literal": {
    type: "value",
    matcher: isContent,
    transformer(token) {
      return `@${wrapValueWithDoubleQuote(token)}`;
    }
  },
  "content/swift/literal": {
    type: "value",
    matcher: isContent,
    transformer: wrapValueWithDoubleQuote
  },
  "font/objC/literal": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "font";
    },
    transformer(token) {
      return `@${wrapValueWithDoubleQuote(token)}`;
    }
  },
  "font/swift/literal": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "font";
    },
    transformer: wrapValueWithDoubleQuote
  },
  "time/seconds": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "time";
    },
    transformer(token) {
      return `${(parseFloat(token.value) / 1e3).toFixed(2)}s`;
    }
  },
  "asset/base64": {
    type: "value",
    matcher: isAsset,
    transformer(token) {
      return convertToBase64_default(token.value);
    }
  },
  "asset/path": {
    type: "value",
    matcher: isAsset,
    transformer(token) {
      return path4.join(process.cwd(), token.value);
    }
  },
  "asset/objC/literal": {
    type: "value",
    matcher: isAsset,
    transformer(token) {
      return `@${wrapValueWithDoubleQuote(token)}`;
    }
  },
  "asset/swift/literal": {
    type: "value",
    matcher: isAsset,
    transformer: wrapValueWithDoubleQuote
  },
  "color/hex8flutter": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const str = Color(token.value).toHex8().toUpperCase();
      return `Color(0x${str.slice(6)}${str.slice(0, 6)})`;
    }
  },
  "content/flutter/literal": {
    type: "value",
    matcher: isContent,
    transformer: wrapValueWithDoubleQuote
  },
  "asset/flutter/literal": {
    type: "value",
    matcher: isAsset,
    transformer: wrapValueWithDoubleQuote
  },
  "font/flutter/literal": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "font";
    },
    transformer: wrapValueWithDoubleQuote
  },
  "size/flutter/remToDouble": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const baseFont = getBasePxFontSize(options2);
      return (parseFloat(token.value, 10) * baseFont).toFixed(2);
    }
  }
};

// src/common/transformGroups.js
var transformGroups_default = {
  "web": [
    "attribute/cti",
    "name/cti/kebab",
    "size/px",
    "color/css"
  ],
  "js": [
    "attribute/cti",
    "name/cti/pascal",
    "size/rem",
    "color/hex"
  ],
  "scss": [
    "attribute/cti",
    "name/cti/kebab",
    "time/seconds",
    "content/icon",
    "size/rem",
    "color/css"
  ],
  "css": [
    "attribute/cti",
    "name/cti/kebab",
    "time/seconds",
    "content/icon",
    "size/rem",
    "color/css"
  ],
  "less": [
    "attribute/cti",
    "name/cti/kebab",
    "time/seconds",
    "content/icon",
    "size/rem",
    "color/hex"
  ],
  "html": [
    "attribute/cti",
    "attribute/color",
    "name/human"
  ],
  "android": [
    "attribute/cti",
    "name/cti/snake",
    "color/hex8android",
    "size/remToSp",
    "size/remToDp"
  ],
  "compose": [
    "attribute/cti",
    "name/cti/camel",
    "color/composeColor",
    "size/compose/em",
    "size/compose/remToSp",
    "size/compose/remToDp"
  ],
  "ios": [
    "attribute/cti",
    "name/cti/pascal",
    "color/UIColor",
    "content/objC/literal",
    "asset/objC/literal",
    "size/remToPt",
    "font/objC/literal"
  ],
  "ios-swift": [
    "attribute/cti",
    "name/cti/camel",
    "color/UIColorSwift",
    "content/swift/literal",
    "asset/swift/literal",
    "size/swift/remToCGFloat",
    "font/swift/literal"
  ],
  "ios-swift-separate": [
    "attribute/cti",
    "name/ti/camel",
    "color/UIColorSwift",
    "content/swift/literal",
    "asset/swift/literal",
    "size/swift/remToCGFloat",
    "font/swift/literal"
  ],
  "assets": [
    "attribute/cti"
  ],
  "flutter": [
    "attribute/cti",
    "name/cti/camel",
    "color/hex8flutter",
    "size/flutter/remToDouble",
    "content/flutter/literal",
    "asset/flutter/literal",
    "font/flutter/literal"
  ],
  "flutter-separate": [
    "attribute/cti",
    "name/ti/camel",
    "color/hex8flutter",
    "size/flutter/remToDouble",
    "content/flutter/literal",
    "asset/flutter/literal",
    "font/flutter/literal"
  ],
  "react-native": [
    "name/cti/camel",
    "color/css",
    "size/object"
  ]
};
var _dir = resolve(dirname(fileURLToPath(import.meta.url)), "../templates");
var resolveTemplate = (_path) => join(_dir, _path);

// src/common/formatHelpers/index.js
var formatHelpers_exports = {};
__export(formatHelpers_exports, {
  createPropertyFormatter: () => createPropertyFormatter_default,
  fileHeader: () => fileHeader_default,
  formattedVariables: () => formattedVariables_default,
  getTypeScriptType: () => getTypeScriptType_default,
  iconsWithPrefix: () => iconsWithPrefix_default,
  minifyDictionary: () => minifyDictionary_default,
  setSwiftFileProperties: () => setSwiftFileProperties_default,
  sortByName: () => sortByName_default,
  sortByReference: () => sortByReference_default
});

// src/common/formatHelpers/createPropertyFormatter.js
var defaultFormatting = {
  prefix: "",
  commentStyle: "long",
  indentation: "",
  separator: " =",
  suffix: ";"
};
function createPropertyFormatter({
  outputReferences = false,
  outputReferenceFallbacks = false,
  dictionary,
  format,
  formatting = {},
  themeable = false
}) {
  let { prefix, commentStyle, indentation, separator, suffix } = Object.assign({}, defaultFormatting, formatting);
  switch (format) {
    case "css":
      prefix = "--";
      indentation = "  ";
      separator = ":";
      break;
    case "sass":
      prefix = "$";
      commentStyle = "short";
      indentation = "";
      separator = ":";
      break;
    case "less":
      prefix = "@";
      commentStyle = "short";
      indentation = "";
      separator = ":";
      break;
    case "stylus":
      prefix = "$";
      commentStyle = "short";
      indentation = "";
      separator = "=";
      break;
  }
  return function(prop) {
    let to_ret_prop = `${indentation}${prefix}${prop.name}${separator} `;
    let value = prop.value;
    if (outputReferences && dictionary.usesReference(prop.original.value)) {
      if (typeof value === "string") {
        const refs = dictionary.getReferences(prop.original.value);
        refs.forEach((ref) => {
          if (ref.value && ref.name) {
            value = value.replace(ref.value, () => {
              if (format === "css") {
                if (outputReferenceFallbacks)
                  return `var(${prefix}${ref.name}, ${ref.value})`;
                else
                  return `var(${prefix}${ref.name})`;
              } else {
                return `${prefix}${ref.name}`;
              }
            });
          }
        });
      }
    }
    to_ret_prop += prop.attributes.category === "asset" ? `"${value}"` : value;
    const themeable_prop = typeof prop.themeable === "boolean" ? prop.themeable : themeable;
    if (format === "sass" && themeable_prop)
      to_ret_prop += " !default";
    to_ret_prop += suffix;
    if (prop.comment && commentStyle !== "none") {
      if (commentStyle === "short")
        to_ret_prop = to_ret_prop.concat(` // ${prop.comment}`);
      else
        to_ret_prop = to_ret_prop.concat(` /* ${prop.comment} */`);
    }
    return to_ret_prop;
  };
}
var createPropertyFormatter_default = createPropertyFormatter;

// src/common/formatHelpers/fileHeader.js
var defaultFileHeader = (arr) => arr;
var lineSeparator = "\n";
var defaultFormatting2 = {
  lineSeparator,
  prefix: " * ",
  header: `/**${lineSeparator}`,
  footer: `${lineSeparator} */${lineSeparator}${lineSeparator}`
};
function fileHeader({ file = {}, commentStyle, formatting = {} }) {
  let showFileHeader = true;
  if (file.options && typeof file.options.showFileHeader !== "undefined")
    showFileHeader = file.options.showFileHeader;
  if (!showFileHeader)
    return "";
  let fn = defaultFileHeader;
  if (file.options && typeof file.options.fileHeader === "function")
    fn = file.options.fileHeader;
  const defaultHeader = [
    "Do not edit directly",
    `Generated on ${new Date().toUTCString()}`
  ];
  let { prefix, lineSeparator: lineSeparator2, header, footer } = Object.assign({}, defaultFormatting2, formatting);
  if (commentStyle === "short") {
    prefix = "// ";
    header = `${lineSeparator2}`;
    footer = `${lineSeparator2}${lineSeparator2}`;
  } else if (commentStyle === "xml") {
    prefix = "  ";
    header = `<!--${lineSeparator2}`;
    footer = `${lineSeparator2}-->`;
  }
  return `${header}${fn(defaultHeader).map((line) => `${prefix}${line}`).join(lineSeparator2)}${footer}`;
}
var fileHeader_default = fileHeader;

// src/common/formatHelpers/sortByReference.js
function sortByReference(dictionary) {
  function sorter(a, b) {
    const aComesFirst = -1;
    const bComesFirst = 1;
    if (typeof a === "undefined")
      return aComesFirst;
    else if (typeof b === "undefined")
      return bComesFirst;
    if (a.original && dictionary.usesReference(a.original.value)) {
      if (b.original && dictionary.usesReference(b.original.value)) {
        const aRefs = dictionary.getReferences(a.original.value);
        const bRefs = dictionary.getReferences(b.original.value);
        aRefs.forEach((aRef) => {
          if (aRef.name === b.name)
            return bComesFirst;
        });
        bRefs.forEach((bRef) => {
          if (bRef.name === a.name)
            return aComesFirst;
        });
        return sorter(aRefs[0], bRefs[0]);
      } else {
        return bComesFirst;
      }
    } else {
      return aComesFirst;
    }
  }
  return sorter;
}
var sortByReference_default = sortByReference;

// src/common/formatHelpers/formattedVariables.js
var defaultFormatting3 = {
  lineSeparator: "\n"
};
function formattedVariables({ format, dictionary, outputReferences = false, formatting = {}, themeable = false }) {
  let { allTokens } = dictionary;
  const { lineSeparator: lineSeparator2 } = Object.assign({}, defaultFormatting3, formatting);
  if (outputReferences) {
    allTokens = [...allTokens].sort(sortByReference_default(dictionary));
  }
  return allTokens.map(createPropertyFormatter_default({ outputReferences, dictionary, format, formatting, themeable })).filter((strVal) => {
    return !!strVal;
  }).join(lineSeparator2);
}
var formattedVariables_default = formattedVariables;

// src/common/formatHelpers/getTypeScriptType.js
function getTypeScriptType(value) {
  if (Array.isArray(value))
    return getArrayType(value);
  if (typeof value === "object")
    return getObjectType(value);
  if (["string", "number", "boolean"].includes(typeof value))
    return typeof value;
  return "any";
}
function getObjectType(value) {
  const entries = Object.entries(value);
  return `{ ${entries.map(([key, property], index) => {
    const isLast = entries.length === index + 1;
    return `${key}: ${getTypeScriptType(property)}${!isLast ? ", " : ""}`;
  }).join("")} }`;
}
function getArrayType(passedArray) {
  if (passedArray.length > 0) {
    const firstValueType = getTypeScriptType(passedArray[0]);
    if (passedArray.every((v) => getTypeScriptType(v) === firstValueType)) {
      return `${firstValueType}[]`;
    } else {
      return `(${unique(passedArray.map((item, index) => {
        const isLast = passedArray.length === index + 1;
        return `${getTypeScriptType(item)}${!isLast ? " | " : ""}`;
      })).join("")})[]`;
    }
  }
  return "any[]";
}
var getTypeScriptType_default = getTypeScriptType;

// src/common/formatHelpers/iconsWithPrefix.js
function iconsWithPrefix(prefix, allTokens, options2) {
  return allTokens.filter((token) => {
    return token.attributes.category === "content" && token.attributes.type === "icon";
  }).map((token) => {
    const varName = `${prefix + token.name}: ${token.value};`;
    const className = `.${options2.prefix}-icon.${token.attributes.item}:before `;
    const declaration = `{ content: ${prefix}${token.name}; }`;
    return `${varName}
${className}${declaration}`;
  }).join("\n");
}
var iconsWithPrefix_default = iconsWithPrefix;

// src/common/formatHelpers/sortByName.js
function sortByName(a, b) {
  if (b.name > a.name)
    return -1;
  else
    return 1;
}
var sortByName_default = sortByName;

// src/common/formatHelpers/minifyDictionary.js
function minifyDictionary(obj) {
  if (typeof obj !== "object" || Array.isArray(obj))
    return obj;
  const toRet = {};
  if (obj.hasOwnProperty("value")) {
    return obj.value;
  } else {
    for (const name in obj) {
      if (obj.hasOwnProperty(name))
        toRet[name] = minifyDictionary(obj[name]);
    }
  }
  return toRet;
}
var minifyDictionary_default = minifyDictionary;

// src/common/formatHelpers/setSwiftFileProperties.js
function setSwiftFileProperties(options2, objectType, transformGroup) {
  if (typeof options2.objectType === "undefined") {
    if (typeof objectType === "undefined")
      options2.objectType = "class";
    else
      options2.objectType = objectType;
  }
  if (typeof options2.import === "undefined") {
    if (typeof transformGroup === "undefined") {
      options2.import = ["UIKit"];
    } else if (["ios-swift", "ios-swift-separate"].includes(transformGroup)) {
      options2.import = ["UIKit"];
    } else {
      options2.import = ["SwiftUI"];
    }
  } else if (typeof options2.import === "string") {
    options2.import = [options2.import];
  }
  if (typeof options2.accessControl === "undefined") {
    options2.accessControl = "public ";
  } else {
    if (options2.accessControl !== "")
      options2.accessControl = `${options2.accessControl} `;
  }
  return options2;
}
var setSwiftFileProperties_default = setSwiftFileProperties;

// src/common/formats.js
var SASS_MAP_FORMAT_DEPRECATION_WARNINGS = groupMessages_default.GROUP.SassMapFormatDeprecationWarnings;
var formats = {
  "css/variables": function({ dictionary, options: options2 = {}, file }) {
    const selector = options2.selector ? options2.selector : ":root";
    const { outputReferences } = options2;
    return `${fileHeader_default({ file })}${selector} {
${formattedVariables_default({ format: "css", dictionary, outputReferences })}
}
`;
  },
  "scss/map-flat": function({ dictionary, options: options2, file }) {
    const template = _template(fs2.readFileSync(resolveTemplate("scss/map-flat.template")));
    const { allTokens } = dictionary;
    return template({ allTokens, file, options: options2, fileHeader: fileHeader_default });
  },
  "sass/map-flat": function({ dictionary, options: options2, file }) {
    groupMessages_default.add(SASS_MAP_FORMAT_DEPRECATION_WARNINGS, "sass/map-flat");
    return formats["scss/map-flat"]({ dictionary, options: options2, file });
  },
  "scss/map-deep": function({ dictionary, options: options2, file }) {
    const mapTemplate = _template(fs2.readFileSync(resolveTemplate("scss/map-deep.template")));
    const { outputReferences, themeable = true } = options2;
    return `
${fileHeader_default({ file, commentStyle: "long" })}${formattedVariables_default({ format: "sass", dictionary, outputReferences, themeable })}
${mapTemplate({ dictionary, file })}`;
  },
  "sass/map-deep": function({ dictionary, options: options2, file }) {
    groupMessages_default.add(SASS_MAP_FORMAT_DEPRECATION_WARNINGS, "sass/map-deep");
    return formats["scss/map-deep"]({ dictionary, options: options2, file });
  },
  "scss/variables": function({ dictionary, options: options2, file }) {
    const { outputReferences, themeable = false } = options2;
    return fileHeader_default({ file, commentStyle: "short" }) + formattedVariables_default({ format: "sass", dictionary, outputReferences, themeable });
  },
  "scss/icons": function({ dictionary, options: options2, file }) {
    return fileHeader_default({ file, commentStyle: "short" }) + iconsWithPrefix_default("$", dictionary.allTokens, options2);
  },
  "less/variables": function({ dictionary, options: options2, file }) {
    const { outputReferences } = options2;
    return fileHeader_default({ file, commentStyle: "short" }) + formattedVariables_default({ format: "less", dictionary, outputReferences });
  },
  "less/icons": function({ dictionary, options: options2, file }) {
    return fileHeader_default({ file, commentStyle: "short" }) + iconsWithPrefix_default("@", dictionary.allTokens, options2);
  },
  "stylus/variables": function({ dictionary, options: options2, file }) {
    const { outputReferences } = options2;
    return fileHeader_default({ file, commentStyle: "short" }) + formattedVariables_default({ format: "stylus", dictionary, outputReferences });
  },
  "javascript/module": function({ dictionary, file }) {
    return `${fileHeader_default({ file })}export default ${JSON.stringify(dictionary.tokens, null, 2)};`;
  },
  "javascript/module-flat": function({ dictionary, file }) {
    return `${fileHeader_default({ file })}export default ${formats["json/flat"]({ dictionary })};`;
  },
  "javascript/object": function({ dictionary, file }) {
    return `${fileHeader_default({ file })}var ${file.name || "_styleDictionary"} = ${JSON.stringify(dictionary.tokens, null, 2)};`;
  },
  "javascript/umd": function({ dictionary, file }) {
    const name = file.name || "_styleDictionary";
    return `${fileHeader_default({ file })}(function(root, factory) {
  if (typeof module === "object" && module.exports) {
    export default factory();
  } else if (typeof exports === "object") {
    exports["${name}"] = factory();
  } else if (typeof define === "function" && define.amd) {
    define([], factory);
  } else {
    root["${name}"] = factory();
  }
}(this, function() {
  return ${JSON.stringify(dictionary.tokens, null, 2)};
}))
`;
  },
  "javascript/es6": function({ dictionary, file }) {
    return fileHeader_default({ file }) + dictionary.allTokens.map((token) => {
      let to_ret = `export const ${token.name} = ${JSON.stringify(token.value)};`;
      if (token.comment)
        to_ret = to_ret.concat(` // ${token.comment}`);
      return to_ret;
    }).join("\n");
  },
  "typescript/es6-declarations": function({ dictionary, file }) {
    return fileHeader_default({ file }) + dictionary.allProperties.map((prop) => {
      let to_ret_prop = `export const ${prop.name} : ${getTypeScriptType_default(prop.value)};`;
      if (prop.comment)
        to_ret_prop = to_ret_prop.concat(` // ${prop.comment}`);
      return to_ret_prop;
    }).join("\n");
  },
  "typescript/module-declarations": function({ dictionary, file, options: options2 }) {
    const { moduleName = "tokens" } = options2;
    function treeWalker(obj) {
      let type = /* @__PURE__ */ Object.create(null);
      const has = Object.prototype.hasOwnProperty.bind(obj);
      if (has("value")) {
        type = "DesignToken";
      } else {
        for (const k in obj) {
          if (has(k)) {
            switch (typeof obj[k]) {
              case "object":
                type[k] = treeWalker(obj[k]);
            }
          }
        }
      }
      return type;
    }
    const _dir2 = resolve(dirname(fileURLToPath(import.meta.url)), "../templates");
    const designTokenInterface = fs2.readFileSync(
      resolve(_dir2, "../../types/DesignToken.d.ts"),
      { encoding: "UTF-8" }
    );
    const lines = designTokenInterface.split("\n");
    const firstLine = lines.indexOf("//start") + 1;
    const lastLine = lines.indexOf("//end");
    const output = `${fileHeader_default({ file })}export default ${moduleName};

declare ${lines.slice(firstLine, lastLine).join("\n")}

declare const ${moduleName}: ${JSON.stringify(treeWalker(dictionary.tokens), null, 2)}`;
    return output.replace(/"DesignToken"/g, "DesignToken");
  },
  "android/resources": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("android/resources.template"))
    );
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  "android/colors": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("android/colors.template"))
    );
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  "android/dimens": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("android/dimens.template"))
    );
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  "android/fontDimens": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("android/fontDimens.template"))
    );
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  "android/integers": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("android/integers.template"))
    );
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  "android/strings": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("android/strings.template"))
    );
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  "compose/object": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("compose/object.kt.template"))
    );
    let allProperties;
    const { outputReferences } = options2;
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary,
      formatting: {
        suffix: "",
        commentStyle: "none"
      }
    });
    if (outputReferences)
      allProperties = [...dictionary.allProperties].sort(sortByReference_default(dictionary));
    else
      allProperties = [...dictionary.allProperties].sort(sortByName_default);
    return template({ allProperties, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  },
  "ios/macros": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/macros.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios/plist": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/plist.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios/singleton.m": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/singleton.m.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios/singleton.h": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/singleton.h.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios/static.h": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/static.h.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios/static.m": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/static.m.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios/colors.h": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/colors.h.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios/colors.m": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/colors.m.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios/strings.h": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/strings.h.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios/strings.m": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios/strings.m.template"))
    );
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  "ios-swift/class.swift": function({ dictionary, options: options2, file, platform }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios-swift/any.swift.template"))
    );
    let allTokens;
    const { outputReferences } = options2;
    options2 = setSwiftFileProperties_default(options2, "class", platform.transformGroup);
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary,
      formatting: {
        suffix: ""
      }
    });
    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference_default(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName_default);
    return template({ allTokens, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  },
  "ios-swift/enum.swift": function({ dictionary, options: options2, file, platform }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios-swift/any.swift.template"))
    );
    let allTokens;
    const { outputReferences } = options2;
    options2 = setSwiftFileProperties_default(options2, "enum", platform.transformGroup);
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary,
      formatting: {
        suffix: ""
      }
    });
    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference_default(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName_default);
    return template({ allTokens, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  },
  "ios-swift/any.swift": function({ dictionary, options: options2, file, platform }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("ios-swift/any.swift.template"))
    );
    let allTokens;
    const { outputReferences } = options2;
    options2 = setSwiftFileProperties_default(options2, options2.objectType, platform.transformGroup);
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary,
      formatting: {
        suffix: ""
      }
    });
    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference_default(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName_default);
    return template({ allTokens, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  },
  "css/fonts.css": _template(
    fs2.readFileSync(resolveTemplate("css/fonts.css.template"))
  ),
  "json": function({ dictionary }) {
    return JSON.stringify(dictionary.tokens, null, 2);
  },
  "json/asset": function({ dictionary }) {
    return JSON.stringify({ asset: dictionary.tokens.asset }, null, 2);
  },
  "json/nested": function({ dictionary }) {
    return JSON.stringify(minifyDictionary_default(dictionary.tokens), null, 2);
  },
  "json/flat": function({ dictionary }) {
    return `{
${dictionary.allTokens.map((token) => {
      return `  "${token.name}": ${JSON.stringify(token.value)}`;
    }).join(",\n")}
}`;
  },
  "sketch/palette": function({ dictionary }) {
    const to_ret = {
      compatibleVersion: "1.0",
      pluginVersion: "1.1"
    };
    to_ret.colors = dictionary.allTokens.filter((token) => {
      return token.attributes.category === "color" && token.attributes.type === "base";
    }).map((token) => {
      return token.value;
    });
    return JSON.stringify(to_ret, null, 2);
  },
  "sketch/palette/v2": function({ dictionary }) {
    const to_ret = {
      compatibleVersion: "2.0",
      pluginVersion: "2.2",
      colors: dictionary.allTokens.map((token) => {
        return Object.assign({
          name: token.name
        }, token.value);
      })
    };
    return JSON.stringify(to_ret, null, 2);
  },
  "flutter/class.dart": function({ dictionary, options: options2, file }) {
    const template = _template(
      fs2.readFileSync(resolveTemplate("flutter/class.dart.template"))
    );
    let allTokens;
    const { outputReferences } = options2;
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary
    });
    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference_default(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName_default);
    return template({ allTokens, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  }
};
formats["json/nested"].nested = true;
formats["javascript/module"].nested = true;
formats["javascript/object"].nested = true;
var formats_default = formats;
var _logger;
var logger = () => {
  if (!_logger)
    _logger = consola.create().withDefaults().withScope("style-dictionary");
  return _logger;
};
var logger_default = logger;

// src/common/actions.js
var actions_default = {
  "android/copyImages": {
    do(dictionary, config) {
      const imagesDir = `${config.buildPath}android/main/res/drawable-`;
      dictionary.allTokens.forEach((token) => {
        if (token.attributes.category === "asset" && token.attributes.type === "image") {
          const name = token.path.slice(2, 4).join("_");
          fs3.copySync(token.value, `${imagesDir + token.attributes.state}/${name}.png`);
        }
      });
    },
    undo(dictionary, config) {
      const imagesDir = `${config.buildPath}android/main/res/drawable-`;
      dictionary.allTokens.forEach((token) => {
        if (token.attributes.category === "asset" && token.attributes.type === "image") {
          const name = token.path.slice(2, 4).join("_");
          fs3.removeSync(`${imagesDir + token.attributes.state}/${name}.png`);
        }
      });
    }
  },
  "copy_assets": {
    do(dictionary, config) {
      logger_default().log(`Copying assets directory to ${config.buildPath}assets`);
      fs3.copySync("assets", `${config.buildPath}assets`);
    },
    undo(dictionary, config) {
      logger_default().log(`Removing assets directory from ${config.buildPath}assets`);
      fs3.removeSync(`${config.buildPath}assets`);
    }
  }
};

// src/common/filters.js
var filters_default = {
  removePrivate(token) {
    return !(token && token.private);
  }
};

// src/register/transform.js
var transformTypes = ["name", "value", "attribute"];
function registerTransform(options2) {
  if (typeof options2.type !== "string")
    throw new Error("type must be a string");
  if (!transformTypes.includes(options2.type))
    throw new Error(`${options2.type} type is not one of: ${transformTypes.join(", ")}`);
  if (typeof options2.name !== "string")
    throw new Error("name must be a string");
  if (options2.matcher && typeof options2.matcher !== "function")
    throw new Error("matcher must be a function");
  if (typeof options2.transformer !== "function")
    throw new Error("transformer must be a function");
  this.transform[options2.name] = {
    type: options2.type,
    matcher: options2.matcher,
    transitive: !!options2.transitive,
    transformer: options2.transformer
  };
  return this;
}
var transform_default = registerTransform;

// src/register/transformGroup.js
function registerTransformGroup(options2) {
  if (typeof options2.name !== "string")
    throw new Error("transform name must be a string");
  if (!isArray(options2.transforms))
    throw new Error("transforms must be an array of registered value transforms");
  options2.transforms.forEach((t) => {
    if (!(t in this.transform))
      throw new Error("transforms must be an array of registered value transforms");
  });
  this.transformGroup[options2.name] = options2.transforms;
  return this;
}
var transformGroup_default = registerTransformGroup;

// src/register/format.js
function registerFormat(options2) {
  if (typeof options2.name !== "string")
    throw new Error("Can't register format; format.name must be a string");
  if (typeof options2.formatter !== "function")
    throw new Error("Can't register format; format.formatter must be a function");
  this.format[options2.name] = options2.formatter;
  return this;
}
var format_default = registerFormat;
var REGISTER_TEMPLATE_DEPRECATION_WARNINGS = groupMessages_default.GROUP.RegisterTemplateDeprecationWarnings;
function registerTemplate(options2) {
  if (typeof options2.name !== "string")
    throw new Error(`Template name must be a string: ${chalk2.red(JSON.stringify(options2.name))}`);
  if (typeof options2.template !== "string")
    throw new Error(`Template path must be a string: ${chalk2.red(JSON.stringify(options2.template))}`);
  if (!fs2.existsSync(options2.template))
    throw new Error(`Can't find template: ${chalk2.red(JSON.stringify(options2.template))}`);
  groupMessages_default.add(
    REGISTER_TEMPLATE_DEPRECATION_WARNINGS,
    `${options2.name}`
  );
  const template_string = fs2.readFileSync(options2.template);
  this.format[options2.name] = _template(template_string);
  return this;
}
var template_default = registerTemplate;

// src/register/action.js
function registerAction(options2) {
  if (typeof options2.name !== "string")
    throw new Error("name must be a string");
  if (typeof options2.do !== "function")
    throw new Error("do must be a function");
  this.action[options2.name] = {
    do: options2.do,
    undo: options2.undo
  };
  return this;
}
var action_default = registerAction;

// src/register/filter.js
function registerFilter(options2) {
  if (typeof options2.name !== "string")
    throw new Error("Can't register filter; filter.name must be a string");
  if (typeof options2.matcher !== "function")
    throw new Error("Can't register filter; filter.matcher must be a function");
  this.filter[options2.name] = options2.matcher;
  return this;
}
var filter_default = registerFilter;

// src/register/parser.js
function registerParser(options2) {
  if (!(options2.pattern instanceof RegExp))
    throw new Error("Can't register parser; parser.pattern must be a regular expression");
  if (typeof options2.parse !== "function")
    throw new Error("Can't register parser; parser.parse must be a function");
  this.parsers.push(options2);
  return this;
}
var parser_default = registerParser;

// src/register/fileHeader.js
function registerFileHeader(options2) {
  if (typeof options2.name !== "string")
    throw new Error("Can't register file header; options.name must be a string");
  if (typeof options2.fileHeader !== "function")
    throw new Error("Can't register file header; options.fileHeader must be a function");
  this.fileHeader[options2.name] = options2.fileHeader;
  return this;
}
var fileHeader_default2 = registerFileHeader;

// src/utils/references/defaults.js
var defaults = {
  opening_character: "{",
  closing_character: "}",
  separator: "."
};
var defaults_default = defaults;

// src/utils/references/createReferenceRegex.js
function createReferenceRegex(opts = {}) {
  const options2 = Object.assign({}, defaults_default, opts);
  return new RegExp(
    `\\${options2.opening_character}([^${options2.closing_character}]+)\\${options2.closing_character}`,
    "g"
  );
}
var createReferenceRegex_default = createReferenceRegex;

// src/utils/references/usesReference.js
function usesReference(value, regexOrOptions = {}) {
  const regex2 = regexOrOptions instanceof RegExp ? regexOrOptions : createReferenceRegex_default(regexOrOptions);
  if (typeof value === "string")
    return regex2.test(value);
  if (typeof value === "object") {
    let hasReference = false;
    for (const key in value) {
      if (value.hasOwnProperty(key)) {
        const element = value[key];
        const reference = usesReference(element, regexOrOptions);
        if (reference) {
          hasReference = true;
          break;
        }
      }
    }
    return hasReference;
  }
  return false;
}
var usesReference_default = usesReference;

// src/utils/references/getName.js
function getName(path5, opts = {}) {
  const options2 = Object.assign({}, defaults_default, opts);
  if (!path5 || !Array.isArray(path5))
    throw new Error("Getting name for path failed. Path must be an array");
  return path5.join(options2.separator);
}
var getName_default = getName;

// src/utils/references/getPathFromName.js
function getPathFromName(pathName, opts = {}) {
  const options2 = Object.assign({}, defaults_default, opts);
  if (typeof pathName !== "string")
    throw new Error("Getting path from name failed. Name must be a string");
  return pathName.split(options2.separator);
}
var getPathFromName_default = getPathFromName;

// src/utils/references/resolveReference.js
function resolveReference(path5, obj) {
  let i;
  let ref = obj;
  if (!Array.isArray(path5))
    return;
  for (i = 0; i < path5.length; i++) {
    if (typeof ref[path5[i]] !== "undefined") {
      ref = ref[path5[i]];
    } else {
      ref = void 0;
      break;
    }
  }
  return ref;
}
var resolveReference_default = resolveReference;

// src/utils/resolveObject.js
var PROPERTY_REFERENCE_WARNINGS = groupMessages_default.GROUP.PropertyReferenceWarnings;
var current_context = [];
var defaults2 = {
  ignoreKeys: ["original"],
  ignorePaths: []
};
var updated_object;
var regex;
var options;
function resolveObject(object, opts) {
  options = Object.assign({}, defaults2, opts);
  updated_object = cloneDeep(object);
  regex = createReferenceRegex_default(options);
  if (typeof object === "object") {
    current_context = [];
    return traverseObj(updated_object);
  } else {
    throw new TypeError("Please pass an object in");
  }
}
function traverseObj(obj) {
  let key;
  for (key in obj) {
    if (!obj.hasOwnProperty(key))
      continue;
    if (options.ignoreKeys && options.ignoreKeys.includes(key))
      continue;
    current_context.push(key);
    if (typeof obj[key] === "object") {
      traverseObj(obj[key]);
    } else {
      if (typeof obj[key] === "string" && obj[key].includes("{"))
        obj[key] = compile_value(obj[key], [getName_default(current_context)]);
    }
    current_context.pop();
  }
  return obj;
}
var foundCirc = {};
function compile_value(value, stack) {
  let to_ret = value;
  let ref;
  value.replace(regex, (match, variable) => {
    variable = variable.trim();
    const pathName = getPathFromName_default(variable, options);
    const context = getName_default(current_context, options);
    const refHasValue = pathName[pathName.length - 1] === "value";
    if (refHasValue && options.ignorePaths.includes(variable))
      return value;
    else if (!refHasValue && options.ignorePaths.includes(`${variable}.value`))
      return value;
    stack.push(variable);
    ref = resolveReference_default(pathName, updated_object);
    if (!refHasValue && ref && ref.hasOwnProperty("value"))
      ref = ref.value;
    if (typeof ref !== "undefined") {
      if (typeof ref === "string" || typeof ref === "number") {
        to_ret = value.replace(match, ref);
        if (usesReference_default(to_ret, regex)) {
          const reference = to_ret.slice(1, -1);
          if (foundCirc.hasOwnProperty(reference)) ; else if (stack.includes(reference)) {
            const stackIndexReference = stack.indexOf(reference);
            const circStack = stack.slice(stackIndexReference);
            circStack.forEach((key) => {
              foundCirc[key] = true;
            });
            circStack.push(reference);
            groupMessages_default.add(
              PROPERTY_REFERENCE_WARNINGS,
              `Circular definition cycle:  ${circStack.join(", ")}`
            );
          } else {
            to_ret = compile_value(to_ret, stack);
          }
        }
        if (typeof ref === "number" && ref.toString() === to_ret)
          to_ret = ref;
      } else {
        to_ret = ref;
      }
    } else {
      groupMessages_default.add(
        PROPERTY_REFERENCE_WARNINGS,
        `Reference doesn't exist: ${context} tries to reference ${variable}, which is not defined`
      );
      to_ret = ref;
    }
    stack.pop(variable);
    return to_ret;
  });
  return to_ret;
}
var resolveObject_default = resolveObject;

// src/transform/property.js
function transformProperty(property, options2) {
  const to_ret = clone(property);
  const transforms = options2.transforms;
  for (let i = 0; i < transforms.length; i++) {
    const transform = transforms[i];
    if (!transform.matcher || transform.matcher(to_ret)) {
      if (transform.type === "name")
        to_ret.name = transform.transformer(to_ret, options2);
      if (transform.type === "value" && !usesReference_default(property.value, options2)) {
        if (!usesReference_default(property.original.value, options2) || transform.transitive)
          to_ret.value = transform.transformer(to_ret, options2);
      }
      if (transform.type === "attribute")
        to_ret.attributes = Object.assign({}, to_ret.attributes, transform.transformer(to_ret, options2));
    }
  }
  return to_ret;
}
var property_default = transformProperty;

// src/utils/deepExtend.js
function deepExtend(objects, collision, path5) {
  if (objects == null)
    return {};
  let src;
  let copyIsArray;
  let copy;
  let name;
  let options2;
  let clone2;
  let target = objects[0] || {};
  let i = 1;
  const length = objects.length;
  path5 = path5 || [];
  if (typeof target !== "object")
    target = {};
  for (; i < length; i++) {
    options2 = objects[i];
    if (options2 != null) {
      for (name in options2) {
        if (!options2.hasOwnProperty(name))
          continue;
        if (name === "__proto__")
          continue;
        src = target[name];
        copy = options2[name];
        if (target === copy)
          continue;
        copyIsArray = isArray(copy);
        if (copy && (isPlainObject(copy) || copyIsArray)) {
          if (copyIsArray) {
            copyIsArray = false;
            clone2 = src && isArray(src) ? src : [];
          } else {
            clone2 = src && isPlainObject(src) ? src : {};
          }
          const nextPath = path5.slice(0);
          nextPath.push(name);
          target[name] = deepExtend([clone2, copy], collision, nextPath);
        } else if (copy !== void 0) {
          if (src != null && typeof collision == "function")
            collision({ target, copy: options2, path: path5, key: name });
          target[name] = copy;
        }
      }
    }
  }
  return target;
}
var deepExtend_default = deepExtend;

// src/transform/propertySetup.js
function propertySetup(property, name, path5) {
  if (!property && !isPlainObject(property))
    throw new Error("Property object must be an object");
  if (!name || !isString(name))
    throw new Error("Name must be a string");
  if (!path5 || !isArray(path5))
    throw new Error("Path must be an array");
  let to_ret = property;
  if (!property.original) {
    to_ret = deepExtend_default([{}, property]);
    const to_ret_original = deepExtend_default([{}, property]);
    delete to_ret_original.filePath;
    delete to_ret_original.isSource;
    to_ret.original = to_ret_original;
    to_ret.name = to_ret.name || name || "";
    to_ret.attributes = to_ret.attributes || {};
    to_ret.path = clone(path5);
  }
  return to_ret;
}
var propertySetup_default = propertySetup;

// src/transform/object.js
function transformObject(obj, options2, transformationContext = {}, path5, transformedObj) {
  transformedObj = transformedObj || {};
  path5 = path5 || [];
  const { transformedPropRefs = [], deferredPropValueTransforms = [] } = transformationContext;
  for (const name in obj) {
    if (!obj.hasOwnProperty(name))
      continue;
    path5.push(name);
    const objProp = obj[name];
    const isPlainObject2 = isPlainObject(objProp);
    if (isPlainObject2 && "value" in objProp) {
      const pathName = getName_default(path5);
      const alreadyTransformed = transformedPropRefs.includes(pathName);
      if (alreadyTransformed) {
        transformedObj[name] = objProp;
        path5.pop();
        continue;
      }
      const setupProperty = propertySetup_default(objProp, name, path5);
      if (usesReference_default(setupProperty.value, options2)) {
        if (!deferredPropValueTransforms.includes(pathName))
          deferredPropValueTransforms.push(pathName);
        transformedObj[name] = setupProperty;
        path5.pop();
        continue;
      }
      transformedObj[name] = property_default(setupProperty, options2);
      pull(deferredPropValueTransforms, pathName);
      transformedPropRefs.push(pathName);
    } else if (isPlainObject2) {
      transformedObj[name] = transformObject(objProp, options2, transformationContext, path5, transformedObj[name]);
    } else {
      transformedObj[name] = objProp;
    }
    path5.pop();
  }
  return transformedObj;
}
var object_default = transformObject;

// src/transform/config.js
var TEMPLATE_DEPRECATION_WARNINGS = groupMessages_default.GROUP.TemplateDeprecationWarnings;
var MISSING_TRANSFORM_ERRORS = groupMessages_default.GROUP.MissingRegisterTransformErrors;
function transformConfig(config, dictionary, platformName) {
  const to_ret = clone(config);
  let transforms = [];
  if (to_ret.transforms) {
    transforms = to_ret.transforms.filter(Boolean);
  } else if (to_ret.transformGroup) {
    if (dictionary.transformGroup[to_ret.transformGroup]) {
      transforms = dictionary.transformGroup[to_ret.transformGroup];
    } else {
      const err = `Unknown transformGroup "${to_ret.transformGroup}" found in platform "${platformName}":
"${to_ret.transformGroup}" does not match the name of a registered transformGroup.
`;
      throw new Error(err);
    }
  }
  to_ret.transforms = transforms.map((name) => {
    if (!dictionary.transform[name]) {
      groupMessages_default.add(
        MISSING_TRANSFORM_ERRORS,
        `"${name}"`
      );
    }
    return dictionary.transform[name];
  });
  const missingTransformCount = groupMessages_default.count(MISSING_TRANSFORM_ERRORS);
  if (missingTransformCount > 0) {
    const transform_warnings = groupMessages_default.flush(MISSING_TRANSFORM_ERRORS).join(", ");
    const err = `Unknown transforms ${transform_warnings} found in platform "${platformName}":
None of ${transform_warnings} match the name of a registered transform.`;
    throw new Error(err);
  }
  if (config.options && config.options.fileHeader) {
    const fileHeader2 = config.options.fileHeader;
    if (typeof fileHeader2 === "string") {
      if (dictionary.fileHeader[fileHeader2])
        to_ret.options.fileHeader = dictionary.fileHeader[fileHeader2];
      else
        throw new Error(`Can't find fileHeader: ${fileHeader2}`);
    } else if (typeof fileHeader2 !== "function") {
      throw new TypeError("fileHeader must be a string or a function");
    } else {
      to_ret.options.fileHeader = fileHeader2;
    }
  }
  to_ret.files = (config.files || []).map((file) => {
    const ext = { options: {} };
    if (file.options && file.options.fileHeader) {
      const fileHeader2 = file.options.fileHeader;
      if (typeof fileHeader2 === "string") {
        if (dictionary.fileHeader[fileHeader2])
          ext.options.fileHeader = dictionary.fileHeader[fileHeader2];
        else
          throw new Error(`Can't find fileHeader: ${fileHeader2}`);
      } else if (typeof fileHeader2 !== "function") {
        throw new TypeError("fileHeader must be a string or a function");
      } else {
        ext.options.fileHeader = fileHeader2;
      }
    }
    if (file.filter) {
      if (typeof file.filter === "string") {
        if (dictionary.filter[file.filter])
          ext.filter = dictionary.filter[file.filter];
        else
          throw new Error(`Can't find filter: ${file.filter}`);
      } else if (typeof file.filter === "object") {
        ext.filter = matches(file.filter);
      } else if (typeof file.filter === "function") {
        ext.filter = file.filter;
      } else {
        throw new TypeError(`Filter format not valid: ${typeof file.filter}`);
      }
    }
    if (file.template) {
      if (dictionary.format[file.template]) {
        groupMessages_default.add(
          TEMPLATE_DEPRECATION_WARNINGS,
          `${file.destination} (template: ${file.template})`
        );
        ext.format = dictionary.format[file.template];
      } else {
        throw new Error(`Can't find template: ${file.template}`);
      }
    } else if (file.format) {
      if (dictionary.format[file.format])
        ext.format = dictionary.format[file.format];
      else
        throw new Error(`Can't find format: ${file.format}`);
    } else {
      throw new Error(`Please supply a format for file: ${JSON.stringify(file)}`);
    }
    return deepExtend_default([{}, file, ext]);
  });
  to_ret.actions = (config.actions || []).map((action) => {
    if (typeof dictionary.action[action].undo !== "function")
      logger_default().warn(`${action} action does not have a clean function!`);
    return dictionary.action[action];
  });
  return to_ret;
}
var config_default = transformConfig;

// src/exportPlatform.js
var PROPERTY_REFERENCE_WARNINGS2 = groupMessages_default.GROUP.PropertyReferenceWarnings;
function exportPlatform(platform) {
  if (!platform || !this.options.platforms[platform])
    throw new Error("Please supply a valid platform");
  const platformConfig = config_default(this.options.platforms[platform], this);
  let exportableResult = this.properties;
  const transformedPropRefs = [];
  const deferredPropValueTransforms = [];
  const transformationContext = {
    transformedPropRefs,
    deferredPropValueTransforms
  };
  let deferredPropCount = 0;
  let finished;
  while (typeof finished === "undefined") {
    const transformed = object_default(exportableResult, platformConfig, transformationContext);
    const ignorePathsToResolve = deferredPropValueTransforms.map((p) => getName_default([p, "value"]));
    exportableResult = resolveObject_default(transformed, { ignorePaths: ignorePathsToResolve });
    const newDeferredPropCount = deferredPropValueTransforms.length;
    if (newDeferredPropCount === 0) {
      finished = true;
    } else if (deferredPropCount === newDeferredPropCount) {
      resolveObject_default(transformed);
      finished = true;
    } else {
      deferredPropCount = newDeferredPropCount;
    }
  }
  if (groupMessages_default.count(PROPERTY_REFERENCE_WARNINGS2) > 0) {
    const warnings = groupMessages_default.flush(PROPERTY_REFERENCE_WARNINGS2).join("\n");
    logger_default().log(`
${PROPERTY_REFERENCE_WARNINGS2}:
${warnings}

`);
    throw new Error("Problems were found when trying to resolve property references");
  }
  return exportableResult;
}
var exportPlatform_default = exportPlatform;

// src/filterProperties.js
function filterPropertyObject(properties, filter2) {
  return reduce(properties, (result, value, key) => {
    if (!isObject(value)) {
      return result;
    } else if (typeof value.value !== "undefined") {
      return filter2(value) ? assign(result, { [key]: value }) : result;
    } else {
      const filtered = filterPropertyObject(value, filter2);
      return isEmpty(filtered) ? result : assign(result, { [key]: filtered });
    }
  }, {});
}
function filterPropertyArray(properties, filter2) {
  return filter(properties, filter2);
}
function filterProperties(dictionary, filter2) {
  if (!filter2) {
    return dictionary;
  } else {
    return {
      allProperties: filterPropertyArray(dictionary.allProperties, filter2),
      properties: filterPropertyObject(dictionary.properties, filter2)
    };
  }
}
var filterProperties_default = filterProperties;

// src/utils/createFormatArgs.js
function createFormatArgs({ dictionary, platform, file = {} }) {
  const { allProperties, properties, allTokens, tokens, usesReference: usesReference2, getReferences: getReferences2 } = dictionary;
  const { options: options2 } = platform;
  file = deepExtend_default([{}, { options: options2 }, file]);
  return {
    dictionary,
    usesReference: usesReference2,
    getReferences: getReferences2,
    allProperties,
    properties,
    allTokens,
    tokens,
    platform,
    file,
    options: file.options || {}
  };
}
var createFormatArgs_default = createFormatArgs;

// src/buildFile.js
function buildFile(file = {}, platform = {}, dictionary = {}) {
  const { destination, filter: filter2 } = file || {};
  let { format } = file || {};
  const silent = (file == null ? void 0 : file.silent) || (platform == null ? void 0 : platform.silent) || false;
  if (typeof format !== "function")
    throw new Error("Please enter a valid file format");
  const nested = format.nested;
  format = format.bind(file);
  let fullDestination = destination;
  const id = `${(file == null ? void 0 : file.format) || ""}-${Date.now()}`;
  if (typeof destination === "string") {
    if (platform.buildPath)
      fullDestination = platform.buildPath + fullDestination;
    const dirname3 = path4.dirname(fullDestination);
    if (!fs3.existsSync(dirname3))
      fs3.mkdirsSync(dirname3, { recursive: true });
  }
  const filteredProperties = filterProperties_default(dictionary, filter2);
  const filteredDictionary = Object.assign({}, dictionary, {
    properties: filteredProperties.properties,
    allProperties: filteredProperties.allProperties,
    tokens: filteredProperties.properties,
    allTokens: filteredProperties.allProperties,
    _properties: dictionary.properties
  });
  if (filteredProperties.hasOwnProperty("properties") && Object.keys(filteredProperties.properties).length === 0 && filteredProperties.properties.constructor === Object) {
    const warnNoFile = `No properties for ${destination || id}. File not created.`;
    !silent && logger_default().log(chalk2.red(warnNoFile));
    return null;
  }
  const nameCollisionObj = {};
  filteredProperties.allProperties && filteredProperties.allProperties.forEach((propertyData) => {
    const propertyName = propertyData.name;
    if (!nameCollisionObj[propertyName])
      nameCollisionObj[propertyName] = [];
    nameCollisionObj[propertyName].push(propertyData);
  });
  const PROPERTY_NAME_COLLISION_WARNINGS = `${groupMessages_default.GROUP.PropertyNameCollisionWarnings}:${destination || id}`;
  groupMessages_default.clear(PROPERTY_NAME_COLLISION_WARNINGS);
  Object.keys(nameCollisionObj).forEach((propertyName) => {
    if (nameCollisionObj[propertyName].length > 1) {
      const collisions = nameCollisionObj[propertyName].map((properties) => {
        const propertyPathText = chalk2.red(properties.path.join("."));
        const valueText = chalk2.red(properties.value);
        return `${propertyPathText}   ${valueText}`;
      }).join("\n        ");
      groupMessages_default.add(
        PROPERTY_NAME_COLLISION_WARNINGS,
        `Output name ${chalk2.red.bold(propertyName)} was generated by:
        ${collisions}`
      );
    }
  });
  const propertyNamesCollisionCount = groupMessages_default.count(PROPERTY_NAME_COLLISION_WARNINGS);
  const result = format(createFormatArgs_default({
    dictionary: filteredDictionary,
    platform,
    file
  }), platform, file);
  if ((platform == null ? void 0 : platform.write) !== false && (file == null ? void 0 : file.write) !== false) {
    fs3.writeFileSync(
      fullDestination,
      result
    );
  }
  if ((platform == null ? void 0 : platform.done) && typeof (platform == null ? void 0 : platform.done) === "function")
    platform == null ? void 0 : platform.done({ file, platform, dictionary, result });
  if ((file == null ? void 0 : file.done) && typeof (file == null ? void 0 : file.done) === "function")
    file == null ? void 0 : file.done({ file, platform, dictionary, result });
  const filteredReferencesCount = groupMessages_default.count(groupMessages_default.GROUP.FilteredOutputReferences);
  if (!silent) {
    if ((nested || propertyNamesCollisionCount === 0) && filteredReferencesCount === 0) {
      logger_default().log(chalk2.bold.green(`\u2714\uFE0E ${fullDestination}`));
    } else {
      logger_default().log(`\u26A0\uFE0F ${fullDestination}`);
      if (propertyNamesCollisionCount > 0) {
        const propertyNamesCollisionWarnings = groupMessages_default.fetchMessages(PROPERTY_NAME_COLLISION_WARNINGS).join("\n    ");
        const title = `While building ${chalk2.red.bold(destination || id)}, token collisions were found; output may be unexpected.`;
        const help = chalk2.red([
          "This many-to-one issue is usually caused by some combination of:",
          "* conflicting or similar paths/names in property definitions",
          "* platform transforms/transformGroups affecting names, especially when removing specificity",
          "* overly inclusive file filters"
        ].join("\n    "));
        const warn = `${title}
    ${propertyNamesCollisionWarnings}
${help}`;
        logger_default().log(chalk2.red.bold(warn));
      }
      if (filteredReferencesCount > 0) {
        const filteredReferencesWarnings = groupMessages_default.flush(groupMessages_default.GROUP.FilteredOutputReferences).join("\n    ");
        const title = `While building ${chalk2.red.bold(destination || id)}, filtered out token references were found; output may be unexpected. Here are the references that are used but not defined in the file`;
        const help = chalk2.red([
          "This is caused when combining a filter and `outputReferences`."
        ].join("\n    "));
        const warn = `${title}
    ${filteredReferencesWarnings}
${help}`;
        logger_default().log(chalk2.red.bold(warn));
      }
    }
  }
}
var buildFile_default = buildFile;

// src/buildFiles.js
function buildFiles(dictionary, platform) {
  if (platform.buildPath && (platform.buildPath.slice(-1) !== "/" && platform.buildPath.slice(-1) !== "\\"))
    throw new Error("Build path must end in a trailing slash or you will get weird file names.");
  platform.files.forEach((file) => {
    if (file.format)
      buildFile_default(file, platform, dictionary);
    else
      throw new Error("Please supply a format");
  });
}
var buildFiles_default = buildFiles;

// src/performActions.js
function performActions(dictionary, platform) {
  if (platform.actions) {
    platform.actions.forEach((action) => {
      action.do(dictionary, platform);
    });
  }
}
var performActions_default = performActions;

// src/utils/flattenProperties.js
function flattenProperties(properties, to_ret) {
  to_ret = to_ret || [];
  for (const name in properties) {
    if (properties.hasOwnProperty(name)) {
      if (isPlainObject(properties[name]) && "value" in properties[name])
        to_ret.push(properties[name]);
      else if (isPlainObject(properties[name]))
        flattenProperties(properties[name], to_ret);
    }
  }
  return to_ret;
}
var flattenProperties_default = flattenProperties;

// src/utils/references/getReferences.js
function getReferences(value, references = []) {
  const self = this;
  const regex2 = createReferenceRegex_default({});
  function findReference(match, variable) {
    variable = variable.trim().replace(".value", "");
    const pathName = getPathFromName_default(variable);
    let ref = resolveReference_default(pathName, self.properties);
    if (!ref) {
      ref = resolveReference_default(pathName, self._properties);
      groupMessages_default.add(groupMessages_default.GROUP.FilteredOutputReferences, variable);
    }
    references.push(ref);
  }
  if (typeof value === "string") {
    value.replace(regex2, findReference);
  }
  if (typeof value === "object") {
    for (const key in value) {
      if (value.hasOwnProperty(key) && typeof value[key] === "string")
        value[key].replace(regex2, findReference);
      if (value.hasOwnProperty(key) && typeof value[key] === "object")
        self.getReferences(value[key], references);
    }
  }
  return references;
}
var getReferences_default = getReferences;

// src/utils/createDictionary.js
function createDictionary({ properties }) {
  const allProperties = flattenProperties_default(properties);
  return {
    properties,
    allProperties,
    tokens: properties,
    allTokens: allProperties,
    getReferences: getReferences_default,
    usesReference: usesReference_default
  };
}
var createDictionary_default = createDictionary;

// src/buildPlatform.js
function buildPlatform(platform) {
  if (!this.options || !(platform in (this.options.platforms || {})))
    throw new Error(`Platform "${platform}" does not exist`);
  let properties;
  const platformConfig = config_default(this.options.platforms[platform], this, platform);
  if (!(platformConfig == null ? void 0 : platformConfig.silent))
    logger_default().log(`
${platform}`);
  properties = this.exportPlatform(platform);
  const dictionary = createDictionary_default({ properties });
  buildFiles_default(dictionary, platformConfig);
  performActions_default(dictionary, platformConfig);
  return this;
}
var buildPlatform_default = buildPlatform;

// src/buildAllPlatforms.js
function buildAllPlatforms() {
  const self = this;
  Object.keys(this.options.platforms).forEach((key) => {
    self.buildPlatform(key);
  });
  return this;
}
var buildAllPlatforms_default = buildAllPlatforms;
function cleanFile(file = {}, platform = {}) {
  let { destination } = file;
  const silent = (file == null ? void 0 : file.silent) || (platform == null ? void 0 : platform.silent) || false;
  if (typeof destination !== "string" || platform.write === false)
    return;
  if (platform.buildPath)
    destination = platform.buildPath + destination;
  if (!fs3.existsSync(destination)) {
    !silent && logger_default().log(`${chalk2.bold.red("!")} ${destination}, does not exist`);
    return;
  }
  fs3.unlinkSync(destination);
  !silent && logger_default().log(`${chalk2.bold.red("-")} ${destination}`);
}
var cleanFile_default = cleanFile;

// src/cleanFiles.js
function cleanFiles(dictionary, platform) {
  if (platform.buildPath && platform.buildPath.slice(-1) !== "/")
    throw new Error("Build path must end in a trailing slash or you will get weird file names.");
  platform.files.forEach((file) => {
    if (file.format)
      cleanFile_default(file, platform);
    else
      throw new Error("Please supply a template or formatter");
  });
}
var cleanFiles_default = cleanFiles;
function cleanDir(file = {}, platform = {}) {
  let { destination } = file;
  const silent = (file == null ? void 0 : file.silent) || (platform == null ? void 0 : platform.silent) || false;
  if (typeof destination !== "string" || platform.write === false)
    return;
  if (platform.buildPath)
    destination = platform.buildPath + destination;
  let dirname3 = path4.dirname(destination);
  while (dirname3) {
    if (fs3.existsSync(dirname3)) {
      if (fs3.readdirSync(dirname3).length === 0) {
        !silent && logger_default().log(`${chalk2.bold.red("-")} ${dirname3}`);
        fs3.rmdirSync(dirname3);
      } else {
        break;
      }
    }
    dirname3 = dirname3.split("/");
    dirname3.pop();
    dirname3 = dirname3.join("/");
  }
}
var cleanDir_default = cleanDir;

// src/cleanDirs.js
function cleanDirs(dictionary, platform) {
  if (platform.buildPath && platform.buildPath.slice(-1) !== "/")
    throw new Error("Build path must end in a trailing slash or you will get weird file names.");
  platform.files.forEach((file) => {
    if (file.format)
      cleanDir_default(file, platform);
    else
      throw new Error("Please supply a format");
  });
}
var cleanDirs_default = cleanDirs;

// src/cleanActions.js
function cleanActions(dictionary, platform) {
  if (platform.actions) {
    platform.actions.forEach((action) => {
      if (typeof action.undo === "function")
        action.undo(dictionary, platform);
    });
  }
}
var cleanActions_default = cleanActions;

// src/cleanPlatform.js
function cleanPlatform(platform) {
  if (!this.options || !(platform in (this.options.platforms || {})))
    throw new Error(`Platform ${platform} doesn't exist`);
  let properties;
  const platformConfig = config_default(this.options.platforms[platform], this, platform);
  if (!(platformConfig == null ? void 0 : platformConfig.silent))
    logger_default().log(`
${platform}`);
  properties = this.exportPlatform(platform);
  const dictionary = createDictionary_default({ properties });
  cleanFiles_default(dictionary, platformConfig);
  cleanActions_default(dictionary, platformConfig);
  cleanDirs_default(dictionary, platformConfig);
  return this;
}
var cleanPlatform_default = cleanPlatform;

// src/cleanAllPlatforms.js
function cleanAllPlatforms() {
  const self = this;
  Object.keys(this.options.platforms).forEach((key) => {
    self.cleanPlatform(key);
  });
  return this;
}
var cleanAllPlatforms_default = cleanAllPlatforms;
function resolveFileContent_default(resolvedPath) {
  let _content;
  if (resolvedPath.match(/.json5$/)) {
    const source = fs2.readFileSync(resolvedPath, { encoding: "UTF-8" });
    _content = JSON5.parse(source);
  } else if (resolvedPath.match(/.jsonc$/)) {
    const source = fs2.readFileSync(resolvedPath, { encoding: "UTF-8" });
    _content = parse(source);
  } else if (resolvedPath.match(/.json$/)) {
    const source = fs2.readFileSync(resolvedPath, { encoding: "UTF-8" });
    _content = JSON.parse(source);
  } else {
    _content = jiti(import.meta.url, { interopDefault: true, cache: false, v8cache: false, requireCache: false })(resolvedPath);
  }
  return _content;
}
function traverseObj2(obj, fn) {
  for (const key in obj) {
    fn.apply(null, [obj, key, obj[key]]);
    if (obj[key] && typeof obj[key] === "object")
      traverseObj2(obj[key], fn);
  }
}
function combineJSON(arr, deep, collision, source, parsers = []) {
  let i;
  let files = [];
  const to_ret = {};
  for (i = 0; i < arr.length; i++) {
    const new_files = glob.sync(arr[i], {});
    files = files.concat(new_files);
  }
  for (i = 0; i < files.length; i++) {
    const filePath = files[i];
    const resolvedPath = path4.isAbsolute(files[i]) ? files[i] : path4.resolve(process.cwd(), files[i]);
    let file_content = null;
    try {
      parsers.forEach(({ pattern, parse }) => {
        if (resolvedPath.match(pattern)) {
          file_content = parse({
            contents: fs2.readFileSync(resolvedPath, { encoding: "UTF-8" }),
            filePath: resolvedPath
          });
        }
      });
      if (!file_content) {
        const _content = resolveFileContent_default(resolvedPath);
        file_content = deepExtend_default([file_content, _content]);
      }
    } catch (e) {
      e.message = `Failed to load or parse JSON or JS Object: ${e.message}`;
      throw e;
    }
    traverseObj2(file_content, (obj) => {
      if (obj.hasOwnProperty("value") && !obj.filePath) {
        obj.filePath = filePath;
        obj.isSource = !!(source || source === void 0);
      }
    });
    if (deep)
      deepExtend_default([to_ret, file_content], collision);
    else
      Object.assign(to_ret, file_content);
  }
  return to_ret;
}
var combineJSON_default = combineJSON;

// src/extend.js
var PROPERTY_VALUE_COLLISIONS = groupMessages_default.GROUP.PropertyValueCollisions;
function extend(opts) {
  let options2, to_ret;
  let inlineTokens = {};
  let includeTokens = {};
  let sourceTokens = {};
  if (isString(opts))
    options2 = resolveFileContent_default(opts);
  else
    options2 = opts;
  to_ret = deepExtend_default([{}, this, { options: options2 }, options2]);
  inlineTokens = deepExtend_default([{}, to_ret.tokens || {}, to_ret.properties || {}]);
  if (options2.include) {
    if (!isArray(options2.include))
      throw new Error("include must be an array");
    includeTokens = combineJSON_default(options2.include, true, null, false, to_ret.parsers);
    to_ret.include = null;
  }
  if (options2.source) {
    if (!isArray(options2.source))
      throw new Error("source must be an array");
    sourceTokens = combineJSON_default(options2.source, true, (prop) => {
      groupMessages_default.add(
        PROPERTY_VALUE_COLLISIONS,
        `Collision detected at: ${prop.path.join(".")}! Original value: ${prop.target[prop.key]}, New value: ${prop.copy[prop.key]}`
      );
    }, true, to_ret.parsers);
    if (groupMessages_default.count(PROPERTY_VALUE_COLLISIONS) > 0) {
      const collisions = groupMessages_default.flush(PROPERTY_VALUE_COLLISIONS).join("\n");
      logger_default().log(`
${PROPERTY_VALUE_COLLISIONS}:
${collisions}

`);
      if (options2.log === "error")
        throw new Error("Collisions detected");
    }
    to_ret.source = null;
  }
  const tokens = deepExtend_default([{}, inlineTokens, includeTokens, sourceTokens]);
  to_ret.tokens = tokens;
  to_ret.properties = tokens;
  return to_ret;
}
var extend_default = extend;

// src/index.js
var TEMPLATE_DEPRECATION_WARNINGS2 = groupMessages_default.GROUP.TemplateDeprecationWarnings;
var REGISTER_TEMPLATE_DEPRECATION_WARNINGS2 = groupMessages_default.GROUP.RegisterTemplateDeprecationWarnings;
var SASS_MAP_FORMAT_DEPRECATION_WARNINGS2 = groupMessages_default.GROUP.SassMapFormatDeprecationWarnings;
var StyleDictionary = {
  VERSION: version,
  properties: {},
  allProperties: [],
  tokens: {},
  allTokens: [],
  options: {},
  parsers: [],
  fileHeader: {},
  transform: transforms_default,
  transformGroup: transformGroups_default,
  format: formats_default,
  action: actions_default,
  formatHelpers: formatHelpers_exports,
  filter: filters_default,
  logger: logger_default,
  registerTransform: transform_default,
  registerTransformGroup: transformGroup_default,
  registerFormat: format_default,
  registerAction: action_default,
  registerFilter: filter_default,
  registerParser: parser_default,
  registerFileHeader: fileHeader_default2,
  exportPlatform: exportPlatform_default,
  buildPlatform: buildPlatform_default,
  buildAllPlatforms: buildAllPlatforms_default,
  cleanPlatform: cleanPlatform_default,
  cleanAllPlatforms: cleanAllPlatforms_default,
  extend: extend_default,
  registerTemplate: template_default
};
var src_default = StyleDictionary;
process.on("exit", () => {
  if (groupMessages_default.count(TEMPLATE_DEPRECATION_WARNINGS2) > 0) {
    const template_warnings = groupMessages_default.flush(TEMPLATE_DEPRECATION_WARNINGS2).join("\n  ");
    logger_default().log(chalk2.bold.yellow(`
\u26A0\uFE0F DEPRECATION WARNING \uFE0F\uFE0F\uFE0F\uFE0F\uFE0F\u26A0\uFE0F
Templates are deprecated and will be removed, please update your config to use formats.
This is an example of how to update your config.json:

Before:
  "files": [{
    "destination": "colors.xml",
    "template": "android/colors"
  }]

After:
  "files": [{
    "destination": "colors.xml",
    "format": "android/colors"
  }]

Your current config uses the following templates:
  ${template_warnings}
`));
  }
  if (groupMessages_default.count(REGISTER_TEMPLATE_DEPRECATION_WARNINGS2) > 0) {
    const register_template_warnings = groupMessages_default.flush(REGISTER_TEMPLATE_DEPRECATION_WARNINGS2).join("\n  ");
    logger_default().log(chalk2.bold.yellow(`
\u26A0\uFE0F DEPRECATION WARNING \uFE0F\uFE0F\uFE0F\uFE0F\uFE0F\u26A0\uFE0F
The registerTemplate method is deprecated and will be removed, please
migrate to registerFormat. You can use any templating engine you would
like, you only need to require/import it. This is an example of how to
update your code using a lodash template (the template engine previously
used by registerTemplate):

Before:
  registerTemplate({
    name: 'template/name',
    template: templateFile,
  });

After:
  registerFormat({
    name: 'template/name',
    formatter: _.template( fs.readFileSync( templateFile ) ),
  });

Note that formatter is a function that takes in a style dictionary
and returns a string with the formatted output. There is a second
argument available that contains the configuration being used to
process the style dictionary.

Calls to registerTemplate included the registration of the following
custom templates:
  ${register_template_warnings}`));
  }
  if (groupMessages_default.count(SASS_MAP_FORMAT_DEPRECATION_WARNINGS2) > 0) {
    const sass_map_format_warnings = groupMessages_default.flush(SASS_MAP_FORMAT_DEPRECATION_WARNINGS2).join("\n  ");
    logger_default().log(chalk2.bold.cyan(`
\u{1F514} NOTICE \u{1F514}
The formats 'sass/map-***' have been renamed to 'scss/map-***', please update your config.
In the future 'sass/map-***' formats may output actual Sass instead of SCSS, which may break your current configuration.
This is an example of how to update your config.json:

Before:
  "files": [{
    "destination": "tokens_map-flat.scss",
    "format": "sass/map-flat"
  }]

After:
  "files": [{
    "destination": "tokens_map-flat.scss",
    "format": "scss/map-flat"
  }]

Your current config uses the following formats:
  ${sass_map_format_warnings}
`));
  }
});

export { src_default as default };
