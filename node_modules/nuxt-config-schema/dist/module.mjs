import { existsSync } from 'node:fs';
import { mkdir, writeFile } from 'node:fs/promises';
import { dirname, resolve } from 'pathe';
import { createDefu } from 'defu';
import { defineNuxtModule, createResolver } from '@nuxt/kit';
import { resolveSchema, generateMarkdown, generateTypes } from 'untyped';
import untypedPlugin from 'untyped/babel-plugin';
import jiti from 'jiti';



// -- Unbuild CommonJS Shims --
import __cjs_url__ from 'url';
import __cjs_path__ from 'path';
import __cjs_mod__ from 'module';
const __filename = __cjs_url__.fileURLToPath(import.meta.url);
const __dirname = __cjs_path__.dirname(__filename);
const require = __cjs_mod__.createRequire(import.meta.url);
const module = defineNuxtModule({
  meta: {
    name: "nuxt-config-schema"
  },
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url);
    const virtualImports = await resolver.resolvePath(
      "./runtime/virtual-imports"
    );
    const _require = jiti(dirname(import.meta.url), {
      esmResolve: true,
      interopDefault: true,
      cache: false,
      requireCache: false,
      alias: {
        "#imports": virtualImports,
        "nuxt/config": virtualImports
      },
      transformOptions: {
        babel: {
          plugins: [untypedPlugin]
        }
      }
    });
    const _defu = createDefu((obj, key, value) => {
      if (Array.isArray(obj[key]) && Array.isArray(value)) {
        obj[key] = Array.from(/* @__PURE__ */ new Set([...obj[key], ...value]));
        return true;
      }
    });
    nuxt.hook("prepare:types", (ctx) => {
      ctx.references.push({ path: "nuxt-config-schema" });
      ctx.references.push({ path: "schema/nuxt.schema.d.ts" });
    });
    let schema;
    nuxt.hook("modules:done", async () => {
      schema = await resolveSchema$1();
      nuxt.options = _defu(nuxt.options, schema.default);
    });
    nuxt.hooks.hook("build:done", async () => {
      await nuxt.hooks.callHook("schema:beforeWrite", schema);
      await writeSchema(schema);
      await nuxt.hooks.callHook("schema:written");
    });
    async function resolveSchema$1() {
      globalThis.defineNuxtConfigSchema = (val) => val;
      const schemas = [];
      for (const layer of nuxt.options._layers) {
        const filePath = await resolver.resolvePath(
          resolve(layer.config.rootDir, "nuxt.schema")
        );
        if (filePath && existsSync(filePath)) {
          let loadedConfig;
          try {
            loadedConfig = _require(filePath);
          } catch (err) {
            console.warn(
              "[nuxt-config-schema] Unable to load schema from",
              filePath,
              err
            );
            continue;
          }
          const lastLayerDefaults = schemas.length ? schemas[schemas.length - 1].default : {};
          const schema3 = await resolveSchema(
            loadedConfig,
            lastLayerDefaults
          );
          schemas.push(schema3);
        }
      }
      const mergedSchema = _defu(...schemas);
      const userSchema = await resolveSchema(
        nuxt.options.$schema,
        mergedSchema.default
      );
      const schema2 = _defu(userSchema, mergedSchema);
      await nuxt.hooks.callHook("schema:resolved", schema2);
      return schema2;
    }
    async function writeSchema(schema2) {
      await mkdir(resolve(nuxt.options.buildDir, "schema"), { recursive: true });
      await writeFile(
        resolve(nuxt.options.buildDir, "schema/nuxt.schema.json"),
        JSON.stringify(schema2, null, 2),
        "utf8"
      );
      const markdown = "# User config schema" + generateMarkdown(schema2);
      await writeFile(
        resolve(nuxt.options.buildDir, "schema/nuxt.schema.md"),
        markdown,
        "utf8"
      );
      const _types = generateTypes(schema2, {
        addExport: true,
        interfaceName: "NuxtUserConfig",
        partial: true
      });
      const types = _types + `
export type UserAppConfig = Exclude<NuxtUserConfig['appConfig'], undefined>

declare module '@nuxt/schema' {
  interface NuxtConfig extends NuxtUserConfig {}
  interface NuxtOptions extends NuxtUserConfig {}
  interface AppConfigInput extends UserAppConfig {}
  interface AppConfig extends UserAppConfig {}
}`;
      const typesPath = resolve(
        nuxt.options.buildDir,
        "schema/nuxt.schema.d.ts"
      );
      await writeFile(typesPath, types, "utf8");
    }
  }
});

export { module as default };
