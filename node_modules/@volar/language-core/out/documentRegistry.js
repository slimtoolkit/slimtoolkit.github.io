Object.defineProperty(exports, "__esModule", { value: true });
exports.forEachEmbeddedFile = exports.createVirtualFiles = void 0;
const source_map_1 = require("@volar/source-map");
const sourceMaps_1 = require("./sourceMaps");
function createVirtualFiles(languageModules) {
    const sourceFiles = new Map();
    const virtualFiles = new Map();
    const virtualFileToSourceMapsMap = new WeakMap();
    const virtualFileToMirrorMap = new WeakMap();
    let sourceFilesDirty = true;
    return {
        all: sourceFiles,
        update(fileName, snapshot) {
            const key = normalizePath(fileName);
            const value = sourceFiles.get(key);
            if (value) {
                const virtualFile = value[2];
                value[1] = snapshot;
                value[3].updateFile(virtualFile, snapshot);
                sourceFilesDirty = true;
                return virtualFile; // updated
            }
            for (const languageModule of languageModules) {
                const virtualFile = languageModule.createFile(fileName, snapshot);
                if (virtualFile) {
                    sourceFiles.set(key, [fileName, snapshot, virtualFile, languageModule]);
                    sourceFilesDirty = true;
                    return virtualFile; // created
                }
            }
        },
        delete(fileName) {
            var _a, _b;
            const key = normalizePath(fileName);
            const value = sourceFiles.get(key);
            if (value) {
                const virtualFile = value[2];
                (_b = (_a = value[3]).deleteFile) === null || _b === void 0 ? void 0 : _b.call(_a, virtualFile);
                sourceFiles.delete(key); // deleted
                sourceFilesDirty = true;
            }
        },
        get(fileName) {
            const key = normalizePath(fileName);
            const value = sourceFiles.get(key);
            if (value) {
                return [
                    value[1],
                    value[2],
                ];
            }
        },
        hasSourceFile: (fileName) => sourceFiles.has(normalizePath(fileName)),
        getMirrorMap: getMirrorMap,
        getMaps: getSourceMaps,
        getSourceByVirtualFileName(fileName) {
            const source = getVirtualFilesMap().get(normalizePath(fileName));
            if (source) {
                return [
                    source[1][0],
                    source[1][1],
                    source[0],
                ];
            }
        },
    };
    function getVirtualFilesMap() {
        if (sourceFilesDirty) {
            sourceFilesDirty = false;
            virtualFiles.clear();
            for (const [_, row] of sourceFiles) {
                forEachEmbeddedFile(row[2], file => {
                    virtualFiles.set(normalizePath(file.fileName), [file, row]);
                });
            }
        }
        return virtualFiles;
    }
    function getSourceMaps(virtualFile) {
        let sourceMapsBySourceFileName = virtualFileToSourceMapsMap.get(virtualFile.snapshot);
        if (!sourceMapsBySourceFileName) {
            sourceMapsBySourceFileName = new Map();
            virtualFileToSourceMapsMap.set(virtualFile.snapshot, sourceMapsBySourceFileName);
        }
        const sources = new Set();
        for (const map of virtualFile.mappings) {
            sources.add(map.source);
        }
        for (const source of sources) {
            const sourceFileName = source !== null && source !== void 0 ? source : getVirtualFilesMap().get(normalizePath(virtualFile.fileName))[1][0];
            if (!sourceMapsBySourceFileName.has(sourceFileName)) {
                sourceMapsBySourceFileName.set(sourceFileName, [
                    sourceFileName,
                    new source_map_1.SourceMap(virtualFile.mappings.filter(mapping => mapping.source === source)),
                ]);
            }
        }
        return [...sourceMapsBySourceFileName.values()];
    }
    function getMirrorMap(file) {
        if (!virtualFileToMirrorMap.has(file.snapshot)) {
            virtualFileToMirrorMap.set(file.snapshot, file.mirrorBehaviorMappings ? new sourceMaps_1.MirrorMap(file.mirrorBehaviorMappings) : undefined);
        }
        return virtualFileToMirrorMap.get(file.snapshot);
    }
}
exports.createVirtualFiles = createVirtualFiles;
function forEachEmbeddedFile(file, cb) {
    cb(file);
    for (const embeddedFile of file.embeddedFiles) {
        forEachEmbeddedFile(embeddedFile, cb);
    }
}
exports.forEachEmbeddedFile = forEachEmbeddedFile;
function normalizePath(fileName) {
    return fileName.replace(/\\/g, '/').toLowerCase();
}
//# sourceMappingURL=documentRegistry.js.map