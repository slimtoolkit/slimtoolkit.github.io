import { existsSync } from 'node:fs';
import { join, resolve } from 'pathe';
import glob from 'fast-glob';
import { defineNuxtModule, createResolver, addPlugin, addPrerenderRoutes, resolveAlias, addPluginTemplate, resolveModule } from '@nuxt/kit';
import jiti from 'jiti';
import { d as defaultOptions, a as prepareOutputDir, p as pinceau } from './shared/pinceau.cbce2c23.mjs';
import { u as useDebugPerformance } from './shared/pinceau.6bd967c3.mjs';
import 'vue';
import { w as walkTokens } from './shared/pinceau.97e4e32f.mjs';
import 'chroma-js';
import 'postcss-nested';
import 'postcss-custom-properties';
import 'postcss-dark-theme-class';
import 'scule';
import 'unplugin';
import 'magic-string';
import './shared/pinceau.5247c7c8.mjs';
import './shared/pinceau.56cc5ade.mjs';
import 'node:fs/promises';
import 'style-dictionary-esm';
import 'untyped';
import 'fs';
import 'defu';
import 'acorn';
import 'vue/compiler-sfc';
import 'recast';
import 'recast/parsers/typescript.js';
import 'ohash';
import './shared/pinceau.0ea5e49b.mjs';
import 'chalk';
import 'consola';
import 'perf_hooks';

const module = defineNuxtModule({
  meta: {
    name: "pinceau/nuxt",
    configKey: "pinceau"
  },
  defaults: (nuxt) => ({
    ...defaultOptions,
    colorSchemeMode: "class",
    outputDir: join(nuxt.options.buildDir, "pinceau/")
  }),
  async setup(options, nuxt) {
    const { stopPerfTimer } = useDebugPerformance("Setup Nuxt module", options.debug);
    const modulePath = createResolver(import.meta.url);
    const resolveLocalModule = (path) => resolveModule(path, { paths: modulePath.resolve("./") });
    nuxt.options.build.transpile = nuxt.options.build.transpile || [];
    nuxt.options.build.transpile.push("pinceau", "chroma-js");
    await nuxt.callHook("pinceau:options", options);
    nuxt.options.runtimeConfig.pinceau = { studio: options?.studio, outputDir: options?.outputDir };
    if (options.componentMetaSupport) {
      let cachedTokens;
      nuxt.hook("component-meta:transformers", (transformers) => {
        transformers.push(
          (component, code) => {
            const flatPath = options.outputDir;
            const resolvedTokens = [];
            if (existsSync(join(flatPath, "index.ts"))) {
              const _tokens = jiti(flatPath)(join(flatPath, "index.ts")).default;
              walkTokens(
                _tokens?.theme || _tokens,
                (_, __, paths) => resolvedTokens.push(paths.join("."))
              );
            }
            if (cachedTokens.length) ;
            component.meta.tokens = resolvedTokens;
            return { component, code };
          }
        );
        return transformers;
      });
    }
    nuxt.hook("prepare:types", async (opts) => {
      const tsConfig = opts.tsConfig;
      tsConfig.compilerOptions = tsConfig.compilerOptions || {};
      tsConfig.compilerOptions.paths = tsConfig.compilerOptions.paths || {};
      if (options?.outputDir) {
        tsConfig.compilerOptions.paths["#pinceau/utils"] = [`${resolve(options.outputDir, "utils.ts")}`];
        tsConfig.compilerOptions.paths["#pinceau/theme"] = [`${resolve(options.outputDir, "index.ts")}`];
        if (options?.studio) {
          tsConfig.compilerOptions.paths["#pinceau/schema"] = [`${resolve(options.outputDir, "schema.ts")}`];
        }
      }
      tsConfig.vueCompilerOptions = tsConfig.vueCompilerOptions || {};
      tsConfig.vueCompilerOptions.plugins = tsConfig.vueCompilerOptions.plugins || [];
      tsConfig.vueCompilerOptions.plugins.push("pinceau/volar");
      await prepareOutputDir(options);
    });
    if (!nuxt.options.nitro) {
      nuxt.options.nitro = {};
    }
    const nitroConfig = nuxt.options.nitro;
    nitroConfig.plugins = nitroConfig.plugins || [];
    nitroConfig.plugins.push(resolveLocalModule("./nitro"));
    options.configLayers = [
      ...options?.configLayers,
      ...nuxt.options._layers.reduce(
        (acc, layer) => {
          if (typeof layer === "string") {
            acc.push({ cwd: layer, configFileName: options.configFileName });
          }
          if (layer?.cwd) {
            acc.push({ cwd: layer?.cwd, configFileName: options.configFileName });
          }
          return acc;
        },
        []
      )
    ];
    if (options.studio) {
      addPlugin(resolveLocalModule("./runtime/schema.server"));
      addPrerenderRoutes("/__pinceau_tokens_config.json");
      addPrerenderRoutes("/__pinceau_tokens_schema.json");
      const studioAppConfigPath = resolveAlias("~/.studio");
      if (existsSync(studioAppConfigPath)) {
        options.configLayers.unshift({ cwd: studioAppConfigPath, configFileName: "tokens.config" });
      }
    }
    options.cwd = nuxt.options.rootDir;
    for (const layer of options.configLayers) {
      const layerPath = typeof layer === "string" ? layer : layer?.cwd;
      if (layerPath) {
        options.includes?.push(
          ...await glob(
            join(layerPath, "**/*.vue"),
            { followSymbolicLinks: options.followSymbolicLinks }
          )
        );
      }
    }
    addPluginTemplate({
      filename: "pinceau-nuxt-plugin.server.mjs",
      mode: "server",
      getContents() {
        const lines = [];
        if (options.runtime) {
          lines.push(
            "import fs from 'node:fs'",
            "import { dirname, join } from 'pathe'",
            "import { useRuntimeConfig } from '#imports'",
            "import { plugin as pinceau } from 'pinceau/runtime'",
            "import utils from '#build/pinceau/utils'",
            "import theme from '#build/pinceau/index'",
            "",
            `export default defineNuxtPlugin(async (nuxtApp) => {
              // Setup plugin
              nuxtApp.vueApp.use(pinceau, { colorSchemeMode: '${options.colorSchemeMode}', theme, utils })

              const { pinceau: runtimeConfig } = useRuntimeConfig()

              // Handle first render of SSR styles
              nuxtApp.hook('app:rendered', async (app) => {
                // Init
                app.ssrContext.event.pinceauContent = app.ssrContext.event.pinceauContent || {}

                // Grab latest theme
                let themeCSS = ''
                try {
                  themeCSS = fs.readFileSync(join(runtimeConfig.outputDir, 'index.css'), 'utf-8')
                } catch (e) {}

                // Theme
                app.ssrContext.event.pinceauContent.theme = themeCSS
                
                // Runtime styling
                const content = app.ssrContext.nuxt.vueApp.config.globalProperties.$pinceauSsr.get()
                app.ssrContext.event.pinceauContent.runtime = content
              })
            })`
          );
        }
        if (options?.preflight) {
          lines.unshift("import '@unocss/reset/tailwind.css'");
        }
        return lines.join("\n");
      }
    });
    addPluginTemplate({
      filename: "pinceau-nuxt-plugin.client.mjs",
      mode: "client",
      getContents() {
        const lines = [];
        if (options.runtime) {
          lines.push(
            "import { plugin as pinceau } from 'pinceau/runtime'",
            "import utils from '#build/pinceau/utils'",
            "",
            `export default defineNuxtPlugin(async (nuxtApp) => {
              // Setup plugin
              nuxtApp.vueApp.use(pinceau, { colorSchemeMode: '${options.colorSchemeMode}', utils })
            })`
          );
        }
        if (options?.preflight) {
          lines.unshift("import '@unocss/reset/tailwind.css'");
        }
        return lines.join("\n");
      }
    });
    nuxt.hook("webpack:config", (config) => {
      config.plugins = config.plugins || [];
      config.plugins.unshift(pinceau.webpack(options));
    });
    nuxt.hook("vite:extend", (vite) => {
      vite.config.plugins = vite.config.plugins || [];
      vite.config.plugins.push(pinceau.vite(options));
    });
    stopPerfTimer();
  }
});

export { module as default };
