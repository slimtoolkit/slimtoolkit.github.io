import { ref, computed, watch, onScopeDispose, unref, getCurrentInstance, inject } from 'vue';
import { nanoid } from 'nanoid';
import { s as stringify, a as resolveCssProperty, k as keyRegex, c as createTokensHelper, p as pathToVarName, h as resolveReferences, r as responsiveMediaQueryRegex } from './shared/pinceau.5247c7c8.mjs';
import { s as set, g as get, n as normalizeConfig, w as walkTokens } from './shared/pinceau.97e4e32f.mjs';
import { kebabCase } from 'scule';
import { defu } from 'defu';

const HYDRATION_SELECTOR = ".phy[--]";
function usePinceauRuntimeSheet($tokens, initialUtils = {}, colorSchemeMode, appId) {
  const sheet = ref();
  const utils = ref(initialUtils);
  const cache = {};
  function stringify$1(decl, loc) {
    return stringify(decl, (property, value, style, selectors) => resolveCssProperty(property, value, style, selectors, { $tokens, utils: utils.value, options: { colorSchemeMode } }, loc));
  }
  function resolveStylesheet() {
    const global = globalThis || window;
    let style;
    let hydratableSheet;
    if (global && global.document) {
      const doc = global.document;
      hydratableSheet = doc.querySelector(`style#pinceau-runtime-hydratable${appId ? `-${appId}` : ""}`);
      const styleNode = doc.createElement("style");
      styleNode.id = `pinceau-runtime${appId ? `-${appId}` : ""}`;
      styleNode.type = "text/css";
      style = doc.head.appendChild(styleNode);
    }
    sheet.value = style?.sheet || getSSRStylesheet();
    return hydratableSheet ? hydrateStylesheet(hydratableSheet) : void 0;
  }
  function hydrateStylesheet(el) {
    const hydratableRules2 = {};
    for (const _rule of Object.entries(el?.sheet?.cssRules || sheet.value?.cssRules || {})) {
      const [index, rule] = _rule;
      const uids = resolveUid(rule);
      if (!uids || !uids.uid) {
        continue;
      }
      if (!hydratableRules2[uids.uid]) {
        hydratableRules2[uids.uid] = {};
      }
      const newIndex = sheet.value.insertRule(rule.cssText, Number(index));
      hydratableRules2[uids.uid][uids.type] = sheet.value.cssRules.item(newIndex);
    }
    if (el) {
      el.remove();
    }
    return hydratableRules2;
  }
  function toString() {
    if (!sheet.value) {
      return "";
    }
    return Object.entries(sheet.value.cssRules).reduce(
      (acc, [, rule]) => {
        acc += `${rule?.cssText}
` || "";
        return acc;
      },
      ""
    );
  }
  function pushDeclaration(uid, type, declaration, previousRule, loc) {
    if (!Object.keys(declaration).length) {
      return;
    }
    const cssText = stringify$1(
      {
        "@media": {
          [HYDRATION_SELECTOR]: { "--puid": `${uid}-${type}` },
          ...declaration
        }
      },
      loc
    );
    if (!cssText) {
      return;
    }
    if (previousRule) {
      deleteRule(previousRule);
    }
    const ruleId = sheet.value.insertRule(cssText);
    return sheet.value.cssRules[ruleId];
  }
  function deleteRule(rule) {
    const ruleIndex = Object.values(sheet.value.cssRules).indexOf(rule);
    if (typeof ruleIndex === "undefined" || isNaN(ruleIndex)) {
      return;
    }
    try {
      sheet.value.deleteRule(ruleIndex);
    } catch (e) {
    }
  }
  const hydratableRules = resolveStylesheet();
  return {
    stringify: stringify$1,
    cache,
    pushDeclaration,
    deleteRule,
    sheet,
    toString,
    hydratableRules
  };
}
function getSSRStylesheet() {
  return {
    cssRules: [],
    insertRule(cssText, index = this.cssRules.length) {
      this.cssRules.splice(index, 1, { cssText });
      return index;
    },
    deleteRule(index) {
      delete this.cssRules[index];
    }
  };
}
function resolveUid(rule) {
  const uidRule = rule.cssRules && rule.cssRules.length ? Object.entries(rule?.cssRules).find(([_, rule2]) => rule2.selectorText === HYDRATION_SELECTOR) : void 0;
  if (!uidRule) {
    return;
  }
  const uidRegex = /--puid:(.*)?-(c|v|p)?/m;
  const [, uid, type] = uidRule[1].cssText.match(uidRegex);
  if (!uid) {
    return;
  }
  return { uid, type };
}

function usePinceauRuntimeIds(instance, classes, _) {
  let uid;
  const el = instance?.vnode?.el;
  if (el && el.classList) {
    el.classList.forEach(
      (elClass) => {
        if (uid) {
          return;
        }
        if (elClass.startsWith("pc-")) {
          uid = elClass.split("pc-")[1];
        }
      }
    );
  } else {
    uid = nanoid(6);
  }
  const scopeId = instance?.vnode?.type?.__scopeId;
  const ids = {
    uid,
    componentId: scopeId ? `[${scopeId}]` : "",
    uniqueClassName: `pc-${uid}`
  };
  classes.value.c = ids.uniqueClassName;
  return computed(() => ids);
}

function isToken(token) {
  return typeof token === "string" && keyRegex.test(token);
}
function scale(type, prop, scales, valueTransform) {
  if (typeof prop === "object") {
    return prop;
  }
  if (typeof prop === "string") {
    const to_ret = {};
    if (isToken(prop)) {
      to_ret.initial = prop;
      return to_ret;
    }
    if (typeof scales === "string") {
      to_ret.initial = `{${type}.${prop}.${scales}}`;
    }
    if (typeof scales === "object") {
      Object.entries(scales).forEach(
        ([mqId, scaleValue]) => {
          if (typeof prop === "string") {
            to_ret[mqId] = `{${type}.${prop}.${scaleValue}}`;
          }
        }
      );
    }
    return valueTransform ? Object.entries(to_ret).reduce(
      (acc, [key, value]) => {
        acc[key] = valueTransform(value);
        return acc;
      },
      {}
    ) : to_ret;
  }
}
const utils = {
  isToken,
  scale
};

function usePinceauThemeSheet(initialTheme, tokensHelperConfig = {}) {
  const sheet = ref();
  const theme = ref(initialTheme || {});
  tokensHelperConfig = Object.assign(
    {
      key: "variable"
    },
    tokensHelperConfig || {}
  );
  const $tokens = createTokensHelper(
    theme,
    tokensHelperConfig
  );
  let cache = {};
  resolveStylesheet();
  if (import.meta.hot) {
    import.meta.hot.on(
      "pinceau:themeUpdate",
      (newTheme) => {
        const styleNode = document.createElement("style");
        styleNode.id = "pinceau-theme";
        styleNode.textContent = newTheme.css;
        sheet.value.ownerNode.replaceWith(styleNode);
        sheet.value = styleNode.sheet;
        hydrateStylesheet(sheet.value.cssRules);
      }
    );
  }
  function resolveStylesheet() {
    const global = globalThis || window;
    if (global && global.document) {
      const sheetElement = document.querySelector("#pinceau-theme");
      sheet.value = sheetElement?.sheet;
      if (sheet.value) {
        hydrateStylesheet(sheet.value?.cssRules);
      }
    }
  }
  function hydrateStylesheet(cssRules) {
    cache = {};
    Object.entries(cssRules || {}).forEach(
      ([_, rule]) => {
        if (rule?.type !== 4 && !rule?.cssText?.includes("--pinceau-mq")) {
          return false;
        }
        let currentTheme = "initial";
        rule.cssText.match(/--([\w-]+)\s*:\s*(.+?);/gm)?.forEach((match) => {
          const [variable, value] = match.replace(";", "").split(/:\s(.*)/s);
          if (variable === "--pinceau-mq") {
            currentTheme = value;
            if (!cache[value]) {
              const ruleReference = Object.entries(rule?.cssRules || {}).find(([_2, cssRule]) => cssRule?.cssText.includes(`--pinceau-mq: ${value}`))?.[1];
              if (ruleReference) {
                cache[value] = ruleReference;
              }
            }
            return;
          }
          const path = [...variable.substring(2).split("-")];
          set(theme.value, path, getSetValue(path, value, variable, currentTheme));
        });
      }
    );
  }
  function updateTheme(value) {
    const mqKeys = Array.from(/* @__PURE__ */ new Set(["dark", "light", ...Object.keys(value?.media || {}), ...Object.keys(theme.value?.media || {})]));
    const config = normalizeConfig(value || {}, mqKeys, true);
    walkTokens(config, (token, _, paths) => updateToken(paths, token.value));
  }
  function updateToken(path, value, mq = "initial") {
    if (typeof value === "object") {
      Object.entries(value).forEach(([mq2, mqValue]) => updateToken(path, mqValue, mq2));
      return;
    }
    const varName = pathToVarName(path);
    if (!cache?.[mq]) {
      createMqRule(mq);
    }
    const resolvedValue = resolveReferences(void 0, value, { $tokens });
    set(
      theme.value,
      path,
      getSetValue(path, resolvedValue, varName, mq)
    );
    cache?.[mq]?.style.setProperty(varName, resolvedValue);
  }
  function reactiveToken(path) {
    return computed(
      {
        get() {
          return get(theme.value, `${path}.value`);
        },
        set(v) {
          updateToken(path, v);
        }
      }
    );
  }
  function getSetValue(path, value, variable, mq = "initial") {
    const varRef = `var(${variable})`;
    const setValue = { value, variable: varRef };
    const existingValue = get(theme.value, path);
    if (existingValue) {
      if (typeof existingValue?.value === "object") {
        setValue.value = { ...existingValue.value, [mq]: value };
      } else {
        setValue.value = { initial: existingValue.value, [mq]: value };
      }
    }
    return setValue;
  }
  function createMqRule(mq) {
    if (cache?.[mq]) {
      return cache?.[mq];
    }
    let mqValue;
    if (mq === "dark" || mq === "light") {
      mqValue = `:root.${mq}`;
    } else {
      mqValue = theme.value?.media?.[mq]?.value;
    }
    let css;
    if (mqValue.match(responsiveMediaQueryRegex)) {
      css = `@media { ${mqValue} { --pinceau-mq: ${mq}; } }`;
    } else {
      css = `@media ${mqValue} { :root { --pinceau-mq: ${mq}; } }`;
    }
    cache[mq] = sheet.value.cssRules.item(sheet.value.insertRule(css, sheet.value.cssRules.length)).cssRules[0];
    return cache[mq];
  }
  return {
    $tokens,
    updateToken,
    updateTheme,
    reactiveToken,
    resolveStylesheet,
    theme
  };
}

function usePinceauComputedStyles(ids, computedStyles, sheet, loc) {
  let rule = sheet.hydratableRules?.[ids.value.uid]?.c;
  watch(
    computedStyles,
    (newComputedStyles) => {
      newComputedStyles = transformComputedStylesToDeclaration(ids.value, newComputedStyles);
      rule = sheet.pushDeclaration(
        ids.value.uid,
        "c",
        newComputedStyles,
        rule,
        { ...loc, type: "c" }
      );
    },
    {
      immediate: !rule,
      deep: true
    }
  );
  onScopeDispose(() => rule && sheet.deleteRule(rule));
}
function transformComputedStylesToDeclaration(ids, computedStyles) {
  const declaration = {};
  const targetId = `.${ids.uniqueClassName}${ids.componentId}`;
  if (computedStyles && Object.keys(computedStyles).length) {
    declaration[targetId] = declaration[targetId] || {};
    for (const [varName, _value] of Object.entries(computedStyles)) {
      const value = unref(_value);
      if (varName === "css") {
        declaration[targetId] = Object.assign(declaration[targetId], value);
        continue;
      }
      if (typeof value === "object") {
        for (const [mqId, mqPropValue] of Object.entries(value)) {
          const _value2 = unref(mqPropValue);
          if (!_value2) {
            continue;
          }
          if (mqId === "initial") {
            if (!declaration[targetId]) {
              declaration[targetId] = {};
            }
            if (!declaration[targetId]) {
              declaration[targetId] = {};
            }
            declaration[targetId][`--${varName}`] = _value2;
          }
          const mediaId = `@${mqId}`;
          if (!declaration[mediaId]) {
            declaration[mediaId] = {};
          }
          if (!declaration[mediaId][targetId]) {
            declaration[mediaId][targetId] = {};
          }
          declaration[mediaId][targetId][`--${kebabCase(varName)}`] = _value2;
        }
      } else {
        const _value2 = unref(value);
        if (_value2) {
          declaration[targetId][`--${kebabCase(varName)}`] = _value2;
        }
      }
    }
  }
  return declaration;
}

const usePinceauVariants = (ids, variants, props, sheet, classes, loc) => {
  let rule = sheet.hydratableRules?.[ids.value.uid]?.v;
  const variantsState = computed(() => variants && variants?.value ? resolveVariantsState(ids.value, props.value, variants.value) : {});
  watch(
    variantsState,
    ({ cacheId, variantsProps }) => {
      let variantClass;
      if (sheet.cache[cacheId]) {
        const cachedRule = sheet.cache[cacheId];
        rule = cachedRule.rule;
        variantClass = cachedRule.variantClass;
        cachedRule.count++;
      } else {
        variantClass = `pv-${nanoid(6)}`;
        const transformed = transformVariantsToDeclaration(variantClass, ids.value, variants.value, variantsProps);
        rule = sheet.pushDeclaration(ids.value.uid, "v", transformed, void 0, { ...loc, type: "v" });
        sheet.cache[cacheId] = { rule, variantClass, count: 1 };
      }
      classes.value.v = variantClass;
    },
    {
      immediate: true
    }
  );
  onScopeDispose(
    () => {
      const state = variantsState?.value;
      const cachedRule = sheet.cache?.[state.cacheId];
      if (cachedRule) {
        cachedRule.count--;
        if (cachedRule.count <= 0) {
          sheet.deleteRule(cachedRule.rule);
          delete sheet.cache[state.cacheId];
        }
      }
    }
  );
};
function transformVariantsToDeclaration(variantClass, ids, variants, props) {
  const declaration = {};
  if (props && Object.keys(props).length) {
    const targetId = `.${variantClass}`;
    for (const [propName, propValue] of Object.entries(props)) {
      if (typeof propValue === "object") {
        for (const [mqId, mqPropValue] of Object.entries(propValue)) {
          const _value = mqPropValue?.toString() || mqPropValue;
          const variantValue = variants[propName][_value];
          if (!variantValue) {
            continue;
          }
          if (!declaration[targetId]) {
            declaration[targetId] = {};
          }
          if (mqId === "initial") {
            if (!declaration[targetId]) {
              declaration[targetId] = {};
            }
            declaration[targetId] = defu(declaration[targetId], variantValue);
          }
          const mediaId = `@${mqId}`;
          if (!declaration[mediaId]) {
            declaration[mediaId] = {};
          }
          if (!declaration[mediaId][targetId]) {
            declaration[mediaId][targetId] = {};
          }
          declaration[mediaId][targetId] = defu(declaration[mediaId][targetId], variantValue);
        }
      } else {
        const _value = propValue?.toString?.() || propValue;
        const variantValue = variants?.[propName]?.[_value];
        if (!variantValue) {
          continue;
        }
        if (!declaration[targetId]) {
          declaration[targetId] = {};
        }
        declaration[targetId] = defu(declaration[targetId], variantValue);
      }
    }
  }
  return declaration;
}
function resolveVariantsState(ids, props, variants) {
  if (!props || !variants) {
    return {};
  }
  let cacheId = ids.componentId;
  const variantsProps = Object.entries(props).reduce(
    (acc, [propName, propValue]) => {
      if (!variants[propName]) {
        return acc;
      }
      if (typeof propValue === "object") {
        Object.entries(propValue).forEach(
          ([key, value]) => {
            cacheId += `${propName}:${key}:${value}|`;
          }
        );
      } else {
        cacheId += `${propName}:${propValue}|`;
      }
      acc[propName] = propValue;
      return acc;
    },
    {}
  );
  return { cacheId, variantsProps };
}

function usePinceauCssProp(ids, props, sheet, loc) {
  let rule = sheet.hydratableRules?.[ids.value.uid]?.p;
  const css = computed(() => props.value?.css);
  watch(
    css,
    (newCss) => {
      newCss = transformCssPropToDeclaration(ids.value, newCss);
      if (rule) {
        sheet.deleteRule(rule);
      }
      rule = sheet.pushDeclaration(
        ids.value.uid,
        "p",
        newCss,
        void 0,
        { ...loc, type: "c" }
      );
    },
    {
      immediate: !rule
    }
  );
  onScopeDispose(() => rule && sheet.deleteRule(rule));
}
function transformCssPropToDeclaration(ids, css) {
  const declaration = {};
  if (css) {
    const targetId = `.${ids.uniqueClassName}${ids.componentId}`;
    declaration[targetId] = Object.assign(declaration[targetId] || {}, css);
  }
  return declaration;
}

const plugin = {
  install(app, {
    theme = {},
    utils = {},
    tokensHelperConfig = {},
    multiApp = false,
    colorSchemeMode = "media",
    dev = process.env.NODE_ENV !== "production"
  }) {
    const themeSheet = usePinceauThemeSheet(theme);
    if (dev && (import.meta.hot || process.server)) {
      import('./chunks/debug.mjs').then(({ usePinceauRuntimeDebug }) => {
        usePinceauRuntimeDebug(tokensHelperConfig);
      });
    }
    const multiAppId = multiApp ? nanoid(6) : void 0;
    const runtimeSheet = usePinceauRuntimeSheet(themeSheet.$tokens, utils, colorSchemeMode, multiAppId);
    function usePinceauRuntime(props, variants, computedStyles) {
      const instance = getCurrentInstance();
      let loc;
      if (dev && (import.meta.hot || process.server)) {
        const { __file: file, __name: name } = instance.vnode.type;
        loc = { file, name };
      }
      const classes = ref({
        v: "",
        c: ""
      });
      const ids = usePinceauRuntimeIds(instance, classes);
      if (computedStyles && computedStyles?.value && Object.keys(computedStyles.value).length > 0) {
        usePinceauComputedStyles(ids, computedStyles, runtimeSheet, loc);
      }
      if (variants && variants?.value && Object.keys(variants.value).length > 0) {
        usePinceauVariants(ids, variants, props, runtimeSheet, classes, loc);
      }
      if (props.value.css && Object.keys(props.value.css).length > 0) {
        usePinceauCssProp(ids, props, runtimeSheet, loc);
      }
      return {
        $pinceau: computed(() => `${classes.value.v} ${classes.value.c}`)
      };
    }
    app.config.globalProperties.$pinceauRuntime = usePinceauRuntime;
    app.config.globalProperties.$pinceauTheme = themeSheet;
    app.config.globalProperties.$pinceauSsr = { get: () => runtimeSheet.toString() };
    app.provide("pinceauRuntime", usePinceauRuntime);
    app.provide("pinceauTheme", themeSheet);
  }
};

function usePinceauRuntime(props, variants, computedStyles) {
  return inject("pinceauRuntime")(props, variants, computedStyles);
}
function usePinceauTheme() {
  return inject("pinceauTheme");
}
const cssProp = {
  type: Object,
  required: false,
  default: void 0
};
function computedStyle(attribute, defaultValue, required = false) {
  return {
    type: [String, Object],
    required,
    default: defaultValue
  };
}

export { computedStyle, createTokensHelper, cssProp, isToken, plugin, resolveCssProperty, scale, stringify, usePinceauRuntime, usePinceauTheme, utils };
