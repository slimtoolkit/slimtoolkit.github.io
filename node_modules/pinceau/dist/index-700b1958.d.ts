import * as vue from 'vue';
import { GeneratedPinceauTheme, GeneratedPinceauPaths } from '#pinceau/theme';
import { GeneratedPinceauUtils } from '#pinceau/utils';
import { ViteDevServer } from 'vite';
import { Schema } from 'untyped';
import * as CSSType from 'csstype';

declare function usePinceauThemeSheet(initialTheme: any, tokensHelperConfig?: {}): {
    $tokens: TokensFunction;
    updateToken: (path: string | string[], value: any, mq?: string) => void;
    updateTheme: (value: PermissiveConfigType<PinceauTheme>) => void;
    reactiveToken: (path: PinceauTokensPaths | ({} & string)) => vue.WritableComputedRef<any>;
    resolveStylesheet: () => void;
    theme: any;
};

type NativeMediaQueries = 'dark' | 'light' | 'initial';
type PinceauTheme = GeneratedPinceauTheme;
type PinceauTokensPaths = GeneratedPinceauPaths;
type PinceauUtils = GeneratedPinceauUtils;
type PinceauMediaQueries = keyof PinceauTheme['media'] extends undefined ? NativeMediaQueries : NativeMediaQueries | keyof PinceauTheme['media'];

type RawTokenType = string | number | string[];
type ResponsiveToken<T> = {
    [key in PinceauMediaQueries]?: T;
} & {
    [key: string]: T;
};
interface DesignToken<T = RawTokenType> {
    /**
     * The raw value of the token.
     */
    value: T | ResponsiveToken<T>;
    /**
     * CSS Variable reference that gets generated out of the token path.
     */
    variable?: string;
    /**
     * Some naming for the token.
     */
    name?: string;
    /**
     * Some comment to help you remember what this token is used for.
     */
    comment?: string;
    /**
     * Is the property live-editable?
     */
    themeable?: boolean;
    /**
     * Is the property using palette()?
     */
    palette?: Boolean;
    /**
     * The original values (not transformed)
     */
    original?: Omit<DesignToken, 'original'>;
    /**
     * Token extraneous attributes.
     */
    attributes?: {
        hsl?: string;
        rgb?: string;
        hex?: string;
        variable?: string;
        category?: string;
        type?: string;
        item?: string;
        subitem?: string;
        state?: string;
        [key: string]: any;
    };
}
interface PinceauTokens {
    [key: string]: PinceauTokens | DesignToken | RawTokenType;
}

interface TokensFunctionOptions {
    /**
     * The key that will be unwrapped from the design token object.
     * @default variable
     */
    key?: 'variable' | 'value' | string;
    /**
     * Called on missing tokens.
     * @default false
     */
    onNotFound?: false | ((path: string, options: TokensFunctionOptions) => void);
    /**
     * The location of the resolved token.
     * Can be useful for logging purposes.
     * @default false
     */
    loc?: any;
}
/**
 * $dt function typing
 */
type DtFunction = (path: PinceauTokensPaths, options?: TokensFunctionOptions) => string;
type TokensFunction = (path?: PinceauTokensPaths | (string & {}), options?: TokensFunctionOptions, theme?: any) => PinceauTokens | DesignToken | number | string;

/**
 * Check if a string is a resolvable token path.
 */
declare function isToken(token: any): boolean;
/**
 * Handles a scale of tokens easily.
 */
declare function scale(type: keyof PinceauTheme & (string & {}), prop: any, scales: ({
    [key in PinceauMediaQueries]?: string;
}) | string, valueTransform?: (token: any) => string): ({
    [key in PinceauMediaQueries]?: string;
}) | string;
declare const utils: {
    isToken: typeof isToken;
    scale: typeof scale;
};

type WrapKey<TKey, TPrefix extends string = '', TSuffix extends string = ''> = TKey extends string ? `${TPrefix}${TKey}${TSuffix}` : never;
type UnwrapKey<TWrappedKey, TPrefix extends string = '', TSuffix extends string = ''> = TWrappedKey extends WrapKey<infer TKey, TPrefix, TSuffix> ? TKey : '';
type WrappedValue<TObject extends object, TWrappedKey extends string, TPrefix extends string = '', TSuffix extends string = ''> = TObject extends {
    [K in UnwrapKey<TWrappedKey, TPrefix, TSuffix>]: infer TValue;
} ? TValue : never;
type PrefixObjectKeys<TObject extends object, TPrefix extends string> = {
    [K in WrapKey<keyof TObject, TPrefix>]: WrappedValue<TObject, K, TPrefix>;
};
type SuffixObjectKeys<TObject extends object, TSuffix extends string> = {
    [K in WrapKey<keyof TObject, TSuffix>]: WrappedValue<TObject, K, '', TSuffix>;
};
type WrapObjectKeys<TObject extends object, TPrefix extends string, TSuffix extends string> = {
    [K in WrapKey<keyof TObject, TPrefix, TSuffix>]: WrappedValue<TObject, K, TPrefix, TSuffix>;
};
type NestedKeyOf<TObject> = {
    [Key in keyof TObject & (string | number)]: TObject[Key] extends object | string ? `${Key}` | `${Key}.${NestedKeyOf<TObject[Key]>}` : `${Key}`;
}[keyof TObject & (string | number)];
type FilterStartingWith<Set, Needle extends string> = Set extends `${Needle}${infer _X}` ? Set : never;
type WrapUnion<TObject extends string | number | symbol, TPrefix extends string, TSuffix extends string> = keyof {
    [K in WrapKey<TObject, TPrefix, TSuffix>]: any;
};
interface VueQuery {
    id: string;
    filename: string;
    vue?: boolean;
    src?: boolean;
    global?: boolean;
    type?: 'script' | 'template' | 'style' | 'custom';
    blockType?: string;
    index?: number;
    locale?: string;
    lang?: string;
    raw?: boolean;
    scoped?: string;
    transformed?: boolean;
    issuerPath?: string;
    css: boolean;
}

interface DefaultThemeMap {
    gap: 'space';
    columnGap: 'space';
    rowGap: 'space';
    inset: 'space';
    insetBlock: 'space';
    insetBlockEnd: 'space';
    insetBlockStart: 'space';
    insetInline: 'space';
    insetInlineEnd: 'space';
    insetInlineStart: 'space';
    margin: 'space';
    marginTop: 'space';
    marginRight: 'space';
    marginBottom: 'space';
    marginLeft: 'space';
    marginBlock: 'space';
    marginBlockEnd: 'space';
    marginBlockStart: 'space';
    marginInline: 'space';
    marginInlineEnd: 'space';
    marginInlineStart: 'space';
    padding: 'space';
    paddingTop: 'space';
    paddingRight: 'space';
    paddingBottom: 'space';
    paddingLeft: 'space';
    paddingBlock: 'space';
    paddingBlockEnd: 'space';
    paddingBlockStart: 'space';
    paddingInline: 'space';
    paddingInlineEnd: 'space';
    paddingInlineStart: 'space';
    scrollMargin: 'space';
    scrollMarginTop: 'space';
    scrollMarginRight: 'space';
    scrollMarginBottom: 'space';
    scrollMarginLeft: 'space';
    scrollMarginBlock: 'space';
    scrollMarginBlockEnd: 'space';
    scrollMarginBlockStart: 'space';
    scrollMarginInline: 'space';
    scrollMarginInlineEnd: 'space';
    scrollMarginInlineStart: 'space';
    scrollPadding: 'space';
    scrollPaddingTop: 'space';
    scrollPaddingRight: 'space';
    scrollPaddingBottom: 'space';
    scrollPaddingLeft: 'space';
    scrollPaddingBlock: 'space';
    scrollPaddingBlockEnd: 'space';
    scrollPaddingBlockStart: 'space';
    scrollPaddingInline: 'space';
    scrollPaddingInlineEnd: 'space';
    scrollPaddingInlineStart: 'space';
    top: 'space';
    right: 'space';
    bottom: 'space';
    left: 'space';
    fontSize: 'fontSize';
    background: 'color';
    backgroundColor: 'color';
    backgroundImage: 'color';
    borderImage: 'color';
    border: 'border';
    borderBlock: 'border';
    borderBlockEnd: 'border';
    borderBlockStart: 'border';
    borderBottom: 'border';
    borderBottomColor: 'border';
    borderColor: 'color';
    borderInline: 'color';
    borderInlineEnd: 'color';
    borderInlineStart: 'color';
    borderLeft: 'color';
    borderLeftColor: 'color';
    borderRight: 'color';
    borderRightColor: 'color';
    borderTop: 'color';
    borderTopColor: 'color';
    caretColor: 'color';
    color: 'color';
    columnRuleColor: 'color';
    outline: 'color';
    outlineColor: 'color';
    fill: 'color';
    stroke: 'color';
    textDecorationColor: 'color';
    fontFamily: 'font';
    fontWeight: 'fontWeight';
    lineHeight: 'lead';
    letterSpacing: 'letterSpacing';
    blockSize: 'size';
    minBlockSize: 'size';
    maxBlockSize: 'size';
    inlineSize: 'size';
    minInlineSize: 'size';
    maxInlineSize: 'size';
    width: 'size';
    minWidth: 'size';
    maxWidth: 'size';
    height: 'size';
    minHeight: 'size';
    maxHeight: 'size';
    flexBasis: 'size';
    gridTemplateColumns: 'size';
    gridTemplateRows: 'size';
    borderWidth: 'borderWidth';
    borderTopWidth: 'borderWidth';
    borderLeftWidth: 'borderWidth';
    borderRightWidth: 'borderWidth';
    borderBottomWidth: 'borderWidth';
    borderRadius: 'radii';
    borderTopLeftRadius: 'radii';
    borderTopRightRadius: 'radii';
    borderBottomRightRadius: 'radii';
    borderBottomLeftRadius: 'radii';
    borderStyle: 'borderStyle';
    boxShadow: 'shadow';
    textShadow: 'shadow';
    transition: 'transition';
    zIndex: 'zIndice';
    opacity: 'opacity';
}

interface VariantOptions<T = any> {
    type?: string;
    required?: boolean;
    default?: T | {
        [key in PinceauMediaQueries]: T;
    };
    mediaPrefix?: boolean;
}
interface BooleanVariant {
    true?: CSSProperties;
    false?: CSSProperties;
}
interface EnumVariant {
    [key: string]: CSSProperties | VariantOptions;
}
interface ClassVariant {
    [key: string]: string | string[] | VariantOptions;
}
type Variant<T = {
    [key: string]: CSSProperties | VariantOptions<any> | string | string[];
}> = (BooleanVariant | EnumVariant | ClassVariant) & {
    options?: VariantOptions<keyof T | string | number | boolean>;
};
interface Variants {
    [key: string]: Variant;
}

type VuePseudos = '&:deep(' | '&:slotted(' | '&:global(';
type AdvancedPseudos = '&::cue(' | '&::cue-region(' | '&::part(' | '&::slotted(' | '&:dir(' | '&:has(' | '&:host(' | '&:host-context(' | '&:is(' | '&:lang(' | '&:not(' | '&:nth-child(' | '&:nth-last-child(' | '&:nth-last-of-type(' | '&:nth-of-type(' | '&:where(';
type SimplePseudos = '&::after' | '&::backdrop' | '&::before' | '&::cue' | '&::cue-region' | '&::first-letter' | '&::first-line' | '&::grammar-error' | '&::marker' | '&::placeholder' | '&::selection' | '&::spelling-error' | '&::target-text' | '&:active' | '&:after' | '&:any-link' | '&:before' | '&:blank' | '&:checked' | '&:current' | '&:default' | '&:defined' | '&:disabled' | '&:empty' | '&:enabled' | '&:first' | '&:first-child' | '&:first-letter' | '&:first-line' | '&:first-of-type' | '&:focus' | '&:focus-visible' | '&:focus-within' | '&:fullscreen' | '&:future' | '&:hover' | '&:in-range' | '&:indeterminate' | '&:invalid' | '&:last-child' | '&:last-of-type' | '&:left' | '&:link' | '&:local-link' | '&:nth-col' | '&:nth-last-col' | '&:only-child' | '&:only-of-type' | '&:optional' | '&:out-of-range' | '&:past' | '&:paused' | '&:picture-in-picture' | '&:placeholder-shown' | '&:read-only' | '&:read-write' | '&:required' | '&:right' | '&:root' | '&:scope' | '&:target' | '&:target-within' | '&:user-invalid' | '&:user-valid' | '&:valid' | '&:visited';
type Pseudos = AdvancedPseudos | SimplePseudos;
type PseudosProperties = {
    [key in Pseudos]?: NativeProperties;
};
interface NativeProperties extends CSSType.StandardProperties, CSSType.StandardShorthandProperties, CSSType.StandardProperties, CSSType.SvgProperties {
}
type ThemeKey<K extends keyof DefaultThemeMap> = WrapUnion<FilterStartingWith<PinceauTokensPaths, DefaultThemeMap[K]>, '{', '}'>;
type SupportedProperties = keyof NativeProperties | keyof DefaultThemeMap;
type PropertyValue<T = string> = (T extends keyof NativeProperties ? T extends keyof DefaultThemeMap ? ThemeKey<T> | NativeProperties[T] : NativeProperties[T] : never);
type UsableTokens = WrapUnion<PinceauTokensPaths, '{', '}'>;

type ComputedStylesUtils = typeof utils;
type ColorSchemeModes = 'media' | 'class';
type ComputedStyleProp = UsableTokens | (string & {}) | ({
    [key in PinceauMediaQueries]: UsableTokens | (string & {});
});
type ComputedStyleDefinition<SupportedProperties = '', TemplateProps = {}> = (props: TemplateProps, utils: ComputedStylesUtils) => PropertyValue<SupportedProperties> | ({
    [key in PinceauMediaQueries]?: PropertyValue<SupportedProperties>;
});
type MappedProperty<K = string, TemplateProps = {}> = PropertyValue<K> | ComputedStyleDefinition<K, TemplateProps>;
type CSSProperties<TemplateProps = {}> = {
    [K in keyof DefaultThemeMap]?: MappedProperty<K, TemplateProps>;
} & {
    [K in keyof NativeProperties]?: MappedProperty<K, TemplateProps>;
} & {
    [K in keyof PseudosProperties]?: CSSProperties<TemplateProps> | {};
} & {
    [K in keyof PinceauUtils]?: UsableTokens | ComputedStyleDefinition<UsableTokens, TemplateProps>;
} & {
    [K in string | number | symbol]: CSSProperties<TemplateProps> | UsableTokens | MappedProperty<K, TemplateProps> | ComputedStyleDefinition<UsableTokens, TemplateProps> | {};
};
type CSSFunctionType<TemplateProps = {}> = {
    variants?: Variants;
} & {
    [K in keyof PinceauUtils]?: UsableTokens;
} & {
    [K in WrapUnion<PinceauMediaQueries, '@', ''>]?: CSSProperties<TemplateProps>;
} & {
    [K in string | number | symbol]: CSSProperties<TemplateProps> | MappedProperty<K, TemplateProps> | {};
};

interface ScaleTokens extends PinceauTokens {
    [key: string]: {
        default?: DesignToken;
        50?: DesignToken;
        100?: DesignToken;
        200?: DesignToken;
        300?: DesignToken;
        400?: DesignToken;
        500?: DesignToken;
        600?: DesignToken;
        700?: DesignToken;
        800?: DesignToken;
        900?: DesignToken;
    } | DesignToken | string;
}
interface BreakpointsTokens extends PinceauTokens {
    '2xs'?: DesignToken;
    xs?: DesignToken;
    sm?: DesignToken;
    md?: DesignToken;
    lg?: DesignToken;
    xl?: DesignToken;
    '2xl'?: DesignToken;
    '3xl'?: DesignToken;
    '4xl'?: DesignToken;
    '5xl'?: DesignToken;
    '6xl'?: DesignToken;
    '7xl'?: DesignToken;
}
interface FontWeightTokens extends PinceauTokens {
    thin?: DesignToken;
    extraLight?: DesignToken;
    light?: DesignToken;
    regular?: DesignToken;
    medium?: DesignToken;
    semiBold?: DesignToken;
    bold?: DesignToken;
    extraBold?: DesignToken;
    black?: DesignToken;
    heavyBlack?: DesignToken;
}
interface ConfigSuggestion {
    color?: ScaleTokens | PinceauTokens;
    font?: PinceauTokens;
    fontWeight?: FontWeightTokens | PinceauTokens;
    fontSize?: BreakpointsTokens | PinceauTokens;
    size?: BreakpointsTokens | PinceauTokens;
    space?: BreakpointsTokens | PinceauTokens;
    radii?: BreakpointsTokens | PinceauTokens;
    border?: BreakpointsTokens | PinceauTokens;
    borderWidth?: BreakpointsTokens | PinceauTokens;
    borderStyle?: BreakpointsTokens | PinceauTokens;
    shadow?: BreakpointsTokens | PinceauTokens;
    opacity?: BreakpointsTokens | PinceauTokens;
    lead?: BreakpointsTokens | PinceauTokens;
    letterSpacing?: BreakpointsTokens | PinceauTokens;
    transition?: PinceauTokens | PinceauTokens;
    zIndex?: PinceauTokens | PinceauTokens;
}

interface LoadConfigResult<T> {
    config: T;
    sources: string[];
}
interface ConfigLayer {
    cwd?: string;
    configFileName?: string;
    tokens?: any;
}
interface ResolvedConfigLayer<T> {
    path: string | undefined;
    schema: Schema;
    config: T;
}
type PinceauUtilsProperties = Record<string, CSSProperties | ((value: any) => CSSProperties)>;
interface ConfigTokens {
    media?: Record<string, DesignToken | RawTokenType>;
    utils?: PinceauUtilsProperties;
}
type PermissiveConfigType<T extends {}> = {
    [K in keyof T]?: T[K] extends (DesignToken | RawTokenType) ? (RawTokenType | ResponsiveToken<RawTokenType> | (T[K] extends DesignToken ? T[K]['value'] : never)) | Partial<T[K]> : PermissiveConfigType<T[K]> | {
        $schema: Schema;
    };
};
type DefineConfigType = ConfigTokens & PermissiveConfigType<(PinceauTheme extends undefined ? ConfigSuggestion : PinceauTheme)>;

type ConfigOrPaths = (string | PinceauTheme | ConfigLayer)[];
interface PinceauContext<UserOptions extends PinceauOptions = PinceauOptions> extends PinceauConfigContext<UserOptions>, PinceauVirtualContext {
    env: 'prod' | 'dev';
    tokens: any;
    utils: any;
    $tokens: TokensFunction;
    options: PinceauOptions;
    transformed: string[];
    addTransformed: (id: string) => void;
    viteServer: ViteDevServer;
    setViteServer(server: ViteDevServer): void;
}
interface PinceauConfigContext<UserOptions = PinceauOptions> {
    cwd: string;
    updateCwd: (newCwd: string) => Promise<LoadConfigResult<PinceauTheme>>;
    sources: string[];
    resolvedConfig: any;
    ready: Promise<LoadConfigResult<PinceauTheme>>;
    reloadConfig: (newOptions?: UserOptions) => Promise<LoadConfigResult<PinceauTheme>>;
    registerConfigWatchers: () => void;
    getConfig: () => Promise<PinceauTheme>;
}
interface ThemeGenerationOutput {
    buildPath: string;
    tokens: any;
    outputs: Record<string, any>;
}
interface PinceauVirtualContext {
    outputs: Record<string, any>;
    updateOutputs: (generatedTheme: ThemeGenerationOutput) => void;
    getOutput: (key: string) => string | undefined;
    getOutputId: (key: string) => string | undefined;
}
interface PinceauTransformContext {
    variants: Record<string, any>;
    computedStyles: Record<string, any>;
}

interface PinceauOptions {
    /**
     * The root directory of your project.
     *
     * @default process.cwd()
     */
    cwd?: string;
    /**
     * The path of your configuration file.
     */
    configLayers?: ConfigOrPaths;
    /**
     * The path of your configuration file.
     *
     * @default 'pinceau.config'
     */
    configFileName?: string;
    /**
     * A callback called each time your config gets resolved.
     */
    configResolved?: (config: any) => void;
    /**
     * The directry in which you store your design tokens.
     *
     * @default 'tokens'
     */
    tokensDir?: string;
    /**
     * The directory in which you want to output the built version of your configuration.
     */
    outputDir?: string;
    /**
     * Imports the default CSS reset in the project.
     *
     * @default true
     */
    preflight?: boolean;
    /**
     * Excluded transform paths.
     */
    excludes?: string[];
    /**
     * Included transform paths.
     */
    includes?: string[];
    /**
     * Toggle follow of symbolic links in glob.
     *
     * Disabling might be useful when testing.
     *
     * Enabling might be useful when using `link`.
     */
    followSymbolicLinks?: boolean;
    /**
     * Toggles color .{dark|light} global classes.
     *
     * If set to class, all @dark and @light clauses will also be generated
     * with .{dark|light} classes on <html> tag as a parent selector.
     *
     * @default 'class'
     */
    colorSchemeMode?: ColorSchemeModes;
    /**
     * Toggles the development mode of Pinceau.
     */
    dev?: boolean;
    /**
     * Enables extra logging on transform failures.
     */
    debug?: boolean | 2;
    /**
     * Enables support for nuxt-component-meta.
     */
    componentMetaSupport?: boolean;
    /**
     * Completely enable or disable Pinceau runtime features.
     */
    runtime?: boolean;
    /**
     * Support for @nuxthq/studio module.
     */
    studio?: boolean;
}
interface ModuleHooks {
    'pinceau:options': (options?: PinceauOptions) => Promise<void> | void;
}
interface ModuleOptions extends PinceauOptions {
}
declare global {
    const $dt: DtFunction;
    const $pinceau: string;
    const __$pProps: any;
}
declare module '@vue/runtime-core' {
    interface ComponentCustomProperties {
        $dt: DtFunction;
        $pinceau: string;
        $pinceauTheme: ReturnType<typeof usePinceauThemeSheet>;
        $pinceauRuntime: any;
    }
}
declare module '@nuxt/schema' {
    interface NuxtHooks {
        'pinceau:options': ModuleHooks['pinceau:options'];
    }
    interface NuxtConfig {
        pinceau?: ModuleOptions;
    }
}

export { Variant as $, TokensFunction as A, RawTokenType as B, ConfigOrPaths as C, DefineConfigType as D, ResponsiveToken as E, FilterStartingWith as F, DesignToken as G, PinceauTokens as H, DefaultThemeMap as I, ScaleTokens as J, BreakpointsTokens as K, LoadConfigResult as L, ModuleHooks as M, NestedKeyOf as N, FontWeightTokens as O, PinceauOptions as P, ConfigSuggestion as Q, ResolvedConfigLayer as R, SuffixObjectKeys as S, ThemeGenerationOutput as T, UnwrapKey as U, VueQuery as V, WrapKey as W, VariantOptions as X, BooleanVariant as Y, EnumVariant as Z, ClassVariant as _, ModuleOptions as a, Variants as a0, VuePseudos as a1, AdvancedPseudos as a2, SimplePseudos as a3, Pseudos as a4, PseudosProperties as a5, NativeProperties as a6, ThemeKey as a7, SupportedProperties as a8, PropertyValue as a9, UsableTokens as aa, usePinceauThemeSheet as ab, isToken as ac, scale as ad, utils as ae, WrappedValue as b, PrefixObjectKeys as c, WrapObjectKeys as d, WrapUnion as e, NativeMediaQueries as f, PinceauTheme as g, PinceauTokensPaths as h, PinceauUtils as i, PinceauMediaQueries as j, PinceauContext as k, PinceauConfigContext as l, PinceauVirtualContext as m, PinceauTransformContext as n, ComputedStylesUtils as o, ColorSchemeModes as p, ComputedStyleProp as q, ComputedStyleDefinition as r, CSSProperties as s, CSSFunctionType as t, ConfigLayer as u, PinceauUtilsProperties as v, ConfigTokens as w, PermissiveConfigType as x, TokensFunctionOptions as y, DtFunction as z };
