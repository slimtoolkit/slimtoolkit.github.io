'use strict';

const fs = require('node:fs');
const path = require('pathe');
const glob = require('fast-glob');
const kit = require('@nuxt/kit');
const jiti = require('jiti');
const unplugin = require('./shared/pinceau.c5e9c4f4.cjs');
const variants = require('./shared/pinceau.407edab2.cjs');
require('vue');
const data = require('./shared/pinceau.7cd078d1.cjs');
require('chroma-js');
require('postcss-nested');
require('postcss-custom-properties');
require('postcss-dark-theme-class');
require('scule');
require('unplugin');
require('magic-string');
require('./shared/pinceau.7e38ce94.cjs');
require('./shared/pinceau.c574f603.cjs');
require('node:fs/promises');
require('style-dictionary-esm');
require('untyped');
require('fs');
require('defu');
require('acorn');
require('vue/compiler-sfc');
require('recast');
require('recast/parsers/typescript.js');
require('ohash');
require('./shared/pinceau.7e4f8cb2.cjs');
require('chalk');
require('consola');
require('perf_hooks');

const module$1 = kit.defineNuxtModule({
  meta: {
    name: "pinceau/nuxt",
    configKey: "pinceau"
  },
  defaults: (nuxt) => ({
    ...unplugin.defaultOptions,
    colorSchemeMode: "class",
    outputDir: path.join(nuxt.options.buildDir, "pinceau/")
  }),
  async setup(options, nuxt) {
    const { stopPerfTimer } = variants.useDebugPerformance("Setup Nuxt module", options.debug);
    const modulePath = kit.createResolver((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('nuxt.cjs', document.baseURI).href)));
    const resolveLocalModule = (path) => kit.resolveModule(path, { paths: modulePath.resolve("./") });
    nuxt.options.build.transpile = nuxt.options.build.transpile || [];
    nuxt.options.build.transpile.push("pinceau", "chroma-js");
    await nuxt.callHook("pinceau:options", options);
    nuxt.options.runtimeConfig.pinceau = { studio: options?.studio, outputDir: options?.outputDir };
    if (options.componentMetaSupport) {
      let cachedTokens;
      nuxt.hook("component-meta:transformers", (transformers) => {
        transformers.push(
          (component, code) => {
            const flatPath = options.outputDir;
            const resolvedTokens = [];
            if (fs.existsSync(path.join(flatPath, "index.ts"))) {
              const _tokens = jiti(flatPath)(path.join(flatPath, "index.ts")).default;
              data.walkTokens(
                _tokens?.theme || _tokens,
                (_, __, paths) => resolvedTokens.push(paths.join("."))
              );
            }
            if (cachedTokens.length) ;
            component.meta.tokens = resolvedTokens;
            return { component, code };
          }
        );
        return transformers;
      });
    }
    nuxt.hook("prepare:types", async (opts) => {
      const tsConfig = opts.tsConfig;
      tsConfig.compilerOptions = tsConfig.compilerOptions || {};
      tsConfig.compilerOptions.paths = tsConfig.compilerOptions.paths || {};
      if (options?.outputDir) {
        tsConfig.compilerOptions.paths["#pinceau/utils"] = [`${path.resolve(options.outputDir, "utils.ts")}`];
        tsConfig.compilerOptions.paths["#pinceau/theme"] = [`${path.resolve(options.outputDir, "index.ts")}`];
        if (options?.studio) {
          tsConfig.compilerOptions.paths["#pinceau/schema"] = [`${path.resolve(options.outputDir, "schema.ts")}`];
        }
      }
      tsConfig.vueCompilerOptions = tsConfig.vueCompilerOptions || {};
      tsConfig.vueCompilerOptions.plugins = tsConfig.vueCompilerOptions.plugins || [];
      tsConfig.vueCompilerOptions.plugins.push("pinceau/volar");
      await unplugin.prepareOutputDir(options);
    });
    if (!nuxt.options.nitro) {
      nuxt.options.nitro = {};
    }
    const nitroConfig = nuxt.options.nitro;
    nitroConfig.plugins = nitroConfig.plugins || [];
    nitroConfig.plugins.push(resolveLocalModule("./nitro"));
    options.configLayers = [
      ...options?.configLayers,
      ...nuxt.options._layers.reduce(
        (acc, layer) => {
          if (typeof layer === "string") {
            acc.push({ cwd: layer, configFileName: options.configFileName });
          }
          if (layer?.cwd) {
            acc.push({ cwd: layer?.cwd, configFileName: options.configFileName });
          }
          return acc;
        },
        []
      )
    ];
    if (options.studio) {
      kit.addPlugin(resolveLocalModule("./runtime/schema.server"));
      kit.addPrerenderRoutes("/__pinceau_tokens_config.json");
      kit.addPrerenderRoutes("/__pinceau_tokens_schema.json");
      const studioAppConfigPath = kit.resolveAlias("~/.studio");
      if (fs.existsSync(studioAppConfigPath)) {
        options.configLayers.unshift({ cwd: studioAppConfigPath, configFileName: "tokens.config" });
      }
    }
    options.cwd = nuxt.options.rootDir;
    for (const layer of options.configLayers) {
      const layerPath = typeof layer === "string" ? layer : layer?.cwd;
      if (layerPath) {
        options.includes?.push(
          ...await glob(
            path.join(layerPath, "**/*.vue"),
            { followSymbolicLinks: options.followSymbolicLinks }
          )
        );
      }
    }
    kit.addPluginTemplate({
      filename: "pinceau-nuxt-plugin.server.mjs",
      mode: "server",
      getContents() {
        const lines = [];
        if (options.runtime) {
          lines.push(
            "import fs from 'node:fs'",
            "import { dirname, join } from 'pathe'",
            "import { useRuntimeConfig } from '#imports'",
            "import { plugin as pinceau } from 'pinceau/runtime'",
            "import utils from '#build/pinceau/utils'",
            "import theme from '#build/pinceau/index'",
            "",
            `export default defineNuxtPlugin(async (nuxtApp) => {
              // Setup plugin
              nuxtApp.vueApp.use(pinceau, { colorSchemeMode: '${options.colorSchemeMode}', theme, utils })

              const { pinceau: runtimeConfig } = useRuntimeConfig()

              // Handle first render of SSR styles
              nuxtApp.hook('app:rendered', async (app) => {
                // Init
                app.ssrContext.event.pinceauContent = app.ssrContext.event.pinceauContent || {}

                // Grab latest theme
                let themeCSS = ''
                try {
                  themeCSS = fs.readFileSync(join(runtimeConfig.outputDir, 'index.css'), 'utf-8')
                } catch (e) {}

                // Theme
                app.ssrContext.event.pinceauContent.theme = themeCSS
                
                // Runtime styling
                const content = app.ssrContext.nuxt.vueApp.config.globalProperties.$pinceauSsr.get()
                app.ssrContext.event.pinceauContent.runtime = content
              })
            })`
          );
        }
        if (options?.preflight) {
          lines.unshift("import '@unocss/reset/tailwind.css'");
        }
        return lines.join("\n");
      }
    });
    kit.addPluginTemplate({
      filename: "pinceau-nuxt-plugin.client.mjs",
      mode: "client",
      getContents() {
        const lines = [];
        if (options.runtime) {
          lines.push(
            "import { plugin as pinceau } from 'pinceau/runtime'",
            "import utils from '#build/pinceau/utils'",
            "",
            `export default defineNuxtPlugin(async (nuxtApp) => {
              // Setup plugin
              nuxtApp.vueApp.use(pinceau, { colorSchemeMode: '${options.colorSchemeMode}', utils })
            })`
          );
        }
        if (options?.preflight) {
          lines.unshift("import '@unocss/reset/tailwind.css'");
        }
        return lines.join("\n");
      }
    });
    nuxt.hook("webpack:config", (config) => {
      config.plugins = config.plugins || [];
      config.plugins.unshift(unplugin.pinceau.webpack(options));
    });
    nuxt.hook("vite:extend", (vite) => {
      vite.config.plugins = vite.config.plugins || [];
      vite.config.plugins.push(unplugin.pinceau.vite(options));
    });
    stopPerfTimer();
  }
});

module.exports = module$1;
