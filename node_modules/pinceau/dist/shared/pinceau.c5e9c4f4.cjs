'use strict';

const unplugin = require('unplugin');
const MagicString = require('magic-string');
const path = require('pathe');
const variants = require('./pinceau.407edab2.cjs');
const stringify = require('./pinceau.7e38ce94.cjs');
require('chroma-js');
require('postcss-nested');
require('postcss-custom-properties');
require('postcss-dark-theme-class');
require('scule');
const theme = require('./pinceau.c574f603.cjs');
const fsp = require('node:fs/promises');
const fs = require('node:fs');
const StyleDictionary = require('style-dictionary-esm');
const data = require('./pinceau.7cd078d1.cjs');
const untyped = require('untyped');
require('vue');
const fs$1 = require('fs');
const jiti = require('jiti');
const defu = require('defu');
require('acorn');
require('vue/compiler-sfc');
require('recast');
require('recast/parsers/typescript.js');
require('ohash');
const sfc = require('./pinceau.7e4f8cb2.cjs');

const stringifyUtils = (value) => {
  const entries = Object.entries(value);
  let result = entries.reduce(
    (acc, [key, value2]) => {
      if (typeof value2 === "function") {
        acc += `  "${key}": ${String(value2)},
`;
      } else {
        acc += `  "${key}": ${JSON.stringify(value2, null, 4)},
`;
      }
      return acc;
    },
    "{\n"
  );
  result += "}";
  return result;
};
const enhanceTokenPaths = (value = []) => {
  const tokensLiteralNodes = [];
  value.forEach(([keyPath]) => {
    tokensLiteralNodes.push(
      variants.astTypes.builders.tsLiteralType(variants.astTypes.builders.stringLiteral(keyPath))
    );
  });
  const ast = variants.astTypes.builders.tsTypeAliasDeclaration(
    variants.astTypes.builders.identifier("GeneratedPinceauPaths"),
    variants.astTypes.builders.tsUnionType(tokensLiteralNodes)
  );
  return variants.printAst(ast).code;
};
function tsFull(tokensObject) {
  let result = "import type { PermissiveConfigType } from 'pinceau'\n\n";
  const flattenedTokens = theme.flattenTokens(tokensObject);
  result += `export const theme = ${JSON.stringify(flattenedTokens, null, 2)} as const

`;
  result += "export type GeneratedPinceauTheme = PermissiveConfigType<typeof theme>\n\n";
  const tokensPaths = theme.objectPaths(tokensObject);
  if (tokensPaths.length) {
    result += `export ${enhanceTokenPaths(tokensPaths)}

`;
  } else {
    result += "export type GeneratedPinceauPaths = ''\n\n";
  }
  result += "export default theme";
  return result;
}
async function schemaFull(tokensObject) {
  const schema = await untyped.resolveSchema({ tokensConfig: tokensObject });
  let result = `export const schema = ${JSON.stringify({ properties: schema.properties.tokensConfig, default: schema.default.tokensConfig }, null, 2)} as const

`;
  result += "export const GeneratedPinceauThemeSchema = typeof schema\n\n";
  return result;
}
const utilsFull = (utils = {}) => {
  let result = `export const utils = ${stringifyUtils(utils)} as const

`;
  result += "export type GeneratedPinceauUtils = typeof utils\n\n";
  result += "export default utils";
  return result;
};
const cssFull = (dictionary, options, responsiveTokens, colorSchemeMode) => {
  const selector = options.selector ? options.selector : ":root";
  const { outputReferences } = options;
  const { formattedVariables } = StyleDictionary.formatHelpers;
  const initialTokens = [];
  data.walkTokens(
    dictionary.tokens,
    (value) => {
      initialTokens.push({
        ...value,
        value: value?.value?.initial || value?.value
      });
      return value;
    }
  );
  let css = `@media {
 ${selector} {
  --pinceau-mq: initial;
${formattedVariables({ format: "css", dictionary: { allTokens: initialTokens }, outputReferences })}
}
}
`;
  Object.entries(responsiveTokens).forEach(
    ([key, value]) => {
      const formattedResponsiveContent = formattedVariables({ format: "css", dictionary: { allTokens: value }, outputReferences });
      let responsiveSelector;
      if (key === "dark" || key === "light") {
        if (colorSchemeMode === "class") {
          responsiveSelector = `:root.${key}`;
        } else {
          responsiveSelector = `@media (prefers-color-scheme: ${key})`;
        }
      } else {
        responsiveSelector = dictionary.allTokens.find((token) => token.name === `media-${key}`)?.value;
      }
      if (responsiveSelector.match(stringify.responsiveMediaQueryRegex)) {
        css += `@media {
 ${responsiveSelector} {
  --pinceau-mq: ${key};
${formattedResponsiveContent}
}
}
`;
      } else {
        css += `
@media ${responsiveSelector} { :root {
  --pinceau-mq: ${key};
${formattedResponsiveContent}
}
}
`;
      }
    }
  );
  return css;
};

async function generateTheme(tokens, { outputDir: buildPath, colorSchemeMode, studio }, silent = true) {
  let styleDictionary = StyleDictionary;
  const files = [
    {
      destination: "index.css",
      format: "pinceau/css"
    },
    {
      destination: "index.ts",
      format: "pinceau/typescript"
    },
    {
      destination: "utils.ts",
      format: "pinceau/utils"
    }
  ];
  const transforms = [
    "size/px",
    "color/hex",
    "pinceau/name",
    "pinceau/variable",
    "pinceau/responsiveTokens"
  ];
  const outputs = {};
  let result = {
    tokens: {},
    outputs: {},
    buildPath
  };
  if (!tokens || typeof tokens !== "object" || !Object.keys(tokens).length) {
    return result;
  }
  const utils = { ...tokens?.utils || {} };
  if (tokens?.utils) {
    delete tokens?.utils;
  }
  const mqKeys = ["dark", "light", ...Object.keys(tokens?.media || {})];
  const responsiveTokens = {};
  styleDictionary.fileHeader = {};
  styleDictionary.registerTransform({
    name: "pinceau/variable",
    type: "attribute",
    matcher: () => true,
    transformer(token) {
      return { variable: `var(--${token.name})` };
    }
  });
  styleDictionary.registerTransform({
    name: "pinceau/name",
    type: "name",
    matcher: () => true,
    transformer(token) {
      if (token.path.join("").includes("-")) {
        variants.message("WRONG_TOKEN_NAMING", [token]);
      }
      return token.path.join("-");
    }
  });
  styleDictionary.registerTransform({
    name: "pinceau/responsiveTokens",
    type: "value",
    transitive: true,
    matcher: (token) => {
      const keys = typeof token.value === "object" ? Object.keys(token.value) : [];
      if (keys && keys.includes("initial") && keys.some((key) => mqKeys.includes(key))) {
        return true;
      }
      return false;
    },
    transformer: (token) => {
      Object.entries(token.value).forEach(
        ([key, value]) => {
          if (key === "initial") {
            return;
          }
          if (!responsiveTokens[key]) {
            responsiveTokens[key] = [];
          }
          const responsiveToken = { ...token, value };
          responsiveTokens[key].push(responsiveToken);
        }
      );
      return token.value;
    }
  });
  styleDictionary.registerTransformGroup({
    name: "pinceau",
    transforms
  });
  styleDictionary.registerFormat({
    name: "pinceau/css",
    formatter({ dictionary, options }) {
      const result2 = cssFull(dictionary, options, responsiveTokens, colorSchemeMode);
      outputs.css = result2.replace(/\n|\s\s/gm, "");
      return result2;
    }
  });
  styleDictionary.registerFormat({
    name: "pinceau/utils",
    formatter() {
      outputs.utils = utilsFull(utils);
      return outputs.utils;
    }
  });
  styleDictionary.registerFormat({
    name: "pinceau/typescript",
    formatter({ dictionary }) {
      outputs.ts = tsFull(dictionary.tokens);
      return outputs.ts;
    }
  });
  styleDictionary = styleDictionary.extend({
    tokens: data.normalizeConfig(tokens, mqKeys, true),
    platforms: {
      prepare: {
        silent,
        transformGroup: "pinceau"
      },
      base: {
        silent,
        transformGroup: "pinceau",
        buildPath,
        files
      },
      done: {
        silent,
        transformGroup: "pinceau",
        actions: ["done"]
      }
    }
  });
  try {
    result = await new Promise(
      (resolve) => {
        styleDictionary.registerAction({
          name: "done",
          do: ({ tokens: tokens2 }) => {
            resolve({
              tokens: theme.flattenTokens(tokens2),
              outputs,
              buildPath
            });
          },
          undo: () => {
          }
        });
        styleDictionary.buildAllPlatforms();
      }
    );
    if (studio) {
      try {
        const schema = await schemaFull(tokens);
        const schemaPath = path.join(buildPath, "schema.ts");
        if (fs.existsSync(schemaPath)) {
          await fsp.unlink(schemaPath);
        }
        await fsp.writeFile(schemaPath, schema, "utf-8");
        result.outputs.schema = schema;
      } catch (e) {
        variants.message("SCHEMA_BUILD_ERROR", [e]);
      }
    }
  } catch (e) {
    variants.message("CONFIG_BUILD_ERROR", [e]);
  }
  return result;
}

const merger = defu.createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = Array.from(/* @__PURE__ */ new Set([...obj[key], ...value]));
    return true;
  }
});

const extensions = [".js", ".ts", ".mjs", ".cjs", ".json"];
function usePinceauConfig(options, getViteServer, getTransformed, dispatchConfigUpdate) {
  let cwd = options?.cwd ?? process.cwd();
  let sources = [];
  let resolvedConfig = {};
  let ready = reloadConfig();
  function registerConfigWatchers() {
    if (!sources.length) {
      return;
    }
    const viteServer = getViteServer();
    viteServer.watcher.add(sources);
    viteServer.watcher.on("change", onConfigChange);
  }
  async function reloadConfig(newOptions = options) {
    const result = await loadConfig(newOptions || options);
    cwd = newOptions?.cwd ?? process.cwd();
    resolvedConfig = result.config;
    sources = result.sources;
    if (dispatchConfigUpdate) {
      dispatchConfigUpdate(result);
    }
    if (options?.configResolved) {
      options.configResolved(result.config);
    }
    return result;
  }
  async function getConfig() {
    await ready;
    return resolvedConfig;
  }
  async function updateCwd(newCwd) {
    if (newCwd !== cwd) {
      cwd = newCwd;
      ready = reloadConfig();
    }
    return await ready;
  }
  async function onConfigChange(p) {
    if (!sources.includes(p)) {
      return;
    }
    const viteServer = getViteServer();
    await reloadConfig();
    const ids = [...stringify.outputFileNames];
    getTransformed().forEach((transformed) => !ids.includes(transformed) && ids.push(transformed));
    for (const id of ids) {
      const _module = viteServer.moduleGraph.getModuleById(id);
      if (!_module) {
        continue;
      }
      viteServer.reloadModule(_module);
    }
  }
  return {
    get ready() {
      return ready;
    },
    get cwd() {
      return cwd;
    },
    updateCwd,
    sources,
    reloadConfig,
    resolvedConfig,
    getConfig,
    registerConfigWatchers
  };
}
async function loadConfig({
  cwd = process.cwd(),
  configLayers = [cwd],
  configFileName = "pinceau.config"
}) {
  let sources = [
    ...configLayers.reduce(
      (acc, layerOrPath) => {
        if (typeof layerOrPath === "object" && (layerOrPath?.cwd || layerOrPath?.configFileName || layerOrPath?.tokens)) {
          acc.push(layerOrPath);
          return acc;
        }
        if (typeof layerOrPath === "object") {
          acc.push({ tokens: layerOrPath });
          return acc;
        }
        if (typeof layerOrPath === "string") {
          acc.push({
            cwd: layerOrPath,
            configFileName
          });
          return acc;
        }
        return acc;
      },
      []
    )
  ].reverse();
  sources = [...new Set(sources)];
  async function resolveConfig(layer) {
    const empty = (path2 = void 0) => ({ path: path2, config: {}, schema: {} });
    let path$1 = "";
    if (typeof layer === "string") {
      path$1 = path.resolve(layer);
    } else if (typeof layer === "object") {
      path$1 = path.resolve(layer?.cwd || cwd, layer?.configFileName || configFileName);
    } else {
      return empty();
    }
    let filePath = "";
    let ext;
    extensions.some((_ext) => {
      if (fs$1.existsSync(path$1 + _ext)) {
        filePath = path$1 + _ext;
        ext = _ext;
        return true;
      }
      return false;
    });
    if (!filePath) {
      return empty();
    }
    try {
      return await loadConfigFile({ path: filePath, ext });
    } catch (e) {
      variants.message("CONFIG_RESOLVE_ERROR", [filePath, e]);
      return empty(filePath);
    }
  }
  const result = {
    config: {},
    sources: []
  };
  for (const layer of sources) {
    const { path, config } = await resolveConfig(layer);
    if (path) {
      result.sources.push(path);
    }
    if (config) {
      result.config = merger(config, result.config);
    }
  }
  return result;
}
async function loadConfigFile({ path, ext }) {
  if (ext === ".json") {
    const config = JSON.parse(await fsp.readFile(path, "utf-8"));
    return {
      config,
      schema: {},
      path
    };
  }
  const configImport = jiti(path, {
    interopDefault: false,
    requireCache: false,
    esmResolve: true
  })(path);
  return {
    config: configImport?.default || configImport,
    schema: configImport?.schema,
    path
  };
}

function usePinceauVirtualStore() {
  const outputs = {
    _css: "/* This file is empty because no tokens has been provided or the configuration is broken. */",
    _ts: tsFull({}),
    _utils: utilsFull({}),
    _schema: "export const schema = {}\nexport const GeneratedPinceauThemeSchema = typeof schema"
  };
  function updateOutputs(generatedTheme) {
    Object.entries(generatedTheme.outputs).forEach(
      ([key, value]) => {
        outputs[`_${key}`] = value;
      }
    );
  }
  function getOutput(id) {
    if (id === "/__pinceau_css.css") {
      return outputs._css;
    }
    if (id === "/__pinceau_ts.ts") {
      return outputs._ts;
    }
    if (id === "/__pinceau_utils.ts") {
      return outputs._utils;
    }
    if (id === "/__pinceau_schema.ts") {
      return outputs._utils;
    }
  }
  function getOutputId(id) {
    if (id.includes("pinceau.css")) {
      return "/__pinceau_css.css";
    }
    if (id.includes("#pinceau/theme")) {
      return "/__pinceau_ts.ts";
    }
    if (id.includes("#pinceau/utils")) {
      return "/__pinceau_utils.ts";
    }
    if (id.includes("#pinceau/schema")) {
      return "/__pinceau_schema.ts";
    }
  }
  return {
    get outputs() {
      return outputs;
    },
    updateOutputs,
    getOutput,
    getOutputId
  };
}

async function prepareOutputDir({
  outputDir = path.join(process.cwd(), "node_modules/.vite/pinceau"),
  studio
}) {
  if (!fs.existsSync(outputDir)) {
    await fsp.mkdir(outputDir, { recursive: true });
  }
  await stubOutputs(outputDir, false, studio);
  return outputDir;
}
async function stubOutputs(buildPath, force = false, schema = false) {
  const files = {
    "index.css": () => "/* This file is empty because no tokens has been provided or your configuration is broken. */",
    "index.ts": tsFull,
    "utils.ts": utilsFull
  };
  if (schema) {
    files["schema.ts"] = schemaFull;
  }
  for (const [file, stubbingFunction] of Object.entries(files)) {
    const path$1 = path.join(buildPath, file);
    if (force && fs.existsSync(path$1)) {
      await fsp.rm(path$1);
    }
    if (!fs.existsSync(path$1)) {
      await fsp.writeFile(path$1, stubbingFunction ? await stubbingFunction({}) : "");
    }
  }
}

const createContext = (options) => {
  const env = "prod";
  const transformed = [];
  const getTransformed = () => transformed;
  let viteServer;
  const getViteServer = () => viteServer;
  let tokens = {};
  const getTokens = () => tokens;
  let utils = {};
  const getUtils = () => utils;
  prepareOutputDir(options);
  const { outputs, getOutput, getOutputId, updateOutputs } = usePinceauVirtualStore();
  const configContext = usePinceauConfig(
    options,
    getViteServer,
    getTransformed,
    async (resolvedConfig) => {
      variants.message("CONFIG_RESOLVED", [resolvedConfig]);
      const { stopPerfTimer } = variants.useDebugPerformance("Build theme", options.debug);
      utils = resolvedConfig.config?.utils || {};
      const builtTheme = await generateTheme(resolvedConfig.config, options);
      if (!builtTheme) {
        stopPerfTimer();
        return;
      }
      updateOutputs(builtTheme);
      tokens = builtTheme.tokens;
      if (viteServer) {
        viteServer.ws.send({
          type: "custom",
          event: "pinceau:themeUpdate",
          data: {
            css: builtTheme.outputs.css,
            theme: theme.flattenTokens(tokens)
          }
        });
      }
      stopPerfTimer();
    }
  );
  return {
    env,
    options,
    get transformed() {
      return getTransformed();
    },
    addTransformed(id) {
      if (!transformed.includes(id)) {
        transformed.push(id);
      }
    },
    get tokens() {
      return getTokens();
    },
    get $tokens() {
      return stringify.createTokensHelper(
        tokens,
        {
          onNotFound(path, options2) {
            variants.message("TOKEN_NOT_FOUND", [path, options2]);
          }
        }
      );
    },
    get utils() {
      return getUtils();
    },
    get viteServer() {
      return getViteServer();
    },
    setViteServer: (server) => {
      viteServer = server;
      configContext.registerConfigWatchers();
    },
    ...configContext,
    outputs,
    getOutput,
    updateOutputs,
    getOutputId
  };
};

function replaceStyleTs(code, id) {
  if (id.endsWith(".vue") && !id.includes("?")) {
    const styleTagRe = /<style\b(.*?)\blang=['"][tj]sx?['"](.*?)>/g;
    if (code.match(styleTagRe)) {
      return code.replace(styleTagRe, '<style$1lang="postcss" transformed$2>');
    }
  }
  return code;
}

const defaultOptions = {
  configFileName: "pinceau.config",
  configLayers: [],
  configResolved: (_) => {
  },
  cwd: process.cwd(),
  outputDir: path.join(process.cwd(), "node_modules/.vite/pinceau/"),
  preflight: true,
  includes: [],
  excludes: [
    "node_modules/nuxt/dist/",
    "node_modules/@nuxt/ui-templates/",
    "node_modules/@vue/",
    "node_modules/pinceau/",
    ...stringify.outputFileNames
  ],
  followSymbolicLinks: true,
  colorSchemeMode: "media",
  debug: false,
  componentMetaSupport: false,
  runtime: true,
  studio: false
};
const pinceau = unplugin.createUnplugin(
  (options) => {
    const { stopPerfTimer } = variants.useDebugPerformance("Setup Unplugin", options.debug);
    options = merger(options, defaultOptions);
    variants.setDebugLevel(options?.dev ? options.debug : false);
    const ctx = createContext(options);
    stopPerfTimer();
    return {
      name: "pinceau",
      enforce: "pre",
      vite: {
        config(config) {
          theme.registerAliases(config, options);
          theme.registerPostCssPlugins(config, options);
        },
        async configResolved(config) {
          await ctx.updateCwd(config.root);
        },
        async configureServer(server) {
          ctx.setViteServer(server);
          ctx.env = "dev";
          await ctx.ready;
        },
        handleHotUpdate(ctx2) {
          const defaultRead = ctx2.read;
          ctx2.read = async function() {
            const code = await defaultRead();
            return replaceStyleTs(code, ctx2.file) || code;
          };
        },
        transformIndexHtml: {
          order: "post",
          handler(html) {
            return html.replace("<pinceau />", `<style id="pinceau-theme">${ctx.getOutput("/__pinceau_css.css")}</style>`);
          }
        }
      },
      transformInclude(id) {
        let toRet;
        const query = theme.parseVueQuery(id);
        if (options.excludes && options.excludes.some((path) => id.includes(path))) {
          toRet = false;
        }
        if (toRet !== false && options.includes && options.includes.some((path) => id.includes(path))) {
          toRet = true;
        }
        if (toRet !== false && (query?.vue || query?.css)) {
          toRet = true;
        }
        if (toRet) {
          ctx.addTransformed(id);
        }
        return toRet;
      },
      transform(code, id) {
        const { stopPerfTimer: stopPerfTimer2 } = variants.useDebugPerformance(`Transforming ${id}`, options.debug);
        code = replaceStyleTs(code, id);
        const query = theme.parseVueQuery(id);
        const magicString = new MagicString(code, { filename: query.filename });
        const result = (code2 = magicString.toString(), ms = magicString) => {
          stopPerfTimer2();
          return { code: code2, map: ms.generateMap({ source: id, includeContent: true }) };
        };
        const missingMap = (code2) => {
          stopPerfTimer2();
          return { code: code2, map: new MagicString(code2, { filename: query.filename }).generateMap() };
        };
        try {
          const loc = { query, source: code };
          if (query.css && !query.vue) {
            const { code: _code2 } = sfc.resolveStyleQuery(code, magicString, query, ctx, loc);
            return missingMap(_code2);
          }
          if (query.type === "style") {
            const { code: _code2 } = sfc.resolveStyleQuery(code, magicString, query, ctx, loc);
            return missingMap(_code2);
          }
          const { code: _code } = sfc.transformVueSFC(code, query, magicString, ctx);
          code = _code;
        } catch (e) {
          variants.message("TRANSFORM_ERROR", [id, e]);
          return missingMap(code);
        }
        return result();
      },
      resolveId(id) {
        return ctx.getOutputId(id);
      },
      load(id) {
        const { stopPerfTimer: stopPerfTimer2 } = variants.useDebugPerformance(`Load ${id}`, options.debug);
        const output = ctx.getOutput(id);
        if (output) {
          stopPerfTimer2();
          return output;
        }
        const query = theme.parseVueQuery(id);
        if (query.vue && query.type === "style") {
          const vueStyle = sfc.transformVueStyle(query, ctx);
          stopPerfTimer2();
          return vueStyle;
        }
      }
    };
  }
);

exports.defaultOptions = defaultOptions;
exports.pinceau = pinceau;
exports.prepareOutputDir = prepareOutputDir;
