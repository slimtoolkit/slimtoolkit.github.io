import { defu } from 'defu';
import { parse as parse$2 } from 'acorn';
import 'vue';
import { s as stringify, a as resolveCssProperty } from './pinceau.5247c7c8.mjs';
import 'chroma-js';
import 'pathe';
import 'postcss-nested';
import 'postcss-custom-properties';
import 'postcss-dark-theme-class';
import chalk from 'chalk';
import consola from 'consola';
import { performance } from 'perf_hooks';
import { hash } from 'ohash';
import { camelCase, kebabCase } from 'scule';
import { parse } from 'vue/compiler-sfc';
import * as recast from 'recast';
import { parse as parse$1 } from 'recast/parsers/typescript.js';

let debugLevel = false;
const setDebugLevel = (newDebugLevel) => debugLevel = newDebugLevel;
const getDebugLevel = () => debugLevel;
const logger = consola.withScope(" \u{1F58C} ");
const fileLink = (id) => logger.log(`\u{1F517} ${chalk.blue(id)}
`);
const errorMessage = (message2) => logger.log(`\u{1F6A7} ${chalk.yellow(message2)}
`);
const DEBUG_MARKER = chalk.bgBlue.blue(" DEBUG ");
const debugMarker = (text, timing) => logger.info(`${DEBUG_MARKER} ${text} ${timing ? `[${timing}ms]` : ""}`);
const messages = {
  TRANSFORM_ERROR: (debugLevel2, id, error) => {
    logger.error("Pinceau could not transform this file:");
    fileLink(id);
    error?.message && errorMessage(error.message);
  },
  CONFIG_RESOLVE_ERROR: (debugLevel2, path, error) => {
    logger.error("Pinceau could not resolve this configuration file:");
    const loc = error?.loc?.start?.line ? `${error.loc.start.line}:${error.loc.start.column}` : "";
    fileLink(`${path}${loc}`);
    error?.message && errorMessage(error.message);
  },
  CONFIG_BUILD_ERROR: (debugLevel2, error) => {
    logger.error("Pinceau could not build your design tokens configuration!\n");
    logger.log(error);
  },
  CONFIG_RESOLVED: (debugLevel2, resolvedConfig) => {
    if (debugLevel2) {
      logger.log("\u{1F3A8} Pinceau loaded with following configuration sources:\n");
      resolvedConfig.sources.forEach((path) => fileLink(path));
      logger.log("\u{1F6A7} Disable this message by setting `debug: false` option.\n");
      logger.log(`\u{1F6A7} Current debug level: ${chalk.blue(Number(debugLevel2))}
`);
    }
  },
  TOKEN_NOT_FOUND: (debugLevel2, path, options) => {
    if (options?.loc?.query && !options.loc.query?.type) {
      logger.warn(`Token not found in static CSS: ${chalk.red(path)}`);
      const { line: lineOffset, column: columnOffset } = findLineColumn(options.loc.source, `{${path}}`);
      if (!options.loc?.start) {
        options.loc.start = findLineColumn(options.loc.source, "css({");
      }
      const line = (options.loc?.start?.line || 0) + lineOffset;
      const column = (options.loc?.start?.column || 0) + columnOffset;
      logger.log(`\u{1F517} ${options.loc.query.filename}${line && column ? `:${line}:${column}
` : ""}`);
    }
  },
  SELECTOR_CONFLICT: (debugLevel2, selector) => {
    logger.warn("You seem to be using a conflicting selector:");
    logger.log(`\u2753 ${selector}
`);
    logger.log("If you want to combine `@dark` or `@light` with `html` selector, consider using `html.dark` or `html.light`.\n");
  },
  WRONG_TOKEN_NAMING: (debugLevel2, token) => {
    logger.error(`Invalid token name: ${chalk.red(token.path.join("-"))}`);
    logger.log("Token paths can not contains the following characters: `.` or `-`\n");
    logger.log("These paths keys also has to only contains characters supported in CSS stylesheets.\n");
  },
  SCHEMA_BUILD_ERROR: (debugLevel2, _) => {
    if (debugLevel2) {
      logger.warn("Pinceau could not build your schema.ts file!");
      logger.log("Design tokens editor might be hidden from Nuxt Studio.");
    }
  }
};
const message = (id, options) => messages[id].bind(void 0, getDebugLevel(), ...options)();

const useDebugPerformance = (text, debug, logOnStop = true) => {
  const isDebug = debug === 2;
  const performanceTimerStart = performance.now();
  let performanceTimerStop;
  return {
    stopPerfTimer: isDebug ? stop : () => {
    },
    logPerfTimer: isDebug ? debugMarker(text, timing()) : () => {
    }
  };
  function timing() {
    let count = Number(parseFloat(`${performanceTimerStop - performanceTimerStart}`).toFixed(2));
    if (isNaN(count)) {
      count = 0;
    }
    let color = chalk.greenBright;
    if (count > 1) {
      color = chalk.green;
    }
    if (count > 3) {
      color = chalk.yellowBright;
    }
    if (count > 5) {
      color = chalk.yellow;
    }
    if (count > 8) {
      color = chalk.redBright;
    }
    if (count > 10) {
      color = chalk.red;
    }
    if (count > 20) {
      color = chalk.red.underline;
    }
    return color(count);
  }
  function stop(silent = false) {
    if (silent) {
      return;
    }
    performanceTimerStop = performance.now();
    if (logOnStop) {
      debugMarker(text, timing());
    }
  }
};
function findLineColumn(content, index) {
  const lines = content.split("\n");
  let line;
  let column;
  lines.forEach((lineContent, lineIndex) => {
    if (lineContent.includes(index)) {
      line = lineIndex;
      column = lineContent.indexOf(index) + 1;
    }
  });
  return {
    line,
    column
  };
}

function parseAst(source, options) {
  return recast.parse(source, defu({ parser: { parse: parse$1 } }, options));
}
function parseVueComponent(source, options = {}) {
  return parse(source, options);
}
function expressionToAst(type, leftSide = "const toAst = ", kind = "js") {
  const parsed = recast.parse(`${leftSide}${type}`, { parser: { parse: parse$1 } });
  return kind === "js" ? parsed.program.body[0].declarations[0].init : parsed.program.body[0].typeAnnotation;
}
const visitAst = recast.visit;
const printAst = recast.print;
const astTypes = recast.types;

function resolveComputedStyles(cssAst, computedStyles = {}) {
  visitAst(
    cssAst,
    {
      visitObjectProperty(path) {
        if (path.value) {
          const valueType = path.value.value.type;
          if (valueType === "ArrowFunctionExpression" || valueType === "FunctionExpression") {
            const key = camelCase((path.value.key.name || path.value.key.value).replace(/--/g, "__"));
            const id = `_${hash(path.value.loc.start).slice(0, 3)}_${key}`;
            computedStyles[id] = printAst(path.value.value.body).code;
            path.replace(
              astTypes.builders.objectProperty(
                path.value.key,
                astTypes.builders.stringLiteral(`var(--${kebabCase(id)})`)
              )
            );
          }
        }
        return this.traverse(path);
      }
    }
  );
}

const transformCssFunction = (id, code = "", variants = {}, computedStyles, ctx, loc) => {
  try {
    parse$2(code, { ecmaVersion: "latest" });
  } catch (e) {
    e.loc.line = loc.start.line + e.loc.line - 1;
    const filePath = `${id.split("?")[0]}:${e.loc.line}:${e.loc.column}`;
    message("TRANSFORM_ERROR", [filePath, e]);
    return "";
  }
  const declaration = resolveCssCallees(
    code,
    (ast) => evalCssDeclaration(ast, computedStyles)
  );
  if (declaration && declaration?.variants) {
    Object.assign(variants, defu(variants || {}, declaration?.variants || {}));
    delete declaration.variants;
  }
  return stringify(declaration, (property, value, _style, _selectors) => resolveCssProperty(property, value, _style, _selectors, ctx, loc));
};
function resolveCssCallees(code, cb) {
  const ast = parseAst(code);
  let result = false;
  visitAst(ast, {
    visitCallExpression(path) {
      if (path.value.callee.name === "css") {
        result = defu(result || {}, cb(path.value.arguments[0]));
      }
      return this.traverse(path);
    }
  });
  return result;
}
function evalCssDeclaration(cssAst, computedStyles = {}) {
  resolveComputedStyles(cssAst, computedStyles);
  try {
    const _eval = eval;
    _eval(`var cssDeclaration = ${printAst(cssAst).code}`);
    return cssDeclaration;
  } catch (e) {
    return {};
  }
}

function transformVariants(code = "", variants = {}, isTs) {
  const variantsProps = resolveVariantsProps(variants, isTs);
  const sanitizedVariants = Object.entries(variants || {}).reduce(
    (acc, [key, variant]) => {
      delete variant.options;
      acc[key] = variant;
      return acc;
    },
    {}
  );
  code += `
const __$pVariants = ref(${JSON.stringify(sanitizedVariants)})
`;
  if (variantsProps) {
    code = pushVariantsProps(code, variantsProps);
  }
  return code;
}
function pushVariantsProps(code, variantsProps) {
  const scriptAst = parseAst(code);
  let propsAst = expressionToAst(JSON.stringify(variantsProps));
  propsAst = castVariantsPropsAst(propsAst);
  visitAst(
    scriptAst,
    {
      visitCallExpression(path) {
        if (path?.value?.callee?.name === "defineProps") {
          path.value.arguments[0].properties.push(
            astTypes.builders.spreadElement(propsAst)
          );
        }
        return this.traverse(path);
      }
    }
  );
  return printAst(scriptAst).code;
}
function resolveVariantsProps(variants, isTs) {
  const props = {};
  Object.entries(variants).forEach(
    ([key, variant]) => {
      const prop = {
        required: false
      };
      const isBooleanVariant = Object.keys(variant).some((key2) => key2 === "true" || key2 === "false");
      if (isBooleanVariant) {
        prop.type = isTs ? "[Boolean, Object] as PropType<boolean & ({ [key in PinceauMediaQueries]?: boolean })>" : "[Boolean, Object]";
        prop.default = false;
      } else {
        const possibleValues = `'${Object.keys(variant).filter((key2) => key2 !== "options").join("' | '")}'`;
        prop.type = isTs ? `[String, Object] as PropType<${possibleValues} & ({ [key in PinceauMediaQueries]?: ${possibleValues} })>` : "[String, Object]";
        prop.default = void 0;
      }
      if (variant?.options) {
        const options = variant.options;
        if (options.default) {
          prop.default = options.default;
        }
        if (options.required) {
          prop.required = options.required;
        }
        if (options.type) {
          prop.type = options.type;
        }
        if (options.validator) {
          prop.validator = options.validator.toString();
        }
      }
      props[key] = prop;
    }
  );
  return props;
}
function castVariantsPropsAst(ast) {
  visitAst(
    ast,
    {
      visitObjectProperty(path) {
        if (path.value?.key?.value === "type") {
          path.value.value = expressionToAst(path.value.value.value);
        }
        if (path.value?.key?.value === "validator") {
          path.value.value = expressionToAst(path.value.value.value);
        }
        return this.traverse(path);
      }
    }
  );
  return ast;
}

export { astTypes as a, parseVueComponent as b, parseAst as c, transformVariants as d, expressionToAst as e, castVariantsPropsAst as f, resolveCssCallees as g, evalCssDeclaration as h, message as m, printAst as p, resolveVariantsProps as r, setDebugLevel as s, transformCssFunction as t, useDebugPerformance as u, visitAst as v };
