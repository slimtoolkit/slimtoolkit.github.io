'use strict';

const vue = require('vue');
const data = require('./pinceau.7cd078d1.cjs');
const scule = require('scule');

const referencesRegex = new RegExp(
  "\\{([^}]+)\\}",
  "g"
);
const keyRegex = /{(.*)}/g;
const cssContentRegex = /css\(({.*?\})\)/mgs;
const mqPlainRegex = /@([^\s]+)/g;
const mqCssRegex = /@([^\s]+)\s{/g;
const darkRegex = /(@dark\s{)/g;
const lightRegex = /(@light\s{)/g;
const DARK = "@dark";
const LIGHT = "@light";
const INITIAL = "@initial";
const dtRegex = /\$dt\('(.*?)'\)/g;
const variantsRegex = /(...)?variants(,)?/mg;
const responsiveMediaQueryRegex = /^(:|\.)/;
const outputFileNames = [
  "/__pinceau_css.css",
  "/__pinceau_ts.ts",
  "/__pinceau_utils.ts"
];

function createTokensHelper(theme = {}, options = {}) {
  const defaultHelperOptions = {
    key: "attributes.variable",
    onNotFound: false,
    ...options
  };
  function $tokens(path = void 0, options2) {
    if (!path) {
      return vue.unref(theme);
    }
    const $tokensOptions = { ...defaultHelperOptions, ...options2 };
    const { key, onNotFound } = $tokensOptions;
    const token = data.get(vue.unref(theme), path);
    if (!token && typeof onNotFound === "function") {
      onNotFound(path, $tokensOptions);
      return;
    }
    return key ? token ? token[key] ? token[key] : data.get(token, key) : token : token;
  }
  return $tokens.bind(this);
}
function transformTokensToVariable(property) {
  return (property || "").replace(keyRegex, (_, tokenPath) => resolveVariableFromPath(tokenPath));
}
function resolveVariableFromPath(path) {
  return `var(${pathToVarName(path)})`;
}
function pathToVarName(path) {
  if (Array.isArray(path)) {
    path = path.join("-");
  }
  if (path.charAt(0) === "{" && path.charAt(path.length - 1) === "}") {
    path = path.substr(1, path.length - 2);
  }
  return `--${path.split(".").join("-")}`;
}

function resolveCssProperty(property, value, style, selectors, ctx, loc) {
  const directive = resolveCustomDirectives(property, value, selectors, ctx, loc);
  if (directive) {
    return directive;
  }
  if (ctx.utils[property]) {
    if (typeof ctx.utils[property] === "function") {
      return ctx.utils[property](value);
    }
    return value ? ctx.utils[property] : {};
  }
  value = castValues(property, value, ctx, loc);
  return {
    [property]: value
  };
}
function castValues(property, value, ctx, loc) {
  if (Array.isArray(value) || typeof value === "string" || typeof value === "number") {
    if (Array.isArray(value)) {
      value = value.map((v) => castValue(property, v, ctx, loc)).join(",");
    } else {
      value = castValue(property, value, ctx, loc);
    }
  }
  return value;
}
function castValue(property, value, ctx, loc) {
  if (typeof value === "number") {
    return value;
  }
  if (value.match(referencesRegex)) {
    value = resolveReferences(property, value, ctx, loc);
  }
  if (value === "{}") {
    return "";
  }
  return value;
}
function resolveReferences(_, value, ctx, loc) {
  if (!(typeof value === "string")) {
    return value;
  }
  value = value.replace(
    referencesRegex,
    (_2, tokenPath) => {
      const token = ctx.$tokens(tokenPath, { key: void 0, loc });
      const tokenValue = typeof token === "string" ? token : token?.variable || token?.value;
      if (!tokenValue) {
        return `var(${pathToVarName(tokenPath)})`;
      }
      return tokenValue;
    }
  );
  return value;
}
function resolveCustomDirectives(property, value, selectors, ctx, loc) {
  if (property.startsWith("@")) {
    const resolveColorScheme = (scheme) => {
      scheme = ctx.options.colorSchemeMode === "class" ? `:root.${scheme} &` : `@media (prefers-color-scheme: ${scheme})`;
      return {
        [scheme]: value
      };
    };
    if (property === DARK) {
      return resolveColorScheme("dark");
    }
    if (property === LIGHT) {
      return resolveColorScheme("light");
    }
    if (property === INITIAL) {
      const token = ctx.$tokens("media.initial", { key: "value", onNotFound: false, loc });
      return {
        [`@media${token ? ` ${token}` : ""}`]: value
      };
    }
    const mediaQueries = ctx.$tokens("media", { key: void 0, loc });
    if (mediaQueries) {
      const query = property.replace("@", "");
      if (mediaQueries[query]) {
        return {
          [`@media ${mediaQueries[query].value}`]: value
        };
      }
    }
    return {
      [property]: value
    };
  }
}

const comma = /\s*,\s*(?![^()]*\))/;
const getResolvedSelectors = (parentSelectors, nestedSelectors) => parentSelectors.reduce(
  (resolvedSelectors, parentSelector) => {
    resolvedSelectors.push(
      ...nestedSelectors.map(
        (selector) => selector.includes("&") ? selector.replace(
          /&/g,
          /[ +>|~]/.test(parentSelector) && /&.*&/.test(selector) ? `:is(${parentSelector})` : parentSelector
        ) : `${parentSelector} ${selector}`
      )
    );
    return resolvedSelectors;
  },
  []
);
const { prototype: { toString } } = Object;
const stringify = (value, replacer = void 0) => {
  const used = /* @__PURE__ */ new WeakSet();
  const write = (cssText, selectors, conditions, name, data, isAtRuleLike) => {
    for (let i = 0; i < conditions.length; ++i) {
      if (!used.has(conditions[i])) {
        used.add(conditions[i]);
        cssText += `${conditions[i]}{`;
      }
    }
    if (selectors.length && !used.has(selectors)) {
      used.add(selectors);
      cssText += `${selectors}{`;
    }
    if (isAtRuleLike) {
      name = `${name} `;
    } else {
      name = `${scule.kebabCase(name)}:`;
    }
    cssText += `${name + String(data)};`;
    return cssText;
  };
  const parse = (style, selectors, conditions, prevName, prevData) => {
    let cssText = "";
    for (const name in style) {
      const isAtRuleLike = name.charCodeAt(0) === 64;
      for (const data of isAtRuleLike && Array.isArray(style[name]) ? style[name] : [style[name]]) {
        if (replacer && (name !== prevName || data !== prevData)) {
          const next = replacer(name, data, style, selectors);
          if (next !== null) {
            cssText += typeof next === "object" && next ? parse(next, selectors, conditions, name, data) : next == null ? "" : next;
            continue;
          }
        }
        const isObjectLike = typeof data === "object" && data && data.toString === toString;
        if (isObjectLike) {
          if (used.has(selectors)) {
            used.delete(selectors);
            cssText += "}";
          }
          const usedName = Object(name);
          let nextSelectors;
          if (isAtRuleLike) {
            nextSelectors = selectors;
            cssText += parse(
              data,
              nextSelectors,
              conditions.concat(usedName)
            );
          } else {
            nextSelectors = selectors.length ? getResolvedSelectors(selectors, name.split(comma)) : name.split(comma);
            cssText += parse(
              data,
              nextSelectors,
              conditions
            );
          }
          if (used.has(usedName)) {
            used.delete(usedName);
            cssText += "}";
          }
          if (used.has(nextSelectors)) {
            used.delete(nextSelectors);
            cssText += "}";
          }
        } else {
          cssText = write(cssText, selectors, conditions, name, data, isAtRuleLike);
        }
      }
    }
    return cssText;
  };
  return parse(value, [], []);
};

exports.DARK = DARK;
exports.INITIAL = INITIAL;
exports.LIGHT = LIGHT;
exports.castValue = castValue;
exports.castValues = castValues;
exports.createTokensHelper = createTokensHelper;
exports.cssContentRegex = cssContentRegex;
exports.darkRegex = darkRegex;
exports.dtRegex = dtRegex;
exports.getResolvedSelectors = getResolvedSelectors;
exports.keyRegex = keyRegex;
exports.lightRegex = lightRegex;
exports.mqCssRegex = mqCssRegex;
exports.mqPlainRegex = mqPlainRegex;
exports.outputFileNames = outputFileNames;
exports.pathToVarName = pathToVarName;
exports.referencesRegex = referencesRegex;
exports.resolveCssProperty = resolveCssProperty;
exports.resolveCustomDirectives = resolveCustomDirectives;
exports.resolveReferences = resolveReferences;
exports.resolveVariableFromPath = resolveVariableFromPath;
exports.responsiveMediaQueryRegex = responsiveMediaQueryRegex;
exports.stringify = stringify;
exports.transformTokensToVariable = transformTokensToVariable;
exports.variantsRegex = variantsRegex;
