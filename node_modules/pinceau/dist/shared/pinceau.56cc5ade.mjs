import * as path from 'pathe';
import { join } from 'pathe';
import postCssNested from 'postcss-nested';
import postCssCustomProperties from 'postcss-custom-properties';
import postCssDarkThemeClass from 'postcss-dark-theme-class';
import { w as walkTokens } from './pinceau.97e4e32f.mjs';

function registerAliases(config, options) {
  if (!config?.resolve) {
    config.resolve = {};
  }
  if (!config.resolve?.alias) {
    config.resolve.alias = {};
  }
  if (options?.outputDir) {
    config.resolve.alias["#pinceau/types"] = join(options.outputDir, "/types.ts");
    config.resolve.alias["#pinceau/theme"] = join(options.outputDir, "/index.ts");
    config.resolve.alias["#pinceau/utils"] = join(options.outputDir, "/utils.ts");
  }
}
function registerPostCssPlugins(config, options) {
  if (!config?.css) {
    config.css = {};
  }
  if (!config.css?.postcss) {
    config.css.postcss = {};
  }
  if (!config.css?.postcss.plugins) {
    config.css.postcss.plugins = [];
  }
  config.css.postcss.plugins.push(
    postCssNested,
    postCssCustomProperties
  );
  if (options?.colorSchemeMode === "class") {
    config.css.postcss.plugins.push(
      postCssDarkThemeClass({
        darkSelector: ".dark",
        lightSelector: ".light"
      })
    );
  }
}

function parseVueQuery(id) {
  const [filename, rawQuery] = id.split("?", 2);
  const params = new URLSearchParams(rawQuery);
  const ret = {
    filename,
    id
  };
  const langPart = Object.keys(Object.fromEntries(params)).find((key) => /lang\./i.test(key));
  ret.vue = params.has("vue") || id.endsWith(".vue");
  ret.global = params.has("global");
  ret.src = params.has("src");
  ret.raw = params.has("raw");
  if (params.has("type")) {
    ret.type = params.get("type");
  }
  if (params.has("blockType")) {
    ret.blockType = params.get("blockType");
  }
  if (params.has("index")) {
    ret.index = Number(params.get("index"));
  }
  if (params.has("scoped")) {
    ret.scoped = String(params.get("scoped"));
  }
  if (langPart) {
    const [, lang] = langPart.split(".");
    ret.lang = lang;
  } else if (params.has("lang")) {
    ret.lang = params.get("lang");
  }
  if (params.has("issuerPath")) {
    ret.issuerPath = params.get("issuerPath");
  }
  if (params.has("transformed")) {
    ret.transformed = true;
  }
  const ext = path.extname(id);
  if ([".css", ".postcss", ".styl", ".stylus", ".sass", ".scss", ".less"].includes(ext)) {
    ret.css = true;
  }
  return ret;
}

const objectPaths = (data) => {
  const output = [];
  function step(obj, prev) {
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      const isarray = Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isobject = type === "[object Object]" || type === "[object Array]";
      const newKey = prev ? `${prev}.${key}` : key;
      if ((typeof value?.value !== "undefined" || typeof value === "string") && !output.includes(newKey)) {
        output.push([newKey, value?.value || value]);
        return;
      }
      if (!isarray && isobject && Object.keys(value).length) {
        return step(value, newKey);
      }
    });
  }
  step(data);
  return output;
};
const flattenTokens = (data, toValue = false) => {
  return walkTokens(data, (value) => {
    return toValue ? value?.value : {
      value: value?.value,
      variable: value?.attributes?.variable
    };
  });
};

export { registerPostCssPlugins as a, flattenTokens as f, objectPaths as o, parseVueQuery as p, registerAliases as r };
