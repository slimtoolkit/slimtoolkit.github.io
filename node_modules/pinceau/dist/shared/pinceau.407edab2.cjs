'use strict';

const defu = require('defu');
const acorn = require('acorn');
require('vue');
const stringify = require('./pinceau.7e38ce94.cjs');
require('chroma-js');
require('pathe');
require('postcss-nested');
require('postcss-custom-properties');
require('postcss-dark-theme-class');
const chalk = require('chalk');
const consola = require('consola');
const perf_hooks = require('perf_hooks');
const ohash = require('ohash');
const scule = require('scule');
const compilerSfc = require('vue/compiler-sfc');
const recast = require('recast');
const typescript_js = require('recast/parsers/typescript.js');

function _interopNamespaceDefault(e) {
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const recast__namespace = /*#__PURE__*/_interopNamespaceDefault(recast);

let debugLevel = false;
const setDebugLevel = (newDebugLevel) => debugLevel = newDebugLevel;
const getDebugLevel = () => debugLevel;
const logger = consola.withScope(" \u{1F58C} ");
const fileLink = (id) => logger.log(`\u{1F517} ${chalk.blue(id)}
`);
const errorMessage = (message2) => logger.log(`\u{1F6A7} ${chalk.yellow(message2)}
`);
const DEBUG_MARKER = chalk.bgBlue.blue(" DEBUG ");
const debugMarker = (text, timing) => logger.info(`${DEBUG_MARKER} ${text} ${timing ? `[${timing}ms]` : ""}`);
const messages = {
  TRANSFORM_ERROR: (debugLevel2, id, error) => {
    logger.error("Pinceau could not transform this file:");
    fileLink(id);
    error?.message && errorMessage(error.message);
  },
  CONFIG_RESOLVE_ERROR: (debugLevel2, path, error) => {
    logger.error("Pinceau could not resolve this configuration file:");
    const loc = error?.loc?.start?.line ? `${error.loc.start.line}:${error.loc.start.column}` : "";
    fileLink(`${path}${loc}`);
    error?.message && errorMessage(error.message);
  },
  CONFIG_BUILD_ERROR: (debugLevel2, error) => {
    logger.error("Pinceau could not build your design tokens configuration!\n");
    logger.log(error);
  },
  CONFIG_RESOLVED: (debugLevel2, resolvedConfig) => {
    if (debugLevel2) {
      logger.log("\u{1F3A8} Pinceau loaded with following configuration sources:\n");
      resolvedConfig.sources.forEach((path) => fileLink(path));
      logger.log("\u{1F6A7} Disable this message by setting `debug: false` option.\n");
      logger.log(`\u{1F6A7} Current debug level: ${chalk.blue(Number(debugLevel2))}
`);
    }
  },
  TOKEN_NOT_FOUND: (debugLevel2, path, options) => {
    if (options?.loc?.query && !options.loc.query?.type) {
      logger.warn(`Token not found in static CSS: ${chalk.red(path)}`);
      const { line: lineOffset, column: columnOffset } = findLineColumn(options.loc.source, `{${path}}`);
      if (!options.loc?.start) {
        options.loc.start = findLineColumn(options.loc.source, "css({");
      }
      const line = (options.loc?.start?.line || 0) + lineOffset;
      const column = (options.loc?.start?.column || 0) + columnOffset;
      logger.log(`\u{1F517} ${options.loc.query.filename}${line && column ? `:${line}:${column}
` : ""}`);
    }
  },
  SELECTOR_CONFLICT: (debugLevel2, selector) => {
    logger.warn("You seem to be using a conflicting selector:");
    logger.log(`\u2753 ${selector}
`);
    logger.log("If you want to combine `@dark` or `@light` with `html` selector, consider using `html.dark` or `html.light`.\n");
  },
  WRONG_TOKEN_NAMING: (debugLevel2, token) => {
    logger.error(`Invalid token name: ${chalk.red(token.path.join("-"))}`);
    logger.log("Token paths can not contains the following characters: `.` or `-`\n");
    logger.log("These paths keys also has to only contains characters supported in CSS stylesheets.\n");
  },
  SCHEMA_BUILD_ERROR: (debugLevel2, _) => {
    if (debugLevel2) {
      logger.warn("Pinceau could not build your schema.ts file!");
      logger.log("Design tokens editor might be hidden from Nuxt Studio.");
    }
  }
};
const message = (id, options) => messages[id].bind(void 0, getDebugLevel(), ...options)();

const useDebugPerformance = (text, debug, logOnStop = true) => {
  const isDebug = debug === 2;
  const performanceTimerStart = perf_hooks.performance.now();
  let performanceTimerStop;
  return {
    stopPerfTimer: isDebug ? stop : () => {
    },
    logPerfTimer: isDebug ? debugMarker(text, timing()) : () => {
    }
  };
  function timing() {
    let count = Number(parseFloat(`${performanceTimerStop - performanceTimerStart}`).toFixed(2));
    if (isNaN(count)) {
      count = 0;
    }
    let color = chalk.greenBright;
    if (count > 1) {
      color = chalk.green;
    }
    if (count > 3) {
      color = chalk.yellowBright;
    }
    if (count > 5) {
      color = chalk.yellow;
    }
    if (count > 8) {
      color = chalk.redBright;
    }
    if (count > 10) {
      color = chalk.red;
    }
    if (count > 20) {
      color = chalk.red.underline;
    }
    return color(count);
  }
  function stop(silent = false) {
    if (silent) {
      return;
    }
    performanceTimerStop = perf_hooks.performance.now();
    if (logOnStop) {
      debugMarker(text, timing());
    }
  }
};
function findLineColumn(content, index) {
  const lines = content.split("\n");
  let line;
  let column;
  lines.forEach((lineContent, lineIndex) => {
    if (lineContent.includes(index)) {
      line = lineIndex;
      column = lineContent.indexOf(index) + 1;
    }
  });
  return {
    line,
    column
  };
}

function parseAst(source, options) {
  return recast__namespace.parse(source, defu.defu({ parser: { parse: typescript_js.parse } }, options));
}
function parseVueComponent(source, options = {}) {
  return compilerSfc.parse(source, options);
}
function expressionToAst(type, leftSide = "const toAst = ", kind = "js") {
  const parsed = recast__namespace.parse(`${leftSide}${type}`, { parser: { parse: typescript_js.parse } });
  return kind === "js" ? parsed.program.body[0].declarations[0].init : parsed.program.body[0].typeAnnotation;
}
const visitAst = recast__namespace.visit;
const printAst = recast__namespace.print;
const astTypes = recast__namespace.types;

function resolveComputedStyles(cssAst, computedStyles = {}) {
  visitAst(
    cssAst,
    {
      visitObjectProperty(path) {
        if (path.value) {
          const valueType = path.value.value.type;
          if (valueType === "ArrowFunctionExpression" || valueType === "FunctionExpression") {
            const key = scule.camelCase((path.value.key.name || path.value.key.value).replace(/--/g, "__"));
            const id = `_${ohash.hash(path.value.loc.start).slice(0, 3)}_${key}`;
            computedStyles[id] = printAst(path.value.value.body).code;
            path.replace(
              astTypes.builders.objectProperty(
                path.value.key,
                astTypes.builders.stringLiteral(`var(--${scule.kebabCase(id)})`)
              )
            );
          }
        }
        return this.traverse(path);
      }
    }
  );
}

const transformCssFunction = (id, code = "", variants = {}, computedStyles, ctx, loc) => {
  try {
    acorn.parse(code, { ecmaVersion: "latest" });
  } catch (e) {
    e.loc.line = loc.start.line + e.loc.line - 1;
    const filePath = `${id.split("?")[0]}:${e.loc.line}:${e.loc.column}`;
    message("TRANSFORM_ERROR", [filePath, e]);
    return "";
  }
  const declaration = resolveCssCallees(
    code,
    (ast) => evalCssDeclaration(ast, computedStyles)
  );
  if (declaration && declaration?.variants) {
    Object.assign(variants, defu.defu(variants || {}, declaration?.variants || {}));
    delete declaration.variants;
  }
  return stringify.stringify(declaration, (property, value, _style, _selectors) => stringify.resolveCssProperty(property, value, _style, _selectors, ctx, loc));
};
function resolveCssCallees(code, cb) {
  const ast = parseAst(code);
  let result = false;
  visitAst(ast, {
    visitCallExpression(path) {
      if (path.value.callee.name === "css") {
        result = defu.defu(result || {}, cb(path.value.arguments[0]));
      }
      return this.traverse(path);
    }
  });
  return result;
}
function evalCssDeclaration(cssAst, computedStyles = {}) {
  resolveComputedStyles(cssAst, computedStyles);
  try {
    const _eval = eval;
    _eval(`var cssDeclaration = ${printAst(cssAst).code}`);
    return cssDeclaration;
  } catch (e) {
    return {};
  }
}

function transformVariants(code = "", variants = {}, isTs) {
  const variantsProps = resolveVariantsProps(variants, isTs);
  const sanitizedVariants = Object.entries(variants || {}).reduce(
    (acc, [key, variant]) => {
      delete variant.options;
      acc[key] = variant;
      return acc;
    },
    {}
  );
  code += `
const __$pVariants = ref(${JSON.stringify(sanitizedVariants)})
`;
  if (variantsProps) {
    code = pushVariantsProps(code, variantsProps);
  }
  return code;
}
function pushVariantsProps(code, variantsProps) {
  const scriptAst = parseAst(code);
  let propsAst = expressionToAst(JSON.stringify(variantsProps));
  propsAst = castVariantsPropsAst(propsAst);
  visitAst(
    scriptAst,
    {
      visitCallExpression(path) {
        if (path?.value?.callee?.name === "defineProps") {
          path.value.arguments[0].properties.push(
            astTypes.builders.spreadElement(propsAst)
          );
        }
        return this.traverse(path);
      }
    }
  );
  return printAst(scriptAst).code;
}
function resolveVariantsProps(variants, isTs) {
  const props = {};
  Object.entries(variants).forEach(
    ([key, variant]) => {
      const prop = {
        required: false
      };
      const isBooleanVariant = Object.keys(variant).some((key2) => key2 === "true" || key2 === "false");
      if (isBooleanVariant) {
        prop.type = isTs ? "[Boolean, Object] as PropType<boolean & ({ [key in PinceauMediaQueries]?: boolean })>" : "[Boolean, Object]";
        prop.default = false;
      } else {
        const possibleValues = `'${Object.keys(variant).filter((key2) => key2 !== "options").join("' | '")}'`;
        prop.type = isTs ? `[String, Object] as PropType<${possibleValues} & ({ [key in PinceauMediaQueries]?: ${possibleValues} })>` : "[String, Object]";
        prop.default = void 0;
      }
      if (variant?.options) {
        const options = variant.options;
        if (options.default) {
          prop.default = options.default;
        }
        if (options.required) {
          prop.required = options.required;
        }
        if (options.type) {
          prop.type = options.type;
        }
        if (options.validator) {
          prop.validator = options.validator.toString();
        }
      }
      props[key] = prop;
    }
  );
  return props;
}
function castVariantsPropsAst(ast) {
  visitAst(
    ast,
    {
      visitObjectProperty(path) {
        if (path.value?.key?.value === "type") {
          path.value.value = expressionToAst(path.value.value.value);
        }
        if (path.value?.key?.value === "validator") {
          path.value.value = expressionToAst(path.value.value.value);
        }
        return this.traverse(path);
      }
    }
  );
  return ast;
}

exports.astTypes = astTypes;
exports.castVariantsPropsAst = castVariantsPropsAst;
exports.evalCssDeclaration = evalCssDeclaration;
exports.expressionToAst = expressionToAst;
exports.message = message;
exports.parseAst = parseAst;
exports.parseVueComponent = parseVueComponent;
exports.printAst = printAst;
exports.resolveCssCallees = resolveCssCallees;
exports.resolveVariantsProps = resolveVariantsProps;
exports.setDebugLevel = setDebugLevel;
exports.transformCssFunction = transformCssFunction;
exports.transformVariants = transformVariants;
exports.useDebugPerformance = useDebugPerformance;
exports.visitAst = visitAst;
