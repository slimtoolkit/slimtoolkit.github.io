'use strict';

const variants = require('./pinceau.407edab2.cjs');
require('vue');
const stringify = require('./pinceau.7e38ce94.cjs');
require('chroma-js');
require('pathe');
require('postcss-nested');
require('postcss-custom-properties');
require('postcss-dark-theme-class');
const scule = require('scule');
const fs = require('fs');

const transformDtHelper = (code, wrapper = void 0) => {
  const replace = (path) => `${wrapper || ""}var(--${path.split(".").map((key) => scule.kebabCase(key)).join("-")})${wrapper || ""}`;
  code = code.replace(stringify.dtRegex, (_, path) => replace(path));
  return code;
};

const transformVueStyle = (query, ctx) => {
  const { filename } = query;
  const file = fs.readFileSync(filename, "utf8");
  const { descriptor } = variants.parseVueComponent(file, { filename });
  const style = descriptor?.styles?.[query.index];
  if (!style) {
    return;
  }
  let source = style?.content || "";
  const loc = { query, ...style.loc };
  if (style.attrs.lang === "ts") {
    source = variants.transformCssFunction(query.id, source, void 0, void 0, ctx, loc);
  }
  source = transformStyle(source, ctx, loc);
  if (style?.content !== source) {
    return source;
  }
};
function transformStyle(code = "", ctx, loc) {
  code = transformDtHelper(code);
  code = transformMediaQueries(code, ctx, loc);
  code = transformScheme(code, "dark");
  code = transformScheme(code, "light");
  return code;
}
function transformScheme(code = "", scheme) {
  const schemesRegex = {
    light: stringify.lightRegex,
    dark: stringify.darkRegex
  };
  code = code.replace(
    schemesRegex[scheme],
    () => `@media (prefers-color-scheme: ${scheme}) {`
  );
  return code;
}
function transformMediaQueries(code = "", ctx, loc) {
  const mediaQueries = ctx.$tokens("media", { key: void 0, loc });
  code = code.replace(
    stringify.mqCssRegex,
    (declaration, query) => {
      const mediaQuery = mediaQueries?.[query];
      if (!mediaQuery) {
        return declaration;
      }
      return `@media ${mediaQuery.value} {`;
    }
  );
  return code;
}

function transformAddPropsKey(code, add = true) {
  try {
    const ast = variants.parseAst(code);
    let propsKey;
    let hasDefineProps;
    let hasWithDefaults;
    variants.visitAst(
      ast,
      {
        visitVariableDeclaration(path) {
          if (path.value?.declarations?.[0]?.init?.callee?.name === "defineProps") {
            propsKey = path.value.declarations[0].id.name;
            return false;
          }
          return this.traverse(path);
        },
        visitCallExpression(path) {
          if (path.node.callee.name === "defineProps") {
            hasDefineProps = true;
            return false;
          }
          if (path.node.callee.name === "withDefaults") {
            hasWithDefaults = true;
          }
          return this.traverse(path);
        }
      }
    );
    if (add && hasDefineProps && !propsKey) {
      code = code.replace(
        /defineProps|withDefaults\(defineProps/,
        () => {
          propsKey = "__$pProps";
          return `const __$pProps = ${hasWithDefaults ? "withDefaults(defineProps" : "defineProps"}`;
        }
      );
    }
    return { propsKey, code };
  } catch (e) {
    return void 0;
  }
}

function transformAddPinceauClass(code) {
  if (code.includes("$pinceau")) {
    return code;
  }
  let firstTag = code.match(/<([a-zA-Z]+)([^>]+)*>/);
  if (firstTag?.[0]) {
    const _source = String(firstTag[0]);
    if (_source.includes(":class")) {
      const existingAttr = _source.match(/:class="([^"]+)"/);
      if (existingAttr) {
        let attrAst = variants.expressionToAst(existingAttr[1]);
        const newAttrAst = variants.astTypes.builders.identifier("$pinceau");
        switch (attrAst.type) {
          case "ArrayExpression":
            attrAst.elements.push(newAttrAst);
            break;
          case "StringLiteral":
          case "Literal":
            attrAst = variants.astTypes.builders.arrayExpression([
              existingAttr
            ]);
            break;
          case "ObjectExpression":
            attrAst = variants.astTypes.builders.arrayExpression([
              attrAst,
              newAttrAst
            ]);
            break;
        }
        firstTag = _source.replace(existingAttr[1], variants.printAst(attrAst).code);
      }
    } else if (_source.includes("/>")) {
      firstTag = _source.replace("/>", ' :class="[$pinceau]" />');
    } else {
      firstTag = _source.replace(">", ' :class="[$pinceau]">');
    }
    code = code.replace(_source, firstTag);
  }
  return code;
}

function transformVueSFC(code, query, magicString, ctx) {
  const variants$1 = {};
  const computedStyles = {};
  const parsedComponent = variants.parseVueComponent(code, { filename: query.id });
  if (parsedComponent.descriptor.styles) {
    resolveStyle(query.id, parsedComponent, magicString, variants$1, computedStyles, ctx, query);
  }
  const hasRuntimeStyles = Object.keys(variants$1).length > 0 || Object.keys(computedStyles).length > 0;
  if (parsedComponent.descriptor.template) {
    resolveTemplate(
      query.id,
      parsedComponent,
      magicString,
      hasRuntimeStyles
    );
  }
  if (parsedComponent.descriptor.scriptSetup) {
    resolveScriptSetup(
      query.id,
      parsedComponent,
      magicString,
      variants$1,
      computedStyles,
      parsedComponent.descriptor.scriptSetup.lang === "ts"
    );
  }
  return { code, magicString };
}
function resolveStyleQuery(code, magicString, query, ctx, loc) {
  if (query.lang === "ts") {
    code = variants.transformCssFunction(query.id, code, void 0, void 0, ctx, loc);
  }
  code = transformStyle(code, ctx);
  return { code, magicString };
}
function resolveTemplate(_, parsedComponent, magicString, hasRuntimeStyles) {
  const templateContent = parsedComponent.descriptor.template;
  let newTemplateContent = templateContent.content;
  newTemplateContent = transformDtHelper(newTemplateContent, "'");
  if (hasRuntimeStyles) {
    newTemplateContent = transformAddPinceauClass(newTemplateContent);
  }
  if (templateContent.loc.end?.offset && templateContent.loc.end?.offset > templateContent.loc.start.offset) {
    magicString.overwrite(templateContent.loc.start.offset, templateContent.loc.end.offset, newTemplateContent);
  }
}
function resolveStyle(id, parsedComponent, magicString, variants$1, computedStyles, ctx, query) {
  const styles = parsedComponent.descriptor.styles;
  styles.forEach(
    (styleBlock) => {
      const { loc, content } = styleBlock;
      let code = content;
      if (styleBlock.attrs.lang === "ts" || styleBlock.lang === "ts" || styleBlock.attrs?.transformed) {
        code = variants.transformCssFunction(id, code, variants$1, computedStyles, ctx, { query, ...loc });
      }
      code = transformStyle(code, ctx);
      magicString.remove(loc.start.offset, loc.end.offset);
      magicString.appendRight(loc.end.offset, `
${code}
`);
    }
  );
}
function resolveScriptSetup(id, parsedComponent, magicString, variants$1, computedStyles, isTs) {
  const scriptSetup = parsedComponent.descriptor.scriptSetup;
  const hasVariants = Object.keys(variants$1).length;
  const hasComputedStyles = Object.keys(computedStyles).length;
  let code = scriptSetup.content;
  code = transformDtHelper(code, "`");
  code = code.replace(stringify.variantsRegex, () => "");
  if (hasVariants || hasComputedStyles) {
    code = transformAddRuntimeImports(code);
  }
  if (hasVariants) {
    code = variants.transformVariants(code, variants$1, isTs);
  }
  if (hasComputedStyles) {
    code = transformComputedStyles(code, computedStyles);
  }
  if (hasVariants || hasComputedStyles) {
    code = transformFinishRuntimeSetup(code, hasComputedStyles, hasVariants, computedStyles);
  }
  magicString.overwrite(scriptSetup.loc.start.offset, scriptSetup.loc.end.offset, code);
}
function transformComputedStyles(code, computedStyles) {
  code = Object.entries(computedStyles).map(
    ([key, styleFunction]) => {
      return `
const ${key} = computed(() => ((props = __$pProps, utils = __$pUtils) => ${styleFunction})())
`;
    }
  ).join("\n") + code;
  return code;
}
function transformAddRuntimeImports(code) {
  code = `
import { usePinceauRuntime, utils as __$pUtils } from 'pinceau/runtime'
${code}`;
  if (!code.match(/reactive\(/gm)) {
    code = `
import { reactive } from 'vue'
${code}`;
  }
  if (!code.match(/computed\(/gm)) {
    code = `
import { computed } from 'vue'
${code}`;
  }
  if (!code.match(/getCurrentInstance\(/gm)) {
    code = `
import { getCurrentInstance } from 'vue'
${code}`;
  }
  if (!code.match(/ref\(/gm)) {
    code = `
import { ref } from 'vue'
${code}`;
  }
  const { propsKey, code: _code } = transformAddPropsKey(code);
  code = _code;
  if (propsKey && propsKey === "__$pProps") {
    return code;
  }
  code += `
const __$pProps = ${propsKey || "{}"}
`;
  return code;
}
function transformFinishRuntimeSetup(newScriptSetup, hasComputedStyles, hasVariants, computedStyles) {
  newScriptSetup += [
    `
${hasVariants || hasComputedStyles ? "const { $pinceau } = " : ""}`,
    "usePinceauRuntime(",
    "computed(() => __$pProps),",
    `${hasVariants ? "__$pVariants" : "undefined"},`,
    `${hasComputedStyles ? `ref({ ${Object.keys(computedStyles).map((key) => `${key}`).join(",")} })` : "undefined"}`,
    ") \n"
  ].join("");
  return newScriptSetup;
}

exports.resolveScriptSetup = resolveScriptSetup;
exports.resolveStyle = resolveStyle;
exports.resolveStyleQuery = resolveStyleQuery;
exports.resolveTemplate = resolveTemplate;
exports.transformVueSFC = transformVueSFC;
exports.transformVueStyle = transformVueStyle;
