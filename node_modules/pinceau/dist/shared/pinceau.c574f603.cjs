'use strict';

const path = require('pathe');
const postCssNested = require('postcss-nested');
const postCssCustomProperties = require('postcss-custom-properties');
const postCssDarkThemeClass = require('postcss-dark-theme-class');
const data = require('./pinceau.7cd078d1.cjs');

function _interopNamespaceDefault(e) {
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);

function registerAliases(config, options) {
  if (!config?.resolve) {
    config.resolve = {};
  }
  if (!config.resolve?.alias) {
    config.resolve.alias = {};
  }
  if (options?.outputDir) {
    config.resolve.alias["#pinceau/types"] = path.join(options.outputDir, "/types.ts");
    config.resolve.alias["#pinceau/theme"] = path.join(options.outputDir, "/index.ts");
    config.resolve.alias["#pinceau/utils"] = path.join(options.outputDir, "/utils.ts");
  }
}
function registerPostCssPlugins(config, options) {
  if (!config?.css) {
    config.css = {};
  }
  if (!config.css?.postcss) {
    config.css.postcss = {};
  }
  if (!config.css?.postcss.plugins) {
    config.css.postcss.plugins = [];
  }
  config.css.postcss.plugins.push(
    postCssNested,
    postCssCustomProperties
  );
  if (options?.colorSchemeMode === "class") {
    config.css.postcss.plugins.push(
      postCssDarkThemeClass({
        darkSelector: ".dark",
        lightSelector: ".light"
      })
    );
  }
}

function parseVueQuery(id) {
  const [filename, rawQuery] = id.split("?", 2);
  const params = new URLSearchParams(rawQuery);
  const ret = {
    filename,
    id
  };
  const langPart = Object.keys(Object.fromEntries(params)).find((key) => /lang\./i.test(key));
  ret.vue = params.has("vue") || id.endsWith(".vue");
  ret.global = params.has("global");
  ret.src = params.has("src");
  ret.raw = params.has("raw");
  if (params.has("type")) {
    ret.type = params.get("type");
  }
  if (params.has("blockType")) {
    ret.blockType = params.get("blockType");
  }
  if (params.has("index")) {
    ret.index = Number(params.get("index"));
  }
  if (params.has("scoped")) {
    ret.scoped = String(params.get("scoped"));
  }
  if (langPart) {
    const [, lang] = langPart.split(".");
    ret.lang = lang;
  } else if (params.has("lang")) {
    ret.lang = params.get("lang");
  }
  if (params.has("issuerPath")) {
    ret.issuerPath = params.get("issuerPath");
  }
  if (params.has("transformed")) {
    ret.transformed = true;
  }
  const ext = path__namespace.extname(id);
  if ([".css", ".postcss", ".styl", ".stylus", ".sass", ".scss", ".less"].includes(ext)) {
    ret.css = true;
  }
  return ret;
}

const objectPaths = (data) => {
  const output = [];
  function step(obj, prev) {
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      const isarray = Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isobject = type === "[object Object]" || type === "[object Array]";
      const newKey = prev ? `${prev}.${key}` : key;
      if ((typeof value?.value !== "undefined" || typeof value === "string") && !output.includes(newKey)) {
        output.push([newKey, value?.value || value]);
        return;
      }
      if (!isarray && isobject && Object.keys(value).length) {
        return step(value, newKey);
      }
    });
  }
  step(data);
  return output;
};
const flattenTokens = (data$1, toValue = false) => {
  return data.walkTokens(data$1, (value) => {
    return toValue ? value?.value : {
      value: value?.value,
      variable: value?.attributes?.variable
    };
  });
};

exports.flattenTokens = flattenTokens;
exports.objectPaths = objectPaths;
exports.parseVueQuery = parseVueQuery;
exports.registerAliases = registerAliases;
exports.registerPostCssPlugins = registerPostCssPlugins;
