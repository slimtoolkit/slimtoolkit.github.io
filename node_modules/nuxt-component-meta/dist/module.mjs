import { readFileSync } from 'fs';
import { defineNuxtModule, createResolver, resolveModule, addImportsDir, addTemplate, addServerHandler } from '@nuxt/kit';
import { join } from 'pathe';
import { withoutLeadingSlash } from 'ufo';
import { createUnplugin } from 'unplugin';
import { useComponentMetaParser } from './parser.mjs';
import 'fs/promises';
import 'perf_hooks';
import 'vue-component-meta';
import 'consola';

const metaPlugin = createUnplugin(
  ({ parser, ...options }) => {
    const instance = parser || useComponentMetaParser(options);
    return {
      name: "vite-plugin-nuxt-component-meta",
      enforce: "post",
      async buildStart() {
        await instance.fetchComponents();
        await instance.updateOutput();
      },
      vite: {
        async handleHotUpdate({ file }) {
          if (Object.entries(instance.components).some(([, comp]) => comp.fullPath === file)) {
            await instance.fetchComponent(file);
            await instance.updateOutput();
          }
        }
      }
    };
  }
);

const module = defineNuxtModule({
  meta: {
    name: "nuxt-component-meta",
    configKey: "componentMeta"
  },
  defaults: (nuxt) => ({
    outputDir: nuxt.options.buildDir,
    rootDir: nuxt.options.rootDir,
    componentDirs: [],
    components: [],
    silent: true,
    exclude: ["nuxt/dist/app/components/client-only", "nuxt/dist/app/components/dev-only"],
    transformers: [
      (component, code) => {
        if (!code.includes("<script")) {
          code += "\n<script setup>defineProps()<\/script>";
        }
        return { code, component };
      },
      (component, code) => {
        code = code.replace(
          /<ContentSlot(.*)?:use="\$slots\.([a-z]+)"(.*)\/>/gm,
          (_, _before, slotName, _rest) => {
            return `<slot ${slotName === "default" ? "" : `name="${slotName}"`} />`;
          }
        );
        return { component, code };
      }
    ],
    checkerOptions: {
      forceUseTs: true,
      schema: {
        ignore: [
          "NuxtComponentMetaNames",
          "RouteLocationRaw",
          "RouteLocationPathRaw",
          "RouteLocationNamedRaw",
          "ComputedStyleProp",
          "VariantProp"
        ]
      }
    }
  }),
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url);
    let parser;
    let transformers = options?.transformers || [];
    transformers = await nuxt.callHook("component-meta:transformers", transformers);
    let componentDirs = [...options?.componentDirs || []];
    let components = [];
    nuxt.hook("components:dirs", (dirs) => {
      componentDirs = [
        ...componentDirs,
        ...dirs,
        { path: resolveModule("nuxt").replace("/index.mjs", "/app") },
        { path: resolveModule("@nuxt/ui-templates").replace("/index.mjs", "/templates") }
      ];
      options.componentDirs = componentDirs;
    });
    nuxt.hook("components:extend", async (_components) => {
      components = _components;
      options.components = components;
      parser = useComponentMetaParser(options);
      await parser.stubOutput();
    });
    addImportsDir(resolver.resolve("./runtime/composables"));
    addTemplate({
      filename: "component-meta.mjs",
      getContents: () => "export default {}",
      write: true
    });
    addTemplate({
      filename: "component-meta.d.ts",
      getContents: () => [
        "import type { NuxtComponentMeta } from 'nuxt-component-meta'",
        "export type { NuxtComponentMeta }",
        `export type NuxtComponentMetaNames = ${components.map((c) => `'${c.pascalName}'`).join(" | ")}`,
        "declare const components: Record<NuxtComponentMetaNames, NuxtComponentMeta>",
        "export { components as default,  components }"
      ].join("\n"),
      write: true
    });
    nuxt.hook("vite:extend", (vite) => {
      vite.config.plugins = vite.config.plugins || [];
      vite.config.plugins.push(metaPlugin.vite({ ...options, parser }));
    });
    nuxt.options.alias = nuxt.options.alias || {};
    nuxt.options.alias["#nuxt-component-meta"] = join(nuxt.options.buildDir, "component-meta.mjs");
    nuxt.options.alias["#nuxt-component-meta/types"] = join(nuxt.options.buildDir, "component-meta.d.ts");
    nuxt.hook("prepare:types", ({ tsConfig, references }) => {
      references.push({
        path: join(nuxt.options.buildDir, "component-meta.d.ts")
      });
      tsConfig.compilerOptions = tsConfig.compilerOptions || {};
      tsConfig.compilerOptions.paths = tsConfig.compilerOptions.paths || {};
      tsConfig.compilerOptions.paths["#nuxt-component-meta"] = [withoutLeadingSlash(join(nuxt.options.buildDir, "/component-meta.mjs").replace(nuxt.options.rootDir, ""))];
      tsConfig.compilerOptions.paths["#nuxt-component-meta/types"] = [withoutLeadingSlash(join(nuxt.options.buildDir, "/component-meta.d.ts").replace(nuxt.options.rootDir, ""))];
    });
    nuxt.hook("nitro:config", (nitroConfig) => {
      nitroConfig.handlers = nitroConfig.handlers || [];
      nitroConfig.virtual = nitroConfig.virtual || {};
      nitroConfig.virtual["#nuxt-component-meta/nitro"] = () => readFileSync(join(nuxt.options.buildDir, "/component-meta.mjs"), "utf-8");
    });
    addServerHandler({
      method: "get",
      route: "/api/component-meta",
      handler: resolver.resolve("./runtime/server/api/component-meta.get")
    });
    addServerHandler({
      method: "get",
      route: "/api/component-meta/:component?",
      handler: resolver.resolve("./runtime/server/api/component-meta.get")
    });
  }
});

export { module as default };
